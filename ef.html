<!DOCTYPE html>
<html>
    
<body>

<div id="contextMenu"> 
    <ul>
    </ul>
</div>

<div id="selfLoopMenu">
    <ul>
    </ul>
</div>

<dialog id="grid_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="grid_form">
    <table cellpadding="3">
    <tr><td colspan="2" align="center"># Rows: <input type="text" id="num_rows" size=3 value="3">&nbsp;&nbsp;&nbsp;# Columns: <input id="num_cols" type="text" size=3 value="3"></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" colspan="2">Pixel separation: <input id="separation" value="30" size=3 align="right">&nbsp;&nbsp;&nbsp;(Minimum 20)</td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" colspan="2"><input type="checkbox" id="l1_connect" name="l1_connect" value="yes" checked> L1 connect nodes</td></tr>
    <tr><td colspan="2"><input type="radio" id="via_undirected_edges" name="edge_dir" value="undirected" checked><label>Via Undirected Edges</label><input type="radio" id="via_directed_edges" name="edge_dir" value="directed"><label>Via Directed Edges</label></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" rowspan="2">Order:</td><td><input type="radio" id="order_tb_lr" name="order" value="order_tb_lr" checked><label>Top to Bottom, then Left to Right</label></td></tr>
    <tr><td><input type="radio" id="order_lr_tb" name="order" value="order_lr_tb"><label>Left to Right, then Top to Bottom</label></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td colspan="2" align="center"><input type="Submit" id="grid_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="gridDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<dialog id="cycle_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="cycle_form">
    <table cellpadding="3">
    <tr><td colspan="2" align="center">Height (in pixels): <input type="text" id="height" size=4 value="100">&nbsp;&nbsp;&nbsp;Width (in pixels): <input id="width" type="text" size=4 value="100"></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" colspan="2"># of Nodes: <input id="num_nodes" value="10" size=3 align="right"></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td colspan="2">Connect via: <input type="radio" id="via_undir_edges" name="edge_dir" value="undirected" checked><label>Undirected Edges</label><input type="radio" id="via_dir_edges" name="edge_dir" value="directed"><label>Directed Edges</label></td></tr>
     <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td colspan="2" align="center"><input type="Submit" id="cycle_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="cycleDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<dialog id="iconization_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="iconization_form">
    <table cellpadding="3">
    <tr><td align="left" colspan="2">Iconize to a (an): &nbsp;&nbsp;<select id="n_gon" onchange="redrawSamplePolygon()"><option value="3">Equilateral Triangle</option><option value="4">Square</option><option value="5">Regular Pentagon</option><option value="6">Regular Hexagon</option><option value="7">Regular Heptagon</option><option value="8">Regular Octagon</option></select></td></tr>
    <!--<tr><td colspan="2">&nbsp;</td></tr>-->
    <tr><td align="left" colspan="2">Circumcircle radius: <select id="radius" onchange="redrawSamplePolygon()"><option value="20">20</option><option value="25">25</option><option value="30">30</option><option value="35">35</option><option value="40">40</option></select>&nbsp;&nbsp;pixels</td></tr>
    <tr><td align="left" colspan="2">Fill color:</td></tr>
    </table>

    <table cellpadding="6">
    <tr>
    <td><input type="radio" id="color" name="color" value="cyan"  onclick="redrawSamplePolygon()" checked/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="cyan"/>
    </svg>
    <td><input type="radio" id="color" name="color" value="chartreuse" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="chartreuse"/>
    </svg>
    </td>
    <td><input type="radio" id="color" name="color" value="orange" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="orange"/>
    </svg>
    </td>
    </tr>

    <tr>
    <td><input type="radio" id="color" name="color" value="brown" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="brown"/>
    </svg>
    <td><input type="radio" id="color" name="color" value="purple" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="purple"/>
    </svg>
    </td>
    <td><input type="radio" id="color" name="color" value="grey" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="grey"/>
    </svg>
    </td>
    </tr>
    </table>
    <table>
    <tr><td colspan=3>Label (3 chars max):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="text" id="label" style="text-align: center;" size=3 maxlength=3 value="" oninput="redrawSamplePolygon()"> </td></tr>    
    </table>
    <table width="100%">
    <canvas id="iconization-canvas" width="270" height="100"></canvas>
    <tr><td colspan="2" align="center"><input type="Submit" id="ico_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="iconizationDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<dialog id="new_game_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="new_game_form">
    <table cellpadding="3">
    <tr><td align="left">Number of Rounds: <input type="text" id="num_rounds" size=4 value="5"> </td></tr>
    <tr><td>&nbsp;</td></tr>
    <tr><td align="left"><input type="checkbox" id="comp_spoiler" name="comp_spoiler" value="true"/>Computer plays Spoiler</td></tr>
    <tr><td align="left"><input type="checkbox" id="comp_duplicator" name="comp_duplicator" value="true"/>Computer plays Duplicator</td></tr>
    <!--
    <tr><td>&nbsp;</td></tr>
    <tr><td align="left"><input type="checkbox" id="comp_analysis" name="comp_analysis" value="true"/>Produce Computer Analysis</td></tr>
    -->
    <tr><td>&nbsp;</td></tr>
    <tr><td align="center"><input type="Submit" id="new_game_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="cycleDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<nav id="topMenu"></nav>

<canvas id="mainCanvas"></canvas> 
<script>

document.body.style.overflow = 'hidden'; //prevents coordinate problems when scrolling

class Rectangle {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
}

nodes = new Set()
edges = new Set()
iconizedGroups = new Set() 
ultraEdges = new Set()

selected_nodes = new Set()
selected_edges = new Set()
selected_ultraEdges = new Set()
selected_iconizedGroups = new Set()

copied_nodes = new Set()
copied_edges = new Set()
copied_ultraEdges = new Set()
copied_iconizedGroups = new Set()

active_grouping_rectangle = undefined
exists_side_grouping_control_point = undefined //if the grouping box spans both sides, this is the x-coord of the right-most node on the left side
forall_side_grouping_control_point = undefined //if the grouping box spans both sides, this is the x-coord of the left-most node on the right side
GROUPING_BOX_BUFFER = 15        //number of pixels beyond the most extreme nodes to draw bounding rectangle
group_processing_active = false   //turned to true when user chooses to iconize group

const NODE_DRAW_RADIUS = 5
const NODE_CLICK_TOLERANCE = 7  //how close to center of node you have to be to count as having clicked on it
const EDGE_CLICK_TOLERANCE = 12  //how close to center of edge you have to be to count as having clicked on it
const EDGE_WIDTH = 2

const ARROW_OFFSET_PCT = 0.60  //On directed edges, how far from from-node1 to node2 to place arrow.
                               //SHOULD NOT BE USED DIRECTLY!! Call getSmartArrowOffsetPct(edge) instead.
const ARROW_HEAD_LENGTH = 15   //Pixels of headlength in a directed edge arrow

const EXISTS_SIDE = -1
const FORALL_SIDE = -2
const BOTH_SIDES = -3
const DONT_CARE = -4

//TOP_BUFFER = 30  //Clicks above here are ignored   //use minimal version with top nav bar
NAV_BAR_MARGIN = 30
TOP_BUFFER = 2   //Clicks above here are ignored (does not count nav bar pixels)
BOTTOM_BUFFER = 5  //Clicks below here are ignored

node_id_counter = 1
nodes_are_ordered = false  //the default
orderings_are_being_displayed = false
const ORDERING_BOX_OFFSET_X = -15   //determines how the ordering boxes are offset from the node centers
const ORDERING_BOX_OFFSET_Y = NAV_BAR_MARGIN + 15
const CONSTANT_BOX_OFFSET_X = 10
const CONSTANT_BOX_OFFSET_Y = NAV_BAR_MARGIN - 22 // NAV_BAR_MARGIN -18 
const CONSTANT_BOX_WIDTH = 22
const CONSTANT_BOX_HEIGHT = 15
const CONSTANT_FLAGPOLL_TOP_OFFSET = CONSTANT_BOX_OFFSET_Y + 7
node_id_to_inputBox_map = new Map()
const NO_ORDER = -999999
node_id_to_constantBox_map = new Map()

iconizedGroup_id_counter = 1

const INFINITE = 999999

CANVAS_WIDTH = window.screen.width  
CANVAS_HEIGHT = window.screen.height 

const canvas = document.getElementById('mainCanvas');
canvas.width = CANVAS_WIDTH
canvas.height = CANVAS_HEIGHT
const ctx = canvas.getContext('2d');


DIVIDING_LINE_BUFFER = 10  //Clicks in this region are ignored (does not count dividing line width)
DIVIDING_LINE_LOC = CANVAS_WIDTH/2

DISK_COLOR = "black"
EDGE_COLOR = "black"
NODE_SELECT_COLOR = "red"
UNSELECT_COLOR = "white"
EDGE_SELECT_COLOR = "lime"
ICONIZED_GROUP_SELECT_COLOR = "DodgerBlue"

TYPE_UNDIRECTED = -1
TYPE_DIRECTED = -2

edge_type = TYPE_UNDIRECTED //the default

ctx.imageSmoothingEnabled = false; 

isDragging = false   //is user dragging the mouse
cutPending = false   //set to true if there is a cut pending rather than a copy

drawDividingLine()

const contextMenuDiv = document.getElementById('contextMenu');
const contextMenuList = contextMenuDiv.querySelector('ul');
const selfLoopMenuDiv = document.getElementById('selfLoopMenu');
const selfLoopMenuList = selfLoopMenuDiv.querySelector('ul');

contextMenuClickPoint = undefined  //gets where the context menu click was in case it is needed by submenus

SELF_LOOP_RADIUS = 15   //radius in pixels for drawing self-loops
//directions for drawing self-loops
DIR_NONE = -1
DIR_UP = 0
DIR_RIGHT = 1
DIR_DOWN = 2
DIR_LEFT = 3

function Point(x, y) {
  this.x = x;
  this.y = y;
}

function Segment(pt1, pt2) {
    this.pt1 = pt1
    this.pt2 = pt2
}

function Node(x, y, id=node_id_counter++, constant='') {
    this.x = x
    this.y = y
    this.edges = new Set()
    this.ultraEdges = new Set()
    this.id = id
    this.order = NO_ORDER
    this.constant = constant
    orderInputBox = createNodeOrderingBox(this)
    orderInputBox.style.display = "none"
}

Node.prototype.toJson = function() {
    return JSON.stringify({x: this.x, 
                           y: this.y,
                           id: this.id,
                           order: this.order,
                           constant: this.constant
    })
}

function structuredNodeClone(node) {
    let n0 = structuredClone(node)
    let n = new Node(n0.x, n0.y, n0.id)
    n.edges = n0.edges
    n.ultraEdges = n0.ultraEdges
    n.order = n0.order
    n.constant = n0.constant
    //may be a good idea to remove the spurious orderInputBox that was created....
    return n
  }

  function structuredNodesClone(nodes) {
    clone = new Set()
    for(let node of nodes) {
        clone.add(structuredNodeClone(node))
    }
    return clone
  }

  


function Edge(node1, node2, dir=DIR_NONE) {  //all edges assumed to be of type edge_type, dir is just used to know how to draw self-loops
    this.node1 = node1
    this.node2 = node2
    this.dir = dir
}

Edge.prototype.toJson = function() {
    return JSON.stringify({node1: this.node1, 
                           node2: this.node2, 
                           dir: this.dir
    })
}

function structuredEdgeClone(edge) {
    let e0 = structuredClone(edge)
    let e = new Edge(e0.node1, e0.node2, e0.dir)
    return e
}

function structuredEdgesClone(edges) {
    clone = new Set()
    for(let edge of edges) {
        clone.add(structuredEdgeClone(edge))
    }
    return clone
}

function IconizedGroup(inner_nodes, inner_edges, inner_iconizedGroups, inner_ultraEdges, ultraEdges, x, y, num_sides, radius, fill_color, label="") {
    this.inner_nodes = inner_nodes   
    this.inner_edges = inner_edges 
    this.inner_iconizedGroups = inner_iconizedGroups
    this.inner_ultraEdges = inner_ultraEdges
    this.ultraEdges = ultraEdges  

    this.x = x
    this.y = y
    this.num_sides = num_sides
    this.radius = radius
    this.fill_color = fill_color
    this.label = label
    this.id = iconizedGroup_id_counter++
}

IconizedGroup.prototype.toJson = function() {
    return JSON.stringify({inner_nodes: Array.from(this.inner_nodes), 
                           inner_edges: Array.from(this.inner_edges),
                           inner_iconizedGroups: Array.from(this.inner_iconizedGroups),
                           inner_ultraEdges: Array.from(this.inner_ultraEdges),
                           x: this.x,
                           y: this.y,
                           num_sides: this.num_sides,
                           radius: this.radius,
                           fill_color: this.fill_color,
                           label: this.label,
                           id: this.id
    })
}

//maybe this should be a deep clone right off the bat
function structuredIconizedGroupClone(icoGroup) {  //this is a very sloppy clone! inner_nodes point to the wrong place!
    let i0 = structuredClone(icoGroup)
    let i = new IconizedGroup(i0.inner_nodes, i0.inner_edges, i0.inner_iconizedGroups, 
                i0.inner_ultraEdges, i0.ultraEdges, i0.x, i0.y, i0.num_sides, i0.radius, 
                i0.fill_color, i0.label)
    i.id = i0.id   
    iconizedGroup_id_counter--
    for(let inner_node of i0.inner_nodes) {
        inner_node.parent = i
    }
    for(let inner_icoGroup of i0.inner_iconizedGroups) {
        inner_icoGroup.parent = i
    }
    
    
    return i
  }

  function structuredIconizedGroupsClone(icoGroups) {
    clone = new Set()
    for(let icoGroup of icoGroups) {
        clone.add(structuredIconizedGroupClone(icoGroup))
    }
    return clone
  }

  //user's responsibility to assign x,y values to icoGroup
  function deepIconizedGroupClone(icoGroup, whichSide) {
    let innerIcos = new Set()
    let old_to_new_ico_id_map = new Map()
    let old_to_new_node_id_map = new Map()
    let new_innerIcoGroups = new Set()
    for(let oldIcoGroup of icoGroup.inner_iconizedGroups) {
        let newIcoGroup = deepIconizedGroupClone(oldIcoGroup, whichSide)
        old_to_new_ico_id_map.set(oldIcoGroup.id, newIcoGroup)
        new_innerIcoGroups.add(newIcoGroup)
    }
    let new_innerNodes = new Set()
    for(let oldNode of icoGroup.inner_nodes) {
        let newNode = new Node(oldNode.x, oldNode.y)
        if(nodes_are_ordered) {
            newNode.order = oldNode.order //will assign new orderings later
        }
        else {
            newNode.order = NO_ORDER
        }
        //make sure constant is available on side before assigning
        if(isConstantAvailable(whichSide, oldNode.constant, undefined)) {
            newNode.constant = oldNode.constant
        }
        old_to_new_node_id_map.set(oldNode.id, newNode)
        //may be a good idea to remove the spurious orderInputBox that was created....
        new_innerNodes.add(newNode)
    }
    let new_innerEdges = new Set()
    for(let edge of icoGroup.inner_edges) {  //Must create a new edge!!
        let newEdge = new Edge(old_to_new_node_id_map.get(edge.node1.id), old_to_new_node_id_map.get(edge.node2.id))
        newEdge. node1.edges.add(newEdge)
        newEdge. node2.edges.add(newEdge)
        new_innerEdges.add(newEdge)
    }
    let new_innerUltraEdges = new Set()
    for(let ultraEdge of icoGroup.inner_ultraEdges) {  //Must create a new ultraEdge!!
        let obj1 = obj2 = undefined
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            obj1 = old_to_new_ico_id_map.get(ultraEdge.obj1.id)
        }
        else {
            obj1 = old_to_new_node_id_map.get(ultraEdge.obj1.id)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            obj2 = old_to_new_ico_id_map.get(ultraEdge.obj2.id)
        }
        else {
            obj2 = old_to_new_node_id_map.get(ultraEdge.obj2.id)
        }
        let newUltraEdge = new UltraEdge(obj1, obj2)
        obj1.ultraEdges.add(newUltraEdge)
        obj2.ultraEdges.add(newUltraEdge)
        new_innerUltraEdges.add(newUltraEdge)
    }

    new_nodes = [...old_to_new_node_id_map.values()] 
    //new_nodes.sort()   //up to the user to sort the nodes based on values in node.order

    let newIcoGroup = new IconizedGroup(new_innerNodes, new_innerEdges, new_innerIcoGroups, 
        new_innerUltraEdges, new Set(), icoGroup.x, icoGroup.y, icoGroup.num_sides,
        icoGroup.radius, icoGroup.fill_color, icoGroup.label)  
    
     for(let inner_node of new_innerNodes) {
        inner_node.parent = newIcoGroup
     }
     for(let inner_icoGroup of new_innerIcoGroups) {
        inner_icoGroup.parent = newIcoGroup
     }

     return newIcoGroup  
  }

  function fetchById(id, setOfObjects) {
    for(let ob of setOfObjects) {
        if(ob.id == id) {
            return ob
        }
    }

    return undefined
  }

  //pass icoGroup == undefined if asking if constant is available for the entire side
  //if icoGroup != undefined this overrules side, so it is the user's responsibility to check
  //that the icoGroup is on the appropriate side
  function isConstantAvailable(side, constant, icoGroup) {
    let setOfNodes = nodes
    let setofIcoGroups = iconizedGroups
    if(icoGroup != undefined) {
        setOfNodes = icoGroup.inner_nodes
        setofIcoGroups = icoGroup.inner_iconizedGroups
    }
    for(let node of setOfNodes) {
        if((icoGroup == undefined && side == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) ||
            (icoGroup == undefined && side == FORALL_SIDE && node.x > DIVIDING_LINE_LOC) || 
            icoGroup != undefined) {
                if(node.constant == constant) {
                    return false
                }
        }  
    }
    for(let i of setofIcoGroups) {
        if((icoGroup == undefined && side == EXISTS_SIDE && i.x < DIVIDING_LINE_LOC) ||
            (icoGroup == undefined && side == FORALL_SIDE && i.x > DIVIDING_LINE_LOC) || 
            icoGroup != undefined) {
                if(!isConstantAvailable(side, constant, i)) {
                    return false
                }
        }  
    }

    return true
 } 

 //pass icoGroup == undefined to get all constants in use on a given side
 function getConstantsInUseOnSide(side, icoGroup) {
    let constants = new Set()
    let setOfNodes = nodes  //replaced if icoGroup != undefined
    let setofIcoGroups = iconizedGroups //replaced if icoGroup != undefined
    if(icoGroup != undefined) {
        setOfNodes = icoGroup.inner_nodes
        setofIcoGroups = icoGroup.inner_iconizedGroups
    }
    for(let node of setOfNodes) {
        if((icoGroup == undefined && side == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) ||
            (icoGroup == undefined && side == FORALL_SIDE && node.x > DIVIDING_LINE_LOC) || 
            icoGroup != undefined) {
                if(node.constant != '') {
                    constants.add(node.constant)
                }
        }  
    }
    for(let i of setofIcoGroups) {
        if((icoGroup == undefined && side == EXISTS_SIDE && i.x < DIVIDING_LINE_LOC) ||
            (icoGroup == undefined && side == FORALL_SIDE && i.x > DIVIDING_LINE_LOC) || 
            icoGroup != undefined) {
                constants = constants.union(getConstantsInUseOnSide(side, i))
        }  
    }

    return constants
 }

  

function UltraEdge(obj1, obj2, dir=DIR_NONE) {
    this.obj1 = obj1
    this.obj2 = obj2
    this.dir = dir  //just for drawing self-loops; currently unused
}

UltraEdge.prototype.toJson = function() {
    return JSON.stringify({obj1: this.obj1, 
                           obj2: this.obj2, 
                           dir: this.dir
    })
}

function structuredUltraEdgeClone(ultraEdge) {
    let u0 = structuredClone(ultraEdge)
    let u = new UltraEdge(u0.obj1, u0.obj2, u0.dir)
    return u
}

function structuredUltraEdgesClone(ultraEdges) {
    clone = new Set()
    for(let ultraEdge of ultraEdges) {
        clone.add(structuredUltraEdgeClone(ultraEdge))
    }
    return clone
}

function arrayToJson(array) {
    json = "["
    for(i=0; i<array.length; i++) {
        json += array[i].toJson()
        if(i < array.length-1) {
            json += ","
        }
    }
    json += ']'
    return json
}

function beep() {
    var snd = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");  
    snd.play();
}

function eraseCanvas(canvasId, x, y, width, height) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = "white"
  ctx.fillRect(x, y, width, height);
}

function select_iconizedGroup(icoGroup) {
    //draw selection squares
    vertices = getPolygonVerticesForIconizedGroup(icoGroup)
    for(let vertex of vertices) {
        drawSelectionSquare(vertex.x, vertex.y, NODE_DRAW_RADIUS*2, ICONIZED_GROUP_SELECT_COLOR, 2)
    }

    //add to group
    selected_iconizedGroups.add(icoGroup)
}

function unselect_iconizedGroup(icoGroup) {
    vertices = getPolygonVerticesForIconizedGroup(icoGroup)
    for(let vertex of vertices) {
        drawSelectionSquare(vertex.x, vertex.y, NODE_DRAW_RADIUS*2, UNSELECT_COLOR)
    }
    //redraw any very close nodes
    for(let n of nodes) {
        dist = Math.sqrt(Math.pow((n.x-icoGroup.x),2) + Math.pow((n.y-icoGroup.y),2))
        if(dist < icoGroup.radius + 2*NODE_DRAW_RADIUS) {
            draw_node(n)
        }
    }
    //redraw any very close iconizedGroups
    for(let i of iconizedGroups) {
        dist = Math.sqrt(Math.pow((i.x-icoGroup.x),2) + Math.pow((i.y-icoGroup.y),2))
        if(dist < i.radius + icoGroup.radius + NODE_DRAW_RADIUS) {
            draw_iconizedGroup(i)
        }
    }
    //redraw edges (could be impairing not just edges from this node but other very close edges....)
    draw_all_edges()
    for(const e of selected_edges) {
        select_edge(e)
    }
    selected_iconizedGroups.delete(icoGroup)
}

function draw_all_iconizedGroups() {
    for(let icoGroup of iconizedGroups) {
        draw_iconizedGroup(icoGroup)
    }
}

function draw_iconizedGroup(icoGroup) {
    drawPolygon("mainCanvas", icoGroup.x, icoGroup.y, icoGroup.radius,
        icoGroup.num_sides, icoGroup.fill_color, icoGroup.label)
}

function erase_iconizedGroup(icoGroup) {
    drawPolygon("mainCanvas", icoGroup.x, icoGroup.y, icoGroup.radius, icoGroup.num_sides, "White", "")
}


function drawPolygon(canvasId, x, y, radius, sides, fill_color, label) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  if (sides < 3) return;
  ctx.beginPath();
  if(fill_color.toLowerCase() != "white") {
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
  }
  else {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
  }
  let initial_angle = -Math.PI/2
  if(sides == 4) {
    initial_angle = -Math.PI/4
  }
  const angle = (Math.PI * 2) / sides;
  ctx.moveTo(x + radius * Math.cos(initial_angle), y + radius * Math.sin(initial_angle));
  for (let i = 1; i <= sides; i++) {
    ctx.lineTo(
      x + radius * Math.cos(initial_angle + angle * i),
      y + radius * Math.sin(initial_angle + angle * i)
    );
  }
  ctx.closePath();
  ctx.fillStyle = fill_color
  ctx.fill()
  ctx.stroke();

  let font_size = radius*2/5
  ctx.font = '' + font_size + 'pt Arial';  //8-14 works
  if(fill_color == "cyan" || fill_color == "chartreuse" || fill_color == "orange") {
    ctx.fillStyle = 'black'; // Text color
  }
  else {
    ctx.fillStyle = 'white';
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x, y);
}

function getPolygonVerticesForIconizedGroup(iconizedGroup) {
    let x = iconizedGroup.x
    let y = iconizedGroup.y
    let radius = iconizedGroup.radius
    let sides = iconizedGroup.num_sides
    let vertices = []
    let initial_angle = -Math.PI/2
    if(sides == 4) {
        initial_angle = -Math.PI/4
    }
    let pt = new Point(x + radius * Math.cos(initial_angle), y + radius * Math.sin(initial_angle))
    vertices .push(pt)
    let angle = (Math.PI * 2) / sides;
    for (let i = 1; i <= sides; i++) {
        pt = new Point(x + radius * Math.cos(initial_angle + angle * i), y + radius * Math.sin(initial_angle + angle * i))
        vertices .push(pt)
    }
    return vertices
}

function validateSpaceForNodes(left_edge, right_edge, top_edge, bottom_edge) {
    if(left_edge < DIVIDING_LINE_BUFFER) {
        alert("Not enough space to the left to fit all of your nodes. Please try again.")
        return false
    }
    else if(left_edge < DIVIDING_LINE_LOC && right_edge > DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) {
        alert("Nodes will not all fit on the left-hand side. Please try again.")
        return false
    } 
    else if(right_edge > CANVAS_WIDTH - NODE_DRAW_RADIUS) {
        alert("Nodes will not all fit on the right-hand side. Please try again.")
        return false
    }
    else if(top_edge < TOP_BUFFER) {
        alert("Not enough space above to fit all of your nodes. Please try again.")
        return false
    }
    else if(bottom_edge > CANVAS_HEIGHT - NODE_DRAW_RADIUS) {
        alert("Not enough space below to fit all of your nodes. Please try again.")
        return false
    }
    //Now verify that there are not nodes in the rectangle
    for(let node of nodes) {
        if(left_edge <= node.x && node.x <= right_edge && top_edge <= node.y && node.y <= bottom_edge) {
            alert("Requested nodes will overlap with some of your existing nodes. Please try again.")
            return false
        }
    }
    //Finally verify that there are not iconizedGroups in the rectangle
    for(let icoGroup of iconizedGroups) {
        if(left_edge <= icoGroup.x + icoGroup.radius && icoGroup.x - icoGroup.radius <= right_edge 
            && top_edge <= icoGroup.y + icoGroup.radius && icoGroup.y - icoGroup.radius <= bottom_edge) {
            alert("Requested nodes will overlap with some of your existing iconized groups. Please try again.")
            return false
        }
    }

    return true
}

function sanityCheckGridDialogEntries(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr) {
    MINIMUM_PIXEL_SEPARATION = 20
    if(num_rows < 1) {
        alert("# Rows must be > 0!")
        document.getElementById("num_rows").focus()
        return false
    }
    else if(num_cols < 1) {
        alert("# Cols must be > 0!")
        document.getElementById("num_cols").focus()
        return false
    }
    else if(pixel_separation < MINIMUM_PIXEL_SEPARATION) {
        alert("Pixel separation must he at least " + MINIMUM_PIXEL_SEPARATION + "!")
        document.getElementById("separation").focus()
        return false
    }
    //now verify that we have room for the new nodes!
    width_needed =  num_cols*pixel_separation + 2*NODE_DRAW_RADIUS 
    height_needed = num_rows*pixel_separation + 2*NODE_DRAW_RADIUS

    left_edge = contextMenuClickPoint.x - NODE_DRAW_RADIUS
    right_edge = left_edge + width_needed
    top_edge = contextMenuClickPoint.y - NODE_DRAW_RADIUS
    bottom_edge = top_edge + height_needed

    return validateSpaceForNodes(left_edge, right_edge, top_edge, bottom_edge)
}

function renderGridOfNodes(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr) {
    //first create nodes
    let node_grid = []
    for(let i=0; i<num_rows; i++) {
        node_grid.push(new Array(num_cols))
    }
    if(order_tb_lr) {
        for(let i=0; i<num_rows; i++) {
            for(let j=0; j<num_cols; j++) {
                let x = contextMenuClickPoint.x + j*pixel_separation
                let y = contextMenuClickPoint.y + i*pixel_separation
                let node = new Node(x, y)
                node_grid[i][j] = node
                create_node(node)
            }
        }
    }
    else {
        for(let j=0; j<num_cols; j++) {
            for(let i=0; i<num_rows; i++) {
                let x = contextMenuClickPoint.x + j*pixel_separation
                let y = contextMenuClickPoint.y + i*pixel_separation
                let node = new Node(x, y)
                node_grid[i][j] = node
                create_node(node)
            }
        }
    }
    //next create edges, if requested
    if(l1_connect) {
        for(let i=0; i<num_rows; i++) {
            for(let j=0; j<num_cols; j++) {
                if(i < num_rows - 1) {
                    let edge = new Edge(node_grid[i][j], node_grid[i+1][j])
                    create_edge(edge)
                }
                if(j < num_cols - 1) {
                    let edge = new Edge(node_grid[i][j], node_grid[i][j+1])
                    create_edge(edge)
                }
            }
        }

    }
    redrawAll()
}

function captureGridDialogDetails(event) {
    num_rows = document.getElementById("num_rows").value
    num_cols = document.getElementById("num_cols").value
    pixel_separation = document.getElementById("separation").value
    l1_connect = document.getElementById("l1_connect").checked
    order_tb_lr = document.getElementById("order_tb_lr").checked
    if(document.getElementById("via_undirected_edges").checked) {
        edge_type = TYPE_UNDIRECTED
    }
    else {
        edge_type = TYPE_DIRECTED
    }
    res = sanityCheckGridDialogEntries(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr)
    if(res) {
        renderGridOfNodes(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr)
        clearSelection()
    } 
    else {
        event.preventDefault()
    }
}

function captureIconizationDialogDetails() {
    let num_sides = document.getElementById("n_gon").value
    let circumradius = Number(document.getElementById("radius").value)
    let fill_color = "cyan"  //the default
    const radios = document.getElementsByName("color");
    for (let i = 0; i < radios.length; i++) {
        if (radios[i].checked) {
            fill_color = radios[i].value;
            break;
        }
    }
    let label = document.getElementById("label").value
    
    let alsoSwapOthers = false
    if(activeIcoGroup == undefined) {
        //active_grouping_rectangle has already been disabled, so we have to make do without it
        let minX = canvas.width
        let minY = canvas.height
        let maxX = maxY = 0
        for(let node of selected_nodes) {
            if(node.x < minX) {
                minX = node.x
            }
            if(node.x > maxX) {
                maxX = node.x
            }
            if(node.y < minY) {
                minY = node.y
            }
            if(node.y > maxY) {
                maxY = node.y
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            if(icoGroup.x < minX) {
                minX = icoGroup.x
            }
            if(icoGroup.x > maxX) {
                maxX = icoGroup.x
            }
            if(icoGroup.y < minY) {
                minY = icoGroup.y
            }
            if(icoGroup.y > maxY) {
                maxY = icoGroup.y
            }
        }
        minX -= GROUPING_BOX_BUFFER
        minY -= GROUPING_BOX_BUFFER
        maxX += GROUPING_BOX_BUFFER
        maxY += GROUPING_BOX_BUFFER
        let x = (minX + maxX)/2
        let y = (minY + maxY)/2

        activeIcoGroup = new IconizedGroup(structuredNodesClone(selected_nodes), structuredEdgesClone(selected_edges), 
            structuredIconizedGroupsClone(selected_iconizedGroups),
            structuredUltraEdgesClone(selected_ultraEdges), 
            new Set(), x, y, num_sides, circumradius, fill_color, label)  //initially created with no ultraEdges
        iconizedGroups.add(activeIcoGroup)
        for(let inner_node of activeIcoGroup.inner_nodes) {
            inner_node.parent = activeIcoGroup
        }
        for(let inner_icoGroup of activeIcoGroup.inner_iconizedGroups) {
            inner_icoGroup.parent = activeIcoGroup
        }
        //nodes and edges must be deteled from the main set or they will always be drawn
        deleteSelectedEdges()
        deleteSelectedUltraEdges()
        deleteSelectedNodes()
        deleteSelectedIconizedGroups()
        let EXTRA_BUFF = 40  //to try to take care of phantom grouping box that sometimes seems to appear
        redrawRectangle(minX - EXTRA_BUFF, minY - EXTRA_BUFF, maxX - minX + 2*EXTRA_BUFF, maxY - minY + 2*EXTRA_BUFF)
    }
    else {
        if(num_sides != activeIcoGroup.num_sides || circumradius != activeIcoGroup.radius || 
            fill_color != activeIcoGroup.fill_color) {
            otherIcosWithSameIcon = new Set()
            for(let i of iconizedGroups) {
                if(i != activeIcoGroup && i.num_sides == activeIcoGroup.num_sides && 
                    i.radius == activeIcoGroup.radius && i.fill_color == activeIcoGroup.fill_color) {
                    otherIcosWithSameIcon.add(i)
                }
            }
            if(otherIcosWithSameIcon.size > 0) {  //only ask this question if the icon or fill color was changed!!
                alsoSwapOthers = confirm("Also swap the icons of other groups with this same icon (does not affect labels)?")
            }
        }
        erase_iconizedGroup(activeIcoGroup)
        activeIcoGroup.num_sides = num_sides
        activeIcoGroup.radius = circumradius
        activeIcoGroup.fill_color = fill_color
        activeIcoGroup.label = label
        if(alsoSwapOthers) {
            for(let i of otherIcosWithSameIcon) {
                erase_iconizedGroup(i)
                i.num_sides = num_sides
                i.radius = circumradius
                i.fill_color = fill_color
            }
        }
    }
    //perform iconization
    MAX_ICON_RADIUS = 40
    draw_iconizedGroup(activeIcoGroup)
    redrawRectangle(activeIcoGroup.x - MAX_ICON_RADIUS, activeIcoGroup.y - MAX_ICON_RADIUS,
        2*MAX_ICON_RADIUS, 2*MAX_ICON_RADIUS)
    if(alsoSwapOthers) {
        for(let i of otherIcosWithSameIcon) {
            draw_iconizedGroup(i)
            redrawRectangle(i.x - MAX_ICON_RADIUS, i.y - MAX_ICON_RADIUS, 2*MAX_ICON_RADIUS, 2*MAX_ICON_RADIUS)
        }
    }

}

function gridDailogCancelHandler() {
    console.log("User cancelled grid dialog!")
}

function iconizationDailogCancelHandler() {
    console.log("User cancelled iconization diaolg!")
    if(active_grouping_rectangle == undefined) {   //cheesy - does a redraw
        handleGrouping() 
    }
}

//for the top menu
const menuItems = ["File", "Edit", "Game", "Help"];
const nav = document.getElementById("topMenu");
const ul = document.createElement("ul");

menuItems.forEach(itemText => {
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.textContent = itemText;
    //a.href = "#" + itemText.toLowerCase(); // Simple link example (has the nice effect of changing the mouse cursor to a slection pointer)
    a.addEventListener('mousedown', event => {
        event.preventDefault();

        let subMenuItems = []
        if(a.textContent == 'File') {
            subMenuItems = [
                { text: 'Open...', action: () => fileOpenHandler()},
                { text: 'Save...', action: () => fileSaveHandler()}
            ];
            contextMenuDiv.style.left = '12px'
        }
        else if(a.textContent == 'Edit') {//this is quite a cheesy way of doing things. Eventually do this correctly with css
            let sfx = []
            let os = getOS()
            if(os == 'macOS') {
                sfx = ['\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200A\u200A\u200A\u200A\u200A\u2318X',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200A\u200A\u200A\u200A\u200A\u2318C',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200A\u200A\u200A\u2318V',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u2002\u2002\u200A\u200ADel',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u2318A', 
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200AG']   
            }
            else {
                sfx = ['\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200A\u200A\u200A\u200A\u200ACtrl+X',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200A\u200A\u200A\u200A\u200ACtrl+C',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200A\u200A\u200ACtrl+V',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u2002\u2002\u200A\u200A\u200A\u200ADel',
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200ACtrl+A', 
                        '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u200A\u200AG'] 
            }
            subMenuItems = [
                { text: 'Cut'+sfx[0], action: () => handleCut()},
                { text: 'Copy'+sfx[1], action: () => handleCopy()},
                { text: 'Paste'+sfx[2], action: () => 
                    {
                        if(!existsButtonPressed && !forallButtonPressed) {
                            alert("You must select either the \u2203 or \u2200 side before pasting!")
                            return
                        }
                        handlePaste()
                    }
                },
                { text: 'Delete'+sfx[3], action: () => 
                    {
                        deleteSelectedEdges() 
                        deleteSelectedUltraEdges()
                        deleteSelectedNodes()
                        deleteSelectedIconizedGroups()
                    }
                },
                { text: 'Select All'+sfx[4], action: () => selectAll()},
                { text: 'Group'+sfx[5], action: () => handleGrouping()}
            
            ];
            contextMenuDiv.style.left = '62px'
        }
        else if(a.textContent == 'Game') {
            let os = getOS()
            subMenuItems = []
            if(os == 'macOS') {
                subMenuItems = [
                    { text: 'Start a Game' + '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\u2318G', action: () => startGame()}
                ];
            }
            else {
                subMenuItems = [
                    { text: 'Start a Game' + '\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Ctrl+G', action: () => startGame()}
                ];
            }
            contextMenuDiv.style.left = '114px'
        }
         else if(a.textContent == 'Help') {
            subMenuItems = [
                    { text: 'Tips and Tricks', action: () => getTips()},
                    { text: 'Known Bugs', action: () => getKnownBugs()},
                    { text: 'Report a Bug...', action: () => reportABug()}
            ];
            contextMenuDiv.style.left = '180px'
         }
        contextMenuDiv.style.fontSize = "12pt"

        contextMenuList.innerHTML = '';

        subMenuItems.forEach(item => {
            let subMenuItemElement = document.createElement('li');
            subMenuItemElement.textContent = item.text;
            subMenuItemElement.addEventListener('click', item.action);
            if(item.text.startsWith("Save") && nodes.size == 0 && iconizedGroups.size == 0) {
                disableMenuItemElement(subMenuItemElement)
            }
            else if(item.text.startsWith("Start a Game") && !areThereNodesOnBothSides()) {
                disableMenuItemElement(subMenuItemElement)
            }
            else if(item.text.startsWith("Select All") && nodes.size == 0 && iconizedGroups.size == 0) {
                disableMenuItemElement(subMenuItemElement)
            }
            else if((item.text.startsWith("Cut") || item.text.startsWith("Delete")) && selected_nodes.size == 0 
                && selected_edges.size == 0 && selected_iconizedGroups.size == 0 && selected_ultraEdges.size == 0) {
                disableMenuItemElement(subMenuItemElement)
            }
            else if((item.text.startsWith("Copy") || item.text.startsWith("Group")) && selected_nodes.size == 0
                && selected_iconizedGroups.size == 0) {
                disableMenuItemElement(subMenuItemElement)
            }
            else if(item.text.startsWith("Paste") && copied_nodes.size == 0 && copied_edges.size == 0
                && copied_iconizedGroups.size == 0 && copied_ultraEdges.size == 0) {
                disableMenuItemElement(subMenuItemElement)
            }
            else if(item.text.startsWith("Group") && active_grouping_rectangle != undefined) {
                subMenuItemElement.textContent = "Ungroup" + "\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0G"
                subMenuItemElement.addEventListener('mousedown', event => {event.stopPropagation()});  //otherwise the grouping rectangle will be immediately killed
            }
            //else if(item.text.startsWith("Report a Bug")) {
            //    disableMenuItemElement(subMenuItemElement)
            //}

            contextMenuList.appendChild(subMenuItemElement);
            if(item.text.startsWith("Select All") || item.text.startsWith("Tips and Tricks")) {
                subMenuItemElement = document.createElement('hr');
                contextMenuList.appendChild(subMenuItemElement);
            }
        });

        //contextMenuDiv.style.left = `${event.clientX-10}px`;
        contextMenuDiv.style.top = '38px'; //`${event.clientY+10}px`;
        contextMenuDiv.style.display = 'block';
        contextMenuDiv.style.fontFamily = "Arial, Helvetica, sans-serif";
        contextMenuDiv.style.fontWeight = "Bold";
        contextMenuDiv.style.fontSize = "12pt";
        event.stopPropagation()
    });
    a.addEventListener('mouseup', event => {
        event.stopPropagation()
    });
    a.addEventListener('click', event => {
        event.stopPropagation()
    });
    a.addEventListener('mouseover', event => {
        document.body.style.cursor = "default"  //without this turns to a text selection cursor
    });
    li.appendChild(a);
    ul.appendChild(li);
});
nav.appendChild(ul);

function getTips() {
    const newWindow = window.open("tips.html", '_blank', "width=740, height=700, location=no,menubar=no,toolbar=no,status=no")
}

function getKnownBugs() {
    const newWindow = window.open("known_bugs.html", '_blank', "width=740, height=500, location=no,menubar=no,toolbar=no,status=no")
}

function reportABug() {
    const newWindow = window.open("bug_report.html", '_blank', "width=740, height=700, location=no,menubar=no,toolbar=no,status=no")
}

function disableMenuItemElement(menuItemElement) {
    menuItemElement.style.pointerEvents = "none"
    menuItemElement.style.opacity = 0.5
}

function fileOpenHandler() {
    if(nodes.size > 0 || iconizedGroups.size > 0) {
        //For a more elegant way of doing confirm dialogs, see https://www.google.com/search?q=javascript+confirm+box+with+a+user+specified+title&oq=javascript+confirm+box+with+a+user+specified+titlehttps://www.google.com/search?q=javascript+confirm+box+with+a+user+specified+title&oq=javascript+confirm+box+with+a+user+specified+title
        res = confirm("Your current set of boards will be replaced. OK to proceed?")
        if(!res) {
            return
        }
    }
    
    console.log('File->Open selected.')
    contextMenu.style.display = 'none';
    event.stopPropagation();
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = (event) => {
        const file = event.target.files[0];
        if (file) {
            // Handle the selected file here
            console.log('Selected file:', file.name);
            // You can use FileReader to read the file content
            const reader = new FileReader();
            reader.onload = (e) => {
                const fileContent = e.target.result;
                console.log('File content:', fileContent);
                loadFileJSON(fileContent)
            };
            reader.readAsText(file);
        }
    };
    input.click();
}

async function fileSaveHandler() {
    console.log('File->Save selected.')
    contextMenu.style.display = 'none';
    event.stopPropagation();
    const blob = new Blob([getGameJSON()], { type: 'text/plain' });

    try {
        const handle = await window.showSaveFilePicker({
        suggestedName: "your_file.json",
        types: [{
            description: 'JSON files',
            accept: { 'application/json': ['.json'] }
        }],
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
    } 
    catch (error) {
        if (error.name !== 'AbortError') {
            console.error('Error saving the file:', error);
        }
    }
}

function drawConstantBoxFlagPole(node) {
    ctx.beginPath()
    ctx.strokeStyle = "Blue"
    ctx.lineWidth = CONSTANT_BOX_OFFSET_X/3
    ctx.moveTo(node.x, node.y - NODE_DRAW_RADIUS);
    ctx.lineTo(node.x, node.y - CONSTANT_FLAGPOLL_TOP_OFFSET - CONSTANT_BOX_HEIGHT); 
    ctx.stroke();
    ctx.closePath()
}

function eraseConstantBoxFlagPole(node) {
    ctx.beginPath()
    ctx.strokeStyle = "White"
    ctx.lineWidth = CONSTANT_BOX_OFFSET_X/2
    ctx.moveTo(node.x, node.y - NODE_DRAW_RADIUS);
    ctx.lineTo(node.x, node.y - CONSTANT_FLAGPOLL_TOP_OFFSET - CONSTANT_BOX_HEIGHT); 
    ctx.stroke();
    ctx.closePath()
}

function loadFileJSON(fileJSON) {
    selectAll()
    deleteSelectedEdges() 
    deleteSelectedUltraEdges()
    deleteSelectedNodes()
    deleteSelectedIconizedGroups()

    const gameObject = JSON.parse(fileJSON);
    parentZoomLevel = gameObject.zoom_level
    iconizedGroup_id_counter = gameObject.iconizedGroup_id_counter
    node_id_counter = gameObject.node_id_counter
    ourZoomLevel = getZoomLevel()
    console.log("parent zoom level = " + parentZoomLevel)
    console.log("our zoom level = " + ourZoomLevel)
    let former_canvas_width = gameObject.canvas_width
    let former_canvas_hieght = gameObject.canvas_height
    if(former_canvas_width == undefined) {
        former_canvas_width = CANVAS_WIDTH
    }
    if(former_canvas_hieght == undefined) {
        former_canvas_hieght = CANVAS_HEIGHT
    }
    let width_expansion_factor = CANVAS_WIDTH/former_canvas_width
    let height_expansion_factoro = CANVAS_HEIGHT/former_canvas_hieght

    if(gameObject.edge_type == "directed") {
        edge_type = TYPE_DIRECTED
    }
    else {
        edge_type = TYPE_UNDIRECTED
    }
    nodes_are_ordered = gameObject.node_ordering
    
    orderings_are_being_displayed = nodes_are_ordered  //default to showing if nodes are ordered in JSON file
    for(let i=0; i<gameObject.nodes.length; i++) {
        n = gameObject.nodes[i]
        node = new Node(n.x * width_expansion_factor, n.y * height_expansion_factoro, n.id, n.constant)
        node_id_counter = Math.max(node_id_counter, node.id+1)
        let orderInputBox = node_id_to_inputBox_map.get(node.id)
        //scaleNodeToZoomLevel(parentZoomLevel, ourZoomLevel, node)
        node.order = n.order
        nodes.add(node)
        if(orderings_are_being_displayed) {
            if(node.order != NO_ORDER) {
                orderInputBox.value = node.order
            }
            else {
                orderInputBox.value = ''
            }
            orderInputBox.style.display = "initial"
        }
        else {
            orderInputBox.style.display = "none"
        }
        if(node.constant != '') {
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
    }

    for(let i=0; i<gameObject.edges.length; i++) {
        nodeId1 = gameObject.edges[i].node1.id
        node1 = getNodeById(nodeId1)
        nodeId2 = gameObject.edges[i].node2.id
        node2 = getNodeById(nodeId2)
        dir = gameObject.edges[i].dir
        edge = new Edge(node1, node2, dir)
        node1.edges.add(edge)
        node2.edges.add(edge)
        edges.add(edge)
    }

    //code below here is not yet working!!
    //pay attention to how everything is turned into JSON to figure out how it
    //should be unrolled...
    iconizedGroups = new Set()
    innerIconizedGroups = new Set()
    ultraEdges = new Set()

    for(let i=0; i<gameObject.iconizedGroups.length; i++) {
        let goodIcoGroup = coerceToIconizedGroup(gameObject.iconizedGroups[i])
        iconizedGroups.add(goodIcoGroup)
    }
    for(let i=0; i<gameObject.ultraEdges.length; i++) {
        let goodUltraEdge = coerceToUltraEdge(gameObject.ultraEdges[i])
        if(goodUltraEdge.obj1.hasOwnProperty("num_sides")) {
            goodUltraEdge.obj1 = getIconoizedGroupById(goodUltraEdge.obj1.id)
        }
        else {
            goodUltraEdge.obj1 = getNodeById(goodUltraEdge.obj1.id)
        }
        goodUltraEdge.obj1.ultraEdges.add(goodUltraEdge)
        if(goodUltraEdge.obj2.hasOwnProperty("num_sides")) {
            goodUltraEdge.obj2 = getIconoizedGroupById(goodUltraEdge.obj2.id)
        }
        else {
            goodUltraEdge.obj2 = getNodeById(goodUltraEdge.obj2.id)
        }
        goodUltraEdge.obj2.ultraEdges.add(goodUltraEdge)
        ultraEdges.add(goodUltraEdge)
    }

    for(let i=0; i<gameObject.innerIconizedGroups.length; i++) {
        innerIcoGroup = coerceToIconizedGroup(gameObject.innerIconizedGroups[i])
        innerIconizedGroups.add(innerIcoGroup)
        //needs to have their ultraEdges setup
    }
    for(let icoGroup of iconizedGroups) { 
        repairIconizedGroup(icoGroup, innerIconizedGroups)
        //Before dealing with inner_ultraEdges and inner_edges deal with inner_nodes
        //and inner_iconizedGroups
        let goodInnerNodes = new Set()
        for(let node of icoGroup.inner_nodes) {
            let goodNode = coerceToNode(node)
            goodInnerNodes.add(goodNode)
        }
        icoGroup.inner_nodes = goodInnerNodes
        let goodInnerEdges = new Set()
        for(let edge of icoGroup.inner_edges) {
            let goodEdge = coerceToEdge(edge)
            goodInnerEdges.add(goodEdge)
            let node1 = fetchById(goodEdge.node1.id, goodInnerNodes)
            let node2 = fetchById(goodEdge.node2.id, goodInnerNodes)
            goodEdge.node1 = node1
            goodEdge.node2 = node2
            node1.edges.add(goodEdge)
            if(node1 != node2) {
                node2.edges.add(goodEdge)
            }
        }
        icoGroup.inner_edges = goodInnerEdges
        //now do the same for ultraEdges
        let goodInnerUltraEdges = new Set()
        for(let ultraEdge of icoGroup.inner_ultraEdges) {
            let goodUltraEdge = coerceToUltraEdge(ultraEdge)
            goodInnerUltraEdges.add(goodUltraEdge)
            if(goodUltraEdge.obj1.hasOwnProperty("num_sides")) {
                let icoGroup1 = fetchById(goodUltraEdge.obj1.id, icoGroup.inner_iconizedGroups)
                goodUltraEdge.obj1 = icoGroup1
                icoGroup1.ultraEdges.add(goodUltraEdge)
            }
            else {
                let node1 = fetchById(goodUltraEdge.obj1.id, icoGroup.inner_nodes)
                goodUltraEdge.obj1 = node1
                node1.ultraEdges.add(goodUltraEdge)
            }
            if(goodUltraEdge.obj2.hasOwnProperty("num_sides")) {
                let icoGroup2 = fetchById(goodUltraEdge.obj2.id, icoGroup.inner_iconizedGroups)
                goodUltraEdge.obj2 = icoGroup2
                icoGroup2.ultraEdges.add(goodUltraEdge)
            }
            else {
                let node2 = fetchById(goodUltraEdge.obj2.id, icoGroup.inner_nodes)
                goodUltraEdge.obj2 = node2
                node2.ultraEdges.add(goodUltraEdge)
            }

        }
        icoGroup.inner_edges = goodInnerEdges
        //need to repair the children in the same way
    }
    
    redrawAll()
}

function repairIconizedGroup(icoGroup, innerIconizedGroups) {
    let inner_icos = new Set()
    for(let inner_ico of icoGroup.inner_iconizedGroups) {
        let actual_inner_ico = fetchById(inner_ico.id, innerIconizedGroups)
        actual_inner_ico.parent = icoGroup
        inner_icos.add(actual_inner_ico)
        repairIconizedGroup(actual_inner_ico, innerIconizedGroups)
    }
    icoGroup.inner_iconizedGroups = inner_icos
}

function drawDividingLine() {
    ctx.beginPath()
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.moveTo(DIVIDING_LINE_LOC, TOP_BUFFER);
    ctx.lineTo(DIVIDING_LINE_LOC, CANVAS_HEIGHT);
    ctx.stroke();
    ctx.closePath()
}

function get_clicked_on_node(event) {
    x = event.clientX - canvas.offsetLeft
    y = event.clientY - canvas.offsetTop
    nodeList = Array.from(nodes)
    //can be very close nodes so find closest, not just node within click tolerance
    closest_distance = INFINITE
    closet_node = undefined
    for(let i=0; i<nodeList.length; i++) {
        node = nodeList[i]
        distance = Math.pow(x-node.x, 2) + Math.pow(y-node.y, 2)
        if(distance <= Math.pow(NODE_DRAW_RADIUS + NODE_CLICK_TOLERANCE,2) && distance < closest_distance) {
            closet_node = node
            closest_distance = distance
        }
    }

    return closet_node
}

function click_to_node(event) {
    //first see if click is in one of the existing nodes
    node = get_clicked_on_node(event)
    if(node != undefined) {
        return node
    }
   else {
        return new Node(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop)
   }
}

function get_clicked_on_iconizedGroup(event) {
    x = event.clientX - canvas.offsetLeft
    y = event.clientY - canvas.offsetTop
     for(icoGroup of iconizedGroups) {
        let d = Math.sqrt(Math.pow(x - icoGroup.x, 2) + Math.pow(y - icoGroup.y, 2))
        if(d <= icoGroup.radius) {
            return icoGroup
        }
    }

    return undefined
}

function draw_node(node) {
    ctx.beginPath()
    ctx.strokeStyle = DISK_COLOR;
    ctx.moveTo(node.x, node.y);
    ctx.arc(node.x, node.y, NODE_DRAW_RADIUS, 0, 2*Math.PI)
    ctx.fillStyle = DISK_COLOR; // Fill the circle with DOISK_COLOR
    ctx.fill();
    ctx.lineWidth = 1
    ctx.stroke();
    ctx.closePath()
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        drawConstantBoxFlagPole(node)
    }
}

function erase_node(node) {
    ctx.beginPath()
    ctx.strokeStyle = "white";
    ctx.moveTo(node.x, node.y);
    ctx.arc(node.x, node.y, NODE_DRAW_RADIUS+2, 0, 2*Math.PI)
    ctx.fillStyle = "white"; 
    ctx.fill();
    ctx.lineWidth = 2
    ctx.stroke();
    ctx.closePath()
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        eraseConstantBoxFlagPole(node)
    }
}

function create_node(node) {
    nodes.add(node)
    draw_node(node)
    if(orderings_are_being_displayed) {
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.display = "initial"
    }
}

function delete_node(node) {
    let edge_list = Array.from(node.edges)
    for(let i=0; i<edge_list.length; i++) {
        unselect_edge(edge_list[i])
        delete_edge(edge_list[i])
    }
    let ultraEdge_list = Array.from(node.ultraEdges)
    for(let i=0; i<ultraEdge_list.length; i++) {
        unselect_ultraEdge(ultraEdge_list[i])
        delete_ultraEdge(ultraEdge_list[i])
    }
    erase_node(node)
    node_id_to_inputBox_map.get(node.id).style.display = "none"
    node_id_to_inputBox_map.delete(node.id)
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        constantBox.remove()
        node_id_to_constantBox_map.delete(node.id)
    }
    nodes.delete(node)
    draw_all_edges()  //could be more clever about edges needing to be redrawn....
    draw_all_ultraEdges()
}

function delete_iconizedGroup(icoGroup) {  //note that parent is responsible for deleting the associated ultraEdges and this should be done first!
    erase_iconizedGroup(icoGroup)
    iconizedGroups.delete(icoGroup)
    draw_all_edges()
    draw_all_ultraEdges()
}

function draw_all_nodes() {
    for(let node of nodes) {
        draw_node(node)
    }
}

function draw_directed_edge(edge) {
    fromX = edge.node1.x
    toX = edge.node2.x
    fromY = edge.node1.y
    toY = edge.node2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(edge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.strokeStyle = EDGE_COLOR
    ctx.lineWidth = EDGE_WIDTH
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = EDGE_COLOR
    ctx.fill();
}

function draw_directed_ultraEdge(ultraEdge) {
    fromX = ultraEdge.obj1.x
    toX = ultraEdge.obj2.x
    fromY = ultraEdge.obj1.y
    toY = ultraEdge.obj2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    let tempEdge = Edge()
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(ultraEdge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.strokeStyle = EDGE_COLOR
    ctx.lineWidth = EDGE_WIDTH*1.5
    ctx.setLineDash([10, 5]);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.setLineDash([]);
    ctx.fillStyle = EDGE_COLOR
    ctx.fill();
}

function erase_directed_ultraEdge(ultraEdge) {
     fromX = ultraEdge.obj1.x
    toX = ultraEdge.obj2.x
    fromY = ultraEdge.obj1.y
    toY = ultraEdge.obj2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(ultraEdge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.strokeStyle = "white"
    ctx.lineWidth = EDGE_WIDTH*3
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = EDGE_WIDTH*3
    ctx.strokeStyle = "white"
    ctx.moveTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = "white"
    ctx.fill();
    ctx.stroke();
}


function draw_edge(edge) {
    if(edge.node1 != edge.node2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = EDGE_COLOR
            ctx.lineWidth = EDGE_WIDTH
            ctx.moveTo(edge.node1.x, edge.node1.y);
            ctx.lineTo(edge.node2.x, edge.node2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            draw_directed_edge(edge)
        }
    }
    else {
        drawSelfLoop(edge.node1, edge.dir)
    }
}

function draw_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = EDGE_COLOR
            ctx.lineWidth = EDGE_WIDTH*2
            ctx.setLineDash([10, 5]);
            ctx.moveTo(ultraEdge.obj1.x, ultraEdge.obj1.y);
            ctx.lineTo(ultraEdge.obj2.x, ultraEdge.obj2.y); 
            ctx.stroke();
            ctx.closePath()
            ctx.setLineDash([]);
        }
        else {
            draw_directed_ultraEdge(ultraEdge)
        }
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {  
            draw_iconizedGroup(ultraEdge.obj1)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj2)
        }
    }
    else {
        drawUltraSelfLoop(ultraEdge.obj1, ultraEdge.dir)
        draw_iconizedGroup(ultraEdge.obj1)
    }
}

function erase_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = "white"
            ctx.lineWidth = EDGE_WIDTH*4
            ctx.moveTo(ultraEdge.obj1.x, ultraEdge.obj1.y);
            ctx.lineTo(ultraEdge.obj2.x, ultraEdge.obj2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            erase_directed_ultraEdge(ultraEdge)
        }
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj1)
        }
        else {
            draw_node(ultraEdge.obj1)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj2)
        }
        else {
            draw_node(ultraEdge.obj2)
        }
    }
    else {
        eraseUltraSelfLoop(ultraEdge.obj1, ultraEdge.dir)
    }
}

function erase_edge(edge) {  //have to be sure to delete directed edge if needed 
    if(edge.node1 != edge.node2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = "white"
            ctx.lineWidth = 2*EDGE_WIDTH
            ctx.moveTo(edge.node1.x, edge.node1.y);
            ctx.lineTo(edge.node2.x, edge.node2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            erase_directed_edge(edge)
        }
        draw_node(edge.node1)
        draw_node(edge.node2)
    }
    else {
        eraseSelfLoop(edge.node1, edge.dir)
    }
 }

 function erase_directed_edge(edge) {   
    fromX = edge.node1.x
    toX = edge.node2.x
    fromY = edge.node1.y
    toY = edge.node2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(edge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.strokeStyle = "white"
    ctx.lineWidth = 2*EDGE_WIDTH
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = 2*EDGE_WIDTH
    ctx.strokeStyle = "white"
    ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = "white"
    ctx.fill();
    ctx.stroke()
 }

 function create_edge(edge) {
    edge.node1.edges.add(edge)
    edge.node2.edges.add(edge)
    edges.add(edge)
    draw_edge(edge)
 }

 function delete_edge(edge) {
    erase_edge(edge)
    edge.node1.edges.delete(edge)
    edge.node2.edges.delete(edge)
    edges.delete(edge)
    draw_all_edges()  //repair crosses (very expensive if there are a lot of edges and a lot are being deleted!!)
    draw_all_ultraEdges()
 }

function create_ultraEdge(ultraEdge) {
    ultraEdge.obj1.ultraEdges.add(ultraEdge)
    ultraEdge.obj2.ultraEdges.add(ultraEdge)
    ultraEdges.add(ultraEdge)
    draw_ultraEdge(ultraEdge)
 }

function delete_ultraEdge(ultraEdge) {
    erase_ultraEdge(ultraEdge)
    ultraEdge.obj1.ultraEdges.delete(ultraEdge)
    ultraEdge.obj2.ultraEdges.delete(ultraEdge)
    ultraEdges.delete(ultraEdge)
    draw_all_edges()  //repair crosses 
    draw_all_ultraEdges()
 }
 

 function draw_all_edges() {
    for(let edge of edges) {
        draw_edge(edge)
    }
 }

 function draw_all_ultraEdges() {
    for(let ultraEdge of ultraEdges) {
        draw_ultraEdge(ultraEdge)
    }
 }

function drawSelectionSquare(x, y, side_length, color, line_width=1) { 
    const sideLength = side_length;
    const top_leftX = x - side_length/2; // x-coordinate of the top-left corner
    const top_leftY = y - side_length/2; // y-coordinate of the top-left corner
    ctx.beginPath()
    ctx.strokeStyle = color; // Set stroke color
    if(color == UNSELECT_COLOR) {
        line_width += 2
    }
    ctx.lineWidth = line_width; // Set line width 
    ctx.strokeRect(top_leftX, top_leftY, sideLength, sideLength); 
    ctx.stroke()
    ctx.closePath()
}

function drawSelectionCircle(x, y, radius) { //used for selecting edges
    ctx.beginPath()
    ctx.strokeStyle = "blue";
    //ctx.moveTo(x, y);
    ctx.arc(x, y, radius, 0, 2*Math.PI)
    ctx.fillStyle = EDGE_SELECT_COLOR;
    ctx.fill();
    ctx.lineWidth = 1
    ctx.stroke();
    ctx.closePath()
}

function undrawSelectionCircle(x, y, radius) {  //used for unselecting edges
    ctx.beginPath()
    ctx.strokeStyle = "white";
    //ctx.moveTo(x, y);
    ctx.arc(x, y, radius, 0, 2*Math.PI)
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.lineWidth = 3
    ctx.stroke();
    ctx.closePath()
}

function getSmartArrowOffsetPct(e) {  
    if(e.hasOwnProperty("node1")) {
        edge_length = Math.sqrt((e.node2.y - e.node1.y)*(e.node2.y - e.node1.y) + 
                        (e.node2.x - e.node1.x)*(e.node2.x - e.node1.x))
    }
    else { //e is an UltraEdge
        edge_length = Math.sqrt((e.obj2.y - e.obj1.y)*(e.obj2.y - e.obj1.y) + 
                        (e.obj2.x - e.obj1.x)*(e.obj2.x - e.obj1.x))
    }
    CRITICAL_LENGTH = 300
    if(edge_length > CRITICAL_LENGTH) {
        return ARROW_OFFSET_PCT
    }
    else {
        return (edge_length/CRITICAL_LENGTH)*ARROW_OFFSET_PCT + ((CRITICAL_LENGTH-edge_length)/CRITICAL_LENGTH)*(ARROW_OFFSET_PCT + (1-ARROW_OFFSET_PCT)*ARROW_OFFSET_PCT)
    }
}

function getSelectionTriangleVertices(abstractEdge) {
    vertices = []

    let dx = dy = 0
    let midX = midY = 0
    let angle = 0
    let fromX = toX = fromY = toY = 0
    let arrowheadMultiplier = 1.0
    if(abstractEdge.hasOwnProperty("node1")) {
        fromX = abstractEdge.node1.x
        toX = abstractEdge.node2.x
        fromY = abstractEdge.node1.y
        toY = abstractEdge.node2.y
    }
    else {
        fromX = abstractEdge.obj1.x
        toX = abstractEdge.obj2.x
        fromY = abstractEdge.obj1.y
        toY = abstractEdge.obj2.y
        arrowheadMultiplier = 1.25
    }
    if(fromX != toX || fromY != toY) {
        dx = toX - fromX;
        dy = toY - fromY;
        SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(abstractEdge)
        midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
        midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;
    }
    else {
        midX = fromX
        midY = fromY
        if(abstractEdge.dir == DIR_UP) {
            dx = 10  //arrow should point right
            midX += ARROW_HEAD_LENGTH/2
            midY -= 2*(SELF_LOOP_RADIUS)
        }
        else if(abstractEdge.dir == DIR_RIGHT) {
            dy = 10  //arrow should point down
            midX += 2*(SELF_LOOP_RADIUS)
            midY += ARROW_HEAD_LENGTH/2
        }
        else if(abstractEdge.dir == DIR_DOWN) {
            dx = -10  //arrow should point to the left
            midX -= ARROW_HEAD_LENGTH/2
            midY += 2*(SELF_LOOP_RADIUS)
        }
        else {
            dy = -10  //arrow should pont left
            midX -= 2*(SELF_LOOP_RADIUS)
            midY -= ARROW_HEAD_LENGTH/2
        }
    }
    angle = Math.atan2(-dy, -dx);
    
    p = new Point(midX + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.sin(angle - Math.PI / 6));
    vertices.push(p)
    p = new Point(midX, midY);
    vertices.push(p)
    p = new Point(midX + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.sin(angle + Math.PI / 6));
    vertices.push(p)
    return vertices
}

function drawSelectionTriangle(abstractEdge) {
    let dx = dy = 0
    let midX = midY = 0
    let angle = 0
    let fromX = toX = fromY = toY = 0
    let arrowheadMultiplier = 1.0
    if(abstractEdge.hasOwnProperty("node1")) {
        fromX = abstractEdge.node1.x
        toX = abstractEdge.node2.x
        fromY = abstractEdge.node1.y
        toY = abstractEdge.node2.y
    }
    else {
        fromX = abstractEdge.obj1.x
        toX = abstractEdge.obj2.x
        fromY = abstractEdge.obj1.y
        toY = abstractEdge.obj2.y
        arrowheadMultiplier = 1.25
    }
    if(fromX != toX || fromY != toY) {
        dx = toX - fromX;
        dy = toY - fromY;
        SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(abstractEdge)
        midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
        midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;
    }
    else {
        midX = fromX
        midY = fromY
        if(abstractEdge.dir == DIR_UP) {
            dx = 10  //arrow should point right
            midX += ARROW_HEAD_LENGTH/2
            midY -= 2*(SELF_LOOP_RADIUS)
        }
        else if(abstractEdge.dir == DIR_RIGHT) {
            dy = 10  //arrow should point down
            midX += 2*(SELF_LOOP_RADIUS)
            midY += ARROW_HEAD_LENGTH/2
        }
        else if(abstractEdge.dir == DIR_DOWN) {
            dx = -10  //arrow should point to the left
            midX -= ARROW_HEAD_LENGTH/2
            midY += 2*(SELF_LOOP_RADIUS)
        }
        else {
            dy = -10  //arrow should pont left
            midX -= 2*(SELF_LOOP_RADIUS)
            midY -= ARROW_HEAD_LENGTH/2
        }
    }

    angle = Math.atan2(-dy, -dx);
    ctx.strokeStyle = "blue";
    ctx.beginPath();
    ctx.moveTo(midX + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * arrowheadMultiplier * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = EDGE_SELECT_COLOR
    ctx.fill();
    ctx.stroke()
}

function toggle_select_node(node) {
    if(selected_nodes.has(node)) {
        unselect_node(node)
    }
    else {
        select_node(node)
    }
}

function toggle_select_edge(edge) {
    if(selected_edges.has(edge)) {
        unselect_edge(edge)
    }
    else {
        select_edge(edge)
    }
}

function toggle_select_ultraEdge(ultraEdge) {
    if(selected_ultraEdges.has(ultraEdge)) {
        unselect_ultraEdge(ultraEdge)
    }
    else {
        select_ultraEdge(ultraEdge)
    }
}

function toggle_select_iconizedGroup(icoGroup) {
    if(selected_iconizedGroups.has(icoGroup)) {
        unselect_iconizedGroup(icoGroup)
    }
    else {
        select_iconizedGroup(icoGroup)
    }
}

function select_node(node) {
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    selected_nodes.add(node)
}

function unselect_node(node) {
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    draw_node(node)  //seems to be redundant....
    //redraw any very close nodes
    for(const n of nodes) {
        dist = Math.sqrt(Math.pow((n.x-node.x),2) + Math.pow((n.y-node.y),2))
        if(dist < 3*NODE_DRAW_RADIUS) {
            draw_node(n)
        }
    }
    //redraw any very close iconizedGroups
    for(const i of iconizedGroups) {
        dist = Math.sqrt(Math.pow((i.x-node.x),2) + Math.pow((i.y-node.y),2))
        if(dist < i.radius + 2*NODE_DRAW_RADIUS) {
            draw_iconizedGroup(i)
        }
    }
    //redraw edges (could be impairing not just edges from this node but other very close edges....)
    draw_all_edges()
    for(const e of selected_edges) {
        select_edge(e)
    }
    draw_all_ultraEdges()
    for(const u of selected_ultraEdges) {
        select_ultraEdge(u)
    }
    selected_nodes.delete(node)
}

function select_edge(edge) {
    alreadyInSelectedSet = false
    for(e of selected_edges) {
        if(equalEdges(e, edge)) {
            alreadyInSelectedSet = true
        }
    }
    if(!alreadyInSelectedSet) {
        selected_edges.add(edge)
    }
    else {
        //return  IMMEDIATELY RETURNING CAUSES MOVES OF SELECTED EDGES NOT TO DRAW!!
    }
    if(edge.node1 != edge.node2) {
        edge_length = Math.sqrt(Math.pow((edge.node1.x-edge.node2.x),2) + Math.pow((edge.node1.y-edge.node2.y),2))
        key_ratio = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        square1_x = (1-key_ratio)*edge.node1.x + key_ratio*edge.node2.x
        square1_y = (1-key_ratio)*edge.node1.y + key_ratio*edge.node2.y
        square2_x = key_ratio*edge.node1.x + (1-key_ratio)*edge.node2.x
        square2_y = key_ratio*edge.node1.y + (1-key_ratio)*edge.node2.y
    }
    else {
        square1_x = square2_x = edge.node1.x
        square1_y = square2_y = edge.node1.y
        let dt = 5
        if(edge.dir == DIR_UP) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y -= dt
            square2_y -= dt
        }
        else if(edge.dir == DIR_DOWN) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y += dt
            square2_y += dt
        }
        else if(edge.dir == DIR_RIGHT) {
            square1_x += dt
            square2_x += dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
        else {
            square1_x -= dt
            square2_x -= dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
    }
    drawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    drawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    if(edge_type == TYPE_DIRECTED) {
        drawSelectionTriangle(edge)
    }
}

function select_ultraEdge(ultraEdge) {
    alreadyInSelectedSet = false
    for(let u of selected_ultraEdges) {
        if(equalUltraEdges(u, ultraEdge)) {
            alreadyInSelectedSet = true
        }
    }
    if(!alreadyInSelectedSet) {
        selected_ultraEdges.add(ultraEdge)
    }
    else {
        //return  IMMEDIATELY RETURNING CAUSES MOVES OF SELECTED EDGES NOT TO DRAW!!
    }
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        let ultraEdge_length = Math.sqrt(Math.pow(ultraEdge.obj1.x - ultraEdge.obj2.x, 2) + Math.pow(ultraEdge.obj1.y - ultraEdge.obj2.y, 2))
        radius1 = radius2 = NODE_DRAW_RADIUS
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj2.x, ultraEdge.obj2.y), ultraEdge.obj1)
            radius1 = ultraEdge_length - d
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj1.x, ultraEdge.obj1.y), ultraEdge.obj2)
            radius2 = ultraEdge_length - d
        }
        //key_ratio1 = key_ratio2 = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        key_ratio1 = (ultraEdge_length - (radius2 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
        key_ratio2 = (ultraEdge_length - (radius1 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
    
        square1_x = (1-key_ratio1)*ultraEdge.obj1.x + key_ratio1*ultraEdge.obj2.x
        square1_y = (1-key_ratio1)*ultraEdge.obj1.y + key_ratio1*ultraEdge.obj2.y
        square2_x = key_ratio2*ultraEdge.obj1.x + (1-key_ratio2)*ultraEdge.obj2.x
        square2_y = key_ratio2*ultraEdge.obj1.y + (1-key_ratio2)*ultraEdge.obj2.y
    }
    else {
        square1_x = square2_x = ultraEdge.obj1.x
        square1_y = square2_y = ultraEdge.obj1.y
        let dt = 5
        if(ultraEdge.dir == DIR_UP) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y -= dt
            square2_y -= dt
        }
        else if(ultraEdge.dir == DIR_DOWN) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y += dt
            square2_y += dt
        }
        else if(ultraEdge.dir == DIR_RIGHT) {
            square1_x += dt
            square2_x += dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
        else {
            square1_x -= dt
            square2_x -= dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
    }
    drawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    drawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    if(edge_type == TYPE_DIRECTED) {
        drawSelectionTriangle(ultraEdge)
    }
}

function unselect_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        let ultraEdge_length = Math.sqrt(Math.pow(ultraEdge.obj1.x - ultraEdge.obj2.x, 2) + Math.pow(ultraEdge.obj1.y - ultraEdge.obj2.y, 2))
        radius1 = radius2 = NODE_DRAW_RADIUS
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj2.x, ultraEdge.obj2.y), ultraEdge.obj1)
            radius1 = ultraEdge_length - d
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj1.x, ultraEdge.obj1.y), ultraEdge.obj2)
            radius2 = ultraEdge_length - d
        }
        //key_ratio1 = key_ratio2 = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        key_ratio1 = (ultraEdge_length - (radius2 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
        key_ratio2 = (ultraEdge_length - (radius1 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
    
        square1_x = (1-key_ratio1)*ultraEdge.obj1.x + key_ratio1*ultraEdge.obj2.x
        square1_y = (1-key_ratio1)*ultraEdge.obj1.y + key_ratio1*ultraEdge.obj2.y
        square2_x = key_ratio2*ultraEdge.obj1.x + (1-key_ratio2)*ultraEdge.obj2.x
        square2_y = key_ratio2*ultraEdge.obj1.y + (1-key_ratio2)*ultraEdge.obj2.y
    }
    else {  
        //not yet implemented
    }
    undrawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    undrawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    //redraw the edge objects and their seleciton indicators
    if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
        draw_iconizedGroup(ultraEdge.obj1)
        if(selected_iconizedGroups.has(ultraEdge.obj1)) {
            select_iconizedGroup(ultraEdge.obj1)
        }
    }
    else {
        draw_node(ultraEdge.obj1)
        if(selected_nodes.has(ultraEdge.obj1)) {
            select_node(ultraEdge.obj1)
        }
    }
    if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
        draw_iconizedGroup(ultraEdge.obj2)
        if(selected_iconizedGroups.has(ultraEdge.obj2)) {
            select_iconizedGroup(ultraEdge.obj2)
        }
    }
    else {
        draw_node(ultraEdge.obj2)
        if(selected_nodes.has(ultraEdge.obj2)) {
            select_node(ultraEdge.obj2)
        }
    }

    draw_all_edges()
    draw_all_ultraEdges()
    //could be clobbering some selected edges and ultraEdges so redraw them (could be more careful about this)
    for(const e of selected_edges) {
        select_edge(e)
    }
    for(const u of selected_ultraEdges) {
        if(!equalUltraEdges(u, ultraEdge)) {
            select_ultraEdge(u)
        }
    }
    selected_ultraEdges.delete(ultraEdge)
}

function unselect_edge(edge) {
    if(edge.node1 != edge.node2) {
        edge_length = Math.sqrt(Math.pow((edge.node1.x-edge.node2.x),2) + Math.pow((edge.node1.y-edge.node2.y),2))
        key_ratio = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        square1_x = (1-key_ratio)*edge.node1.x + key_ratio*edge.node2.x
        square1_y = (1-key_ratio)*edge.node1.y + key_ratio*edge.node2.y
        square2_x = key_ratio*edge.node1.x + (1-key_ratio)*edge.node2.x
        square2_y = key_ratio*edge.node1.y + (1-key_ratio)*edge.node2.y
    }
    else {
        square1_x = square2_x = edge.node1.x
        square1_y = square2_y = edge.node1.y
        let dt = 5
        if(edge.dir == DIR_UP) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y -= dt
            square2_y -= dt
        }
        else if(edge.dir == DIR_DOWN) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y += dt
            square2_y += dt
        }
        else if(edge.dir == DIR_RIGHT) {
            square1_x += dt
            square2_x += dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
        else {
            square1_x -= dt
            square2_x -= dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
    }
    undrawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    undrawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    //redraw the edge nodes and their seleciton indicators
    draw_node(edge.node1)
    draw_node(edge.node2)
    if(selected_nodes.has(edge.node1)) {
        select_node(edge.node1)
    }
    if(selected_nodes.has(edge.node2)) {
        select_node(edge.node2)
    }
    draw_all_edges()
    draw_all_ultraEdges
    //could be clobbering some selected edges or ultraEdges so redraw them (could be more careful about this)
    for(const e of selected_edges) {
        if(!equalEdges(e, edge)) {
            select_edge(e)
        }
    }
    for(const u of selected_ultraEdges) {
        select_ultraEdge(u)
    }
    selected_edges.delete(edge)
}

function isViableDrag(event) {
    if(event.button == 0) {
        if (Math.abs(event.clientX - canvas.offsetLeft - DIVIDING_LINE_LOC) <= DIVIDING_LINE_BUFFER)  {  
                //reject if too close to dividing line
            return false
        }
        else if(event.clientY - canvas.offsetTop < TOP_BUFFER) {  //reject if in top buffer
            //return false
            return true    //no longer rejecting these
        }
        else {
            return true
        }
    }
    else {
        return false
    }
}

function isClickInAnOrderInputBox(event) {
    //let CLICK_BUFF = 3
    const cursor = getComputedStyle(event.target).cursor;  //the text cursor gives screwy coordinates....
    return cursor == "text"
    /*console.log(cursor);
    if(orderings_are_being_displayed) {
        for(let node of nodes) {
            orderInputBox = node_id_to_inputBox_map.get(node.id)
            bdgRect = orderInputBox.getBoundingClientRect()
            if(x >= bdgRect.left - CLICK_BUFF && x <= bdgRect.left + bdgRect.width  + CLICK_BUFF &&
                y >= bdgRect.top - CLICK_BUFF && y <= bdgRect.top + bdgRect.height  + CLICK_BUFF) {
                beep()
                orderInputBox.focus()
                return true
            }
        }
        return false
    }
    else {
        return false
    }*/
}

function process_click(event) {
    x = event.clientX - canvas.offsetLeft
    y = event.clientY - canvas.offsetTop

    if(isClickInAnOrderInputBox(event)) {
        return false
    }

    if(wasDragging) {
        wasDragging = false
        return false
    }
    else if (Math.abs(x - DIVIDING_LINE_LOC) <= DIVIDING_LINE_BUFFER) {  //reject if too close to dividing line
        return false
    }
    else if(y < TOP_BUFFER || y > canvas.height - BOTTOM_BUFFER) {  //reject if in top buffer or too low in the canvas
        return false
    }
    else {
        return true
    }
}

function clearSelectionFromAllButNode(node) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        if(selected_nodes_list[i] != node) {
            unselect_node(selected_nodes_list[i])
        }
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function clearSelectionFromAllButEdge(edge) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        if(selected_edge_list[i] != edge) {
            unselect_edge(selected_edge_list[i])
        }
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function clearSelectionFromAllButUltraEdge(ultraEdge) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }

    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        if(selected_ultraEdge_list[i] != ultraEdge) {
            unselect_ultraEdge(selected_ultraEdge_list[i])
        }
    }
}

function clearSelectionFromAllButIconizedGroup(icoGroup) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        if(selected_iconizedGroup_list[i] != icoGroup) {
            unselect_iconizedGroup(selected_iconizedGroup_list[i])
        }
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function clearSelection() {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function getPointToDirectedEdgeDistance(point, edge) { //here the target is the direction triangle
    return getPointToDirectedAbstractEdgeDistance(point, edge, edge.node1.x, edge.node1.y, edge.node2.x, edge.node2.y) 
}

function getPointToDirectedUltraEdgeDistance(point, ultraEdge) {
    return getPointToDirectedAbstractEdgeDistance(point, ultraEdge, ultraEdge.obj1.x, ultraEdge.obj1.y, 
        ultraEdge.obj2.x, ultraEdge.obj2.y) 
}

function getPointToDirectedAbstractEdgeDistance(point, abstractEdge, x1, y1, x2, y2) {
    vertices = getSelectionTriangleVertices(abstractEdge)
    let x_sum = y_sum = 0
    for(let v of vertices) {
        x_sum += v.x
        y_sum += v.y
    }
    let centroid = new Point(x_sum/3, y_sum/3)
    let seg = new Segment(point, centroid)
    let seg1 = new Segment(vertices[0], vertices[1])
    let int_pt = getIntersectPoint(seg, seg1)
    if(int_pt != undefined) {
        return Math.sqrt(Math.pow(point.x-int_pt.x, 2) + Math.pow(point.y-int_pt.y, 2))
    }
    let seg2 = new Segment(vertices[1], vertices[2])
    int_pt = getIntersectPoint(seg, seg2)
    if(int_pt != undefined) {
        return Math.sqrt(Math.pow(point.x-int_pt.x, 2) + Math.pow(point.y-int_pt.y, 2))
    }
    let seg3 = new Segment(vertices[2], vertices[0])
    int_pt = getIntersectPoint(seg, seg3)
    if(int_pt != undefined) {
        return Math.sqrt(Math.pow(point.x-int_pt.x, 2) + Math.pow(point.y-int_pt.y, 2))
    }
    else {
         return 0
    }
}

function getPointToUndirectedAbstractEdgeDistance(point, x1, y1, x2, y2) {
    if(x1 != x2 || y1 != y2) {
        let A = B = C = 0
        if(x1 == x2) {
            //B = 1
            //C = -1*edge.node1.x
            if(point.y >= Math.min(y1, y2) && point.y <= Math.max(y1, y2)) {
                return Math.abs(point.x - x1)
            }
            else {
                //let d1 = Math.sqrt((point.x - edge.node1.x)*(point.x - edge.node1.x) + (point.y - edge.node1.y)*(point.y - edge.node1.y))
                //let d2 = Math.sqrt((point.x - edge.node2.x)*(point.x - edge.node2.x) + (point.y - edge.node2.y)*(point.y - edge.node2.y))
                //return Math.min(d1, d2)
                return INFINITE  //want to reject these clicks!
            }
        }
        else {
            A = y2 - y1
            B = x2 - x1
            C = x2*y1 - y2*x1
        }

        pt_line_dist = Math.abs(A*point.x - B*point.y + C)/Math.sqrt(A*A + B*B)

        edge_length = Math.sqrt(Math.pow((x1-x2),2) + Math.pow((y1-y2),2))
        test_distance1 = Math.sqrt(Math.pow((x1-point.x),2) + Math.pow((y1-point.y),2))
        test_distance2 = Math.sqrt(Math.pow((x2-point.x),2) + Math.pow((y2-point.y),2))
        
        if(test_distance1 < edge_length && test_distance2 < edge_length) {
            return pt_line_dist
        }
        else {
            return edge_length  //we want to reject these clicks so we don't bother with the exact calculation here....
                                //Modify to do proper calculation here if needed
        }
    }
    else {  //in this case it is the point to circle distance
        //Not doing this in a very good way
        //let d = Math.abs(Math.sqrt(Math.pow(point.x - edge.node1.x, 2) + Math.pow(point.y - edge.node1.y, 2)) - SELF_LOOP_RADIUS)
        //return d
        let disk_center = undefined
        let x = x1
        let y = y1
        if(edge.dir==DIR_UP) {
            disk_center = new Point(x, y-SELF_LOOP_RADIUS)
        }
        else if(edge.dir==DIR_RIGHT) {
            disk_center = new Point(x+SELF_LOOP_RADIUS, y)
        }
        else if(edge.dir==DIR_DOWN) {
            disk_center = new Point(x, y+SELF_LOOP_RADIUS)
        }
        else {
            disk_center = new Point(x-SELF_LOOP_RADIUS, y)
        }
        let d = Math.sqrt(Math.pow(point.x - disk_center.x, 2) + Math.pow(point.y - disk_center.y, 2)) 
        return Math.abs(d - SELF_LOOP_RADIUS)
    }
}

function getPointToIconizedGroupIconDistance(point, icoGroup) {
    consecutiveVertices = getPolygonVerticesForIconizedGroup(icoGroup)
    seg1 = new Segment(point, new Point(icoGroup.x, icoGroup.y))
    for(let i = 0; i < consecutiveVertices.length -1; i++) {
        seg2 = new Segment(consecutiveVertices[i], consecutiveVertices[i+1])
        int_pt = getIntersectPoint(seg1, seg2)
        if(int_pt != undefined) {
            return Math.sqrt(Math.pow(point.x - int_pt.x, 2) + Math.pow(point.y - int_pt.y, 2))
        }
    }
}

//Gets the intersection point of two line segments, under the assumption that the two line segs
// are NOT collinear.
function getIntersectPoint(seg1, seg2) {
  const s1_x = seg1.pt2.x - seg1.pt1.x;
  const s1_y = seg1.pt2.y - seg1.pt1.y;
  const s2_x = seg2.pt2.x - seg2.pt1.x;
  const s2_y = seg2.pt2.y - seg2.pt1.y;

  const s = (-s1_y * (seg1.pt1.x - seg2.pt1.x) + s1_x * (seg1.pt1.y - seg2.pt1.y)) / (-s2_x * s1_y + s1_x * s2_y);
  const t = ( s2_x * (seg1.pt1.y - seg2.pt1.y) - s2_y * (seg1.pt1.x - seg2.pt1.x)) / (-s2_x * s1_y + s1_x * s2_y);

  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return new Point(seg1.pt1.x + (t * s1_x), seg1.pt1.y + (t * s1_y));
  }

  return undefined;
}

function getPointToUndirectedEdgeDistance(point, edge) { //here the target is the entire edge
    return getPointToUndirectedAbstractEdgeDistance(point, edge.node1.x, edge.node1.y, edge.node2.x, edge.node2.y)
}



function getPointToEdgeDistance(point, edge) { //used to determine if user has clicked on an edge
    if(edge_type == TYPE_UNDIRECTED) {
        return getPointToUndirectedEdgeDistance(point, edge)
    }
    else {
        return getPointToDirectedEdgeDistance(point, edge)
    }
}

function getPointToUltraEdgeDistance(point, ultraEdge) { //used to determine if user has clicked on an edge
    if(edge_type == TYPE_UNDIRECTED) {
        return getPointToUndirectedAbstractEdgeDistance(point, ultraEdge.obj1.x, ultraEdge.obj1.y, ultraEdge.obj2.x, ultraEdge.obj2.y)
    }
    else {
        return getPointToDirectedUltraEdgeDistance(point, ultraEdge)
    }
}



prior_width = 0; 
prior_height = 0;
wasDragging = false

function smartClearRect(event) {
    deltaX = 1
    deltaY = 1
    if(prior_width < 0) {
        deltaX = -1
    }
    if(prior_height < 0) {
        deltaY = -1
    }
    keepSelections = false
    if(event.shiftKey || event.metaKey) { 
        keepSelections = true
    }
    ctx.clearRect(startX-deltaX, startY-deltaY, prior_width+2*deltaX, prior_height+2*deltaY);
    const rect = new Rectangle(startX-deltaX, startY-deltaY, prior_width+2*deltaX, prior_height+2*deltaY)
    for(const node of nodes) {
        if(nodeInRect(node, rect)) {
            draw_node(node)
            if(keepSelections && selected_nodes.has(node)) {
                select_node(node)
            }
        }
    }
    draw_all_edges()
    draw_all_ultraEdges()
    draw_all_iconizedGroups()
    if(keepSelections) {
        for(const edge of selected_edges) {
            select_edge(edge)
        }
        for(const icoGroup of selected_iconizedGroups) {
            select_iconizedGroup(icoGroup)
        }
    }
    drawDividingLine()
}

  function redrawRectangle(x, y, width, height) {
    ctx.clearRect(x, y, width, height)
    draw_all_edges()
    for(let edge of selected_edges) {
        select_edge(edge)
    }
    draw_all_ultraEdges()
    for(let ultraEdge of selected_ultraEdges) {
        select_ultraEdge(ultraEdge)
    }
    draw_all_nodes()
    for(let node of selected_nodes) {
        select_node(node)
    }
    draw_all_iconizedGroups()
    for(let icoGroup of selected_iconizedGroups) {
        select_iconizedGroup(icoGroup)
    }
    drawDividingLine()
  }

  //call the below function with icoGroup == udefined to get all nested nodes and icoGroups period
  function getAllNestedNodesAndIcoGroups(icoGroup) {
    let allNestedOnes = []

    if(icoGroup == undefined) {
        for(let n of nodes) {
            allNestedOnes.push(n)
        }
        for(let i of iconizedGroups) {
            allNestedOnes.push(i)
            allNestedOnes = allNestedOnes.concat(getAllNestedNodesAndIcoGroups(i))
        }
    }
    else {
        for(let n of icoGroup.inner_nodes) {
            allNestedOnes.push(n)
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            allNestedOnes.push(i)
            allNestedOnes = allNestedOnes.concat(getAllNestedNodesAndIcoGroups(i))
        }
    }

    return allNestedOnes
  }

  function getAllNestedNodesBySide(whichside) {
    let allNestedNodes = []
    for(let n of nodes) {
        if((n.x < DIVIDING_LINE_LOC && whichside == EXISTS_SIDE) ||
          (n.x > DIVIDING_LINE_LOC && whichside == FORALL_SIDE)) {
            allNestedNodes.push(n)
        }
    }

    for(let i of iconizedGroups) {
        if((i.x < DIVIDING_LINE_LOC && whichside == EXISTS_SIDE) ||
          (i.x > DIVIDING_LINE_LOC && whichside == FORALL_SIDE)) {
            allNestedNodes = allNestedNodes.concat(getAllNestedNodes(i))
        }
    }

    return allNestedNodes
  }

  function getHightestNodeOrderOnSide(whichside) {
    nodesOnSide = getAllNestedNodesBySide(whichside)
    let highestOrder = NO_ORDER
    for(let node of nodesOnSide) {
        if(node.order > highestOrder) {
            highestOrder = node.order
        }
    }

    return highestOrder
  }
  
  //call the below function with icoGroup == udefined to get all nested nodes period.
  //NOTE that the node.x values are not indicative of the side the nodes are on!!!
  function getAllNestedNodes(icoGroup) {
    let allNestedNodes = []

    if(icoGroup == undefined) {
        for(let n of nodes) {
            allNestedNodes.push(n)
        }
        for(let i of iconizedGroups) {
            allNestedNodes = allNestedNodes.concat(getAllNestedNodes(i))
        }
    }
    else {
        for(let n of icoGroup.inner_nodes) {
            allNestedNodes.push(n)
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            allNestedNodes = allNestedNodes.concat(getAllNestedNodes(i))
        }
    }

    return allNestedNodes
  }

  function coerceToNode(n) {
    if(n instanceof Node) {
        return n
    }
    else {
        let node = new Node(n.x, n.y, n.id, n.constant)
        if(n.edges != undefined && n.edges instanceof Set) {
            node.edges = n.edges
        }
        else {
            node.edges = new Set()
        }
        if(n.ultraEdges != undefined && n.ultraEdges instanceof Set) {
            node.ultraEdges = n.ultraEdges
        }
        else {
            node.ultraEdges = new Set()
        }
        node.order = n.order
        //node.parent = n.parent
        return node
    }

  }

  function coerceToEdge(e) {
    if(e instanceof Edge) {
        return e
    }
    else {
        let edge = new Edge(e.node1, e.node2, e.dir)
        return edge
    }
  }

  function coerceToUltraEdge(u) {
    if(u instanceof UltraEdge) {
        return u
    }
    else {
        let ultraEdge = new UltraEdge(u.obj1, u.obj2, u.dir)
        return ultraEdge
    }
  }


  function coerceToIconizedGroup(o) {
    if(o instanceof IconizedGroup) {
        return o
    }
    else {
        if(o.inner_nodes instanceof Array) {
            o.inner_nodes = new Set(o.inner_nodes)
        }
        else if(!(o.inner_nodes instanceof Set)) {
            o.inner_node = new Set()
        }
        if(o.inner_edges instanceof Array) {
            o.inner_edges = new Set(o.inner_edges)
        }
        else if(!(o.inner_edges instanceof Set)) {
            o.inner_edges = new Set()
        }
        if(o.inner_iconizedGroups instanceof Array) {
            o.inner_iconizedGroups = new Set(o.inner_iconizedGroups)
        }
        else if(!(o.inner_iconizedGroups instanceof Set)) {
            o.inner_iconizedGroups = new Set()
        }
        if(o.inner_ultraEdges instanceof Array) {
            o.inner_ultraEdges = new Set(o.inner_ultraEdges)
        }
        else if(!(o.inner_ultraEdgs instanceof Set)) {
            o.inner_ultraEdges = new Set()
        }
        if(o.ultraEdges instanceof Array) {
            o.ultraEdges = new Set(o.ultraEdges)
        }
        else if(!(o.ultraEdges instanceof Set)) {
            o.ultraEdges = new Set()
        }

        let icoGroup = new IconizedGroup(o.inner_nodes, o.inner_edges, o.inner_iconizedGroups, 
                o.inner_ultraEdges, o.ultraEdges, o.x, o.y, o.num_sides, o.radius, 
                o.fill_color, o.label)
        icoGroup.id = o.id
        iconizedGroup_id_counter--
        icoGroup.parent = o.parent
        for(let inner_node of o.inner_nodes) {
            inner_node.parent = icoGroup
        }
        for(let inner_icoGroup of o.inner_iconizedGroups) {
            inner_icoGroup.parent = icoGroup
        }
        return icoGroup
    }

  }

  function getAllNestedIconizedGroups(icoGroup) {   
    let allNestedIcos = []

    if(icoGroup == undefined) {
        for(let i of iconizedGroups) {
            allNestedIcos.push(coerceToIconizedGroup(i))
            allNestedIcos = allNestedIcos.concat(getAllNestedIconizedGroups(i))
        }
    }
    else {
        for(let i of icoGroup.inner_iconizedGroups) {
            allNestedIcos.push(coerceToIconizedGroup(i))
            allNestedIcos = allNestedIcos.concat(getAllNestedIconizedGroups(i))
        }
    }

    return allNestedIcos
  }

  function createNodeOrderingBox(node) {  //if node.order is not set, node.x must be inidicative of side node will go on
    const ORDERING_BOX_WIDTH = 20 //was `17
    const ORDERING_BOX_HEIGHT = 15

    if(node.order == NO_ORDER) {
        let some_nodes_have_orders = false
        let which_side = (node.x < DIVIDING_LINE_LOC ? EXISTS_SIDE : FORALL_SIDE)
        let max_order_on_this_side = getHightestNodeOrderOnSide(which_side)
        if(max_order_on_this_side > NO_ORDER) {
            some_nodes_have_orders = true
        }

        //if(some_nodes_have_orders || orderings_are_being_displayed) {
        if(nodes_are_ordered) {
            if(max_order_on_this_side > NO_ORDER) {
                node.order = Math.floor(max_order_on_this_side + 1)
            }
            else {
                node.order = 1
            }
        }
    }

    orderInputBox = createTextBox(node.x + ORDERING_BOX_OFFSET_X, node.y + ORDERING_BOX_OFFSET_Y, node.order, 
                    ORDERING_BOX_WIDTH, ORDERING_BOX_HEIGHT)
    node_id_to_inputBox_map.set(node.id, orderInputBox)
    return orderInputBox
  }

  function orderNodesbyId() {
    let left_hand_nodes = Array.from(getAllNestedNodesBySide(EXISTS_SIDE))
    let right_hand_nodes = Array.from(getAllNestedNodesBySide(FORALL_SIDE))
    left_hand_nodes.sort((a,b) => a.id - b.id);
    right_hand_nodes.sort((a,b) => a.id - b.id);
    for(i=0; i<left_hand_nodes.length; i++) {
        left_hand_nodes[i].order = i+1
    }
    for(i=0; i<right_hand_nodes.length; i++) {
        right_hand_nodes[i].order = i+1
    }
  }

  function orderUnorderedNodesById() {
    let left_hand_unordered_nodes = []
    let right_hand_unordered_nodes = []
    let highest_left_hand_ordering = 0
    let highest_right_hand_ordering = 0

    let left_hand_nodes = getAllNestedNodesBySide(EXISTS_SIDE)
    let right_hand_nodes = getAllNestedNodesBySide(FORALL_SIDE)
    for(let node of left_hand_nodes) {
        if(node.order == NO_ORDER) {
            left_hand_unordered_nodes.push(node)
        }
        else if(node.order > highest_left_hand_ordering) {
            highest_left_hand_ordering = node.order
        }
    }
    for(let node of right_hand_nodes) {
        if(node.order == NO_ORDER) {
            right_hand_unordered_nodes.push(node)
        }
        else if(node.order > highest_right_hand_ordering) {
            highest_right_hand_ordering = node.order
        }
    }    
    
    left_hand_unordered_nodes.sort((a,b) => a.id - b.id);
    right_hand_unordered_nodes.sort((a,b) => a.id - b.id);
    
    for(i=0; i<left_hand_unordered_nodes.length; i++) {
        left_hand_unordered_nodes[i].order = ++highest_left_hand_ordering
    }
    for(i=0; i<right_hand_unordered_nodes.length; i++) {
        right_hand_unordered_nodes[i].order = ++highest_right_hand_ordering
    }
  }

  function nodesAreAllUnordered() {
    let allNestedNodes = getAllNestedNodes(undefined)
    for(let node of allNestedNodes) {
        if(node.order != NO_ORDER) {
            return false
        }
    }

    return true
  }

  function displayNodeOrderings() {
    const ORDERING_BOX_WIDTH = 17
    const ORDERING_BOX_HEIGHT = 15
    for(let node of nodes) {
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.left = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
        orderInputBox.style.top = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        orderInputBox.style.display = "initial"
        if(node.order != NO_ORDER) {
            orderInputBox.value = node.order
        }
        else {
            orderInputBox.value = ''
        }
    }
  }

  function hideNodeOrderings() {
    for(let node of nodes) {
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.display = "none"
    }
  }

  function createTextBox(x, y, value, width, height) {
        const input = document.createElement('input');
        input.type = 'text';
        input.style.position = 'absolute';
        input.style.left = x + 'px';
        input.style.top = y + 'px';
        input.style.width = width + 'px';
        input.style.height = height + 'px';
        input.style.textAlign = 'center'
        input.style.fontSize = "8pt"
        input.maxLength = 3
        input.pattern = "[0-9]{3}"
        if(value != NO_ORDER && !isNaN(value)) {
            input.value = value
        }
        
        
        document.body.appendChild(input);

        input.addEventListener('input', function(event) {
            const allowedChars = /^[0-9.-]*$/; // Allows only numbers
            if (!allowedChars.test(this.value)) {
                beep()
                this.value = this.value.replace(/[^0-9.-]/g, ''); //Removes invalid characters
            }
        });

        input.addEventListener('blur', function(event) {
            for(let node of nodes) {
                ibox = node_id_to_inputBox_map.get(node.id)
                if(ibox == this) {
                    node.order = Number(this.value)
                    if(isNaN(node.order) || node.order == 0) {
                        node.order = NO_ORDER
                        ibox.value = ''
                    }
                }
            }
            killClickEvent = true
        });
       
       
        input.addEventListener('keyup', function(event) {
            event.stopPropagation()   //Don't propagate deletes to selected nodes and other things like that
        });


        return input;
    }   

    function createConstantBox(x, y, value, width, height) {
        const input = document.createElement('input');
        input.type = 'text';
        input.style.position = 'absolute';
        input.style.left = x + 'px';
        input.style.top = y + 'px';
        input.style.width = width + 'px';
        input.style.height = height + 'px';
        input.style.textAlign = 'center'
        input.style.fontSize = "8pt"
        input.style.border = "2px solid"
        input.style.borderColor = "Blue"
        //input.disabled = true  //uncomment on game_play page!
        input.value = value
        input.maxLength = 3
        input.style.backgroundColor = "yellow"        
        
        document.body.appendChild(input);


        ignoreBlur = false  //a bit of a hack
        input.addEventListener('blur', function(event) {
            if(ignoreBlur) {
                ignoreBlur = false
                return
            }
            for(let node of nodes) {
                cbox = node_id_to_constantBox_map.get(node.id)
                if(cbox == this) {  
                    if(node.constant == this.value) { //they didn't change anything
                        if(this.value == '') {
                            removeConstantBox(node)
                        }
                        killClickEvent = true 
                        return 
                    }
                    if(this.value != '') {
                        if(node.x < DIVIDING_LINE_LOC) {
                            if(isConstantInUseOnLeft(this.value)) {
                                alert("Constant is already in use on this side!")
                                this.value = node.constant
                                ignoreBlur = true
                                this.focus()
                                return
                            }
                        }
                        else {
                            if(isConstantInUseOnRight(this.value)) {
                                alert("Constant is already in use on this side!")
                                this.value = node.constant
                                ignoreBlur = true
                                this.focus()
                                return
                            }
                        }
                        node.constant = this.value
                    }
                    else { //remove constant box and flag pole
                        node.constant = ''
                        removeConstantBox(node)
                    }
                }
            }
            killClickEvent = true 
        });
       
        input.addEventListener('keyup', function(event) {
            event.stopPropagation()   //Don't propagate deletes to selected nodes and other things like that
        });


        return input;
    } 
  
  function redrawAll() {
    minX = canvas.width
    maxX = 0
    minY = canvas.height
    maxY = 0
    for(let node of nodes) {
        if(node.x < minX) {
            minX = node.x
        }
        if(node.x > maxX) {
            maxX = node.x
        }
        if(node.y < minY) {
            minY = node.y
        }
        if(node.y > maxY) {
            maxY = node.y
        }
    }
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.x < minX) {
            minX = icoGroup.x
        }
        if(icoGroup.x > maxX) {
            maxX = icoGroup.x
        }
        if(icoGroup.y < minY) {
            minY = icoGroup.y
        }
        if(icoGroup.y > maxY) {
            maxY = icoGroup.y
        }
    }
    REDRAW_BUFF = 100
    if(maxX >= minX && maxY >= minY) {    //there could just be a single node or a bunch of horizontal/vertical nodes
        redrawRectangle(minX-REDRAW_BUFF, minY-REDRAW_BUFF, maxX-minX+2*REDRAW_BUFF, maxY-minY+2*REDRAW_BUFF)
    }
  }

  function nodeInRect(node, rect) {
    tolerance = NODE_DRAW_RADIUS
    rect_left = Math.min(rect.x, rect.x + rect.width) - tolerance
    rect_right = Math.max(rect.x, rect.x + rect.width) + tolerance 
    rect_top = Math.min(rect.y, rect.y + rect.height) - tolerance
    rect_bottom = Math.max(rect.y, rect.y + rect.height) + tolerance
    return rect_left <= node.x && node.x <= rect_right && rect_top <= node.y && node.y <= rect_bottom
  }

  function iconizedGroupInRect(icoGroup, rect) {
    tolerance = icoGroup.radius
    rect_left = Math.min(rect.x, rect.x + rect.width) - tolerance
    rect_right = Math.max(rect.x, rect.x + rect.width) + tolerance 
    rect_top = Math.min(rect.y, rect.y + rect.height) - tolerance
    rect_bottom = Math.max(rect.y, rect.y + rect.height) + tolerance
    return rect_left <= icoGroup.x && icoGroup.x <= rect_right && rect_top <= icoGroup.y && icoGroup.y <= rect_bottom
  }

  function drawDragRectangle(event) {
    smartClearRect(event)
    const width = endX - startX;
    const height = endY - startY;
    ctx.beginPath()
    ctx.lineWidth = 1;
    //ctx.globalAlpha = 0.5; 
    ctx.strokeStyle = 'red';
    ctx.setLineDash([10, 5]);
    ctx.strokeRect(startX, startY, width, height);
    ctx.setLineDash([]);
    //ctx.globalAlpha = 1.0;
    prior_width = width
    prior_height = height
    ctx.closePath()
  }

  function selectAll() {
    for(const node of nodes) {
        select_node(node)
    }
    for(const icoGroup of iconizedGroups) {
        select_iconizedGroup(icoGroup)
    }
    for(const edge of edges) {
        select_edge(edge)
    }
    for(const ultraEdge of ultraEdges) {
        select_ultraEdge(ultraEdge)
    }
  }


  document.addEventListener('mousedown', function(event) {
    console.log('document got mousedown')
    if(isAModalDialogOpen()) {
        return
    }
    killClickEvent = true
    if(isViableDrag(event)) {
        isDragging = true;
        startX = event.clientX - canvas.offsetLeft;
        startY = event.clientY - canvas.offsetTop;
        dragging_node = undefined
        dragging_iconizedGroup = undefined
        if(!group_processing_active) {
            if(active_grouping_rectangle == undefined || !isPointWithinToleranceOfDistanceToGroupingRectangle(startX, startY)) {
                dragging_node = get_clicked_on_node(event)  //undefined if not dragging a node
                dragging_iconizedGroup = get_clicked_on_iconizedGroup(event)
                if(active_grouping_rectangle != undefined) {
                    killGroupingRectangle()
                }
                killClickEvent = false
            }
        }
        else {
            group_processing_active = false
        }
    }
  });

  contextMenuItems = ['Order Nodes', 'Display Node Ordering', 'Order Selected Nodes Left to Right', 
                                'Shrink Selection', 'Expand Selection', 'Insert Grid of Nodes...', 'Insert a Cycle of Nodes...']
  contextMenuPrefix = ['', '', '', '', '', '' , '']
  ORDER_NODES_INDEX = 0
  DISPLAY_ORDERINGS_INDEX = 1
  ORDER_LEFT_TO_RIGHT_INDEX = 2
  SHRINK_SELECTED_INDEX = 3
  EXPAND_SELECTED_INDEX = 4
  INSERT_GRID_INDEX = 5
  INSERT_CYCLE_INDEX = 6
  nodeContextMenuItems = ['Assign a Constant', 'Create a Self-Loop    \u25BE']
  ASSIGN_CONSTANT_INDEX = 0
  SELF_LOOP_INDEX = 1
  selfLoopMenuItems = ['Above', 'To the Right', 'Below', 'To the Left']
  LOOP_ABOVE_INDEX = 0
  LOOP_RIGHT_INDEX = 1
  LOOP_BELOW_INDEX = 2
  LOOP_LEFT_INDEX = 3
  groupMenuItems = ['Iconize Group', 'Ungroup']
  ICONIZE_INDEX = 0
  UNGROUP_INDEX = 1
  iconizedGroupContextMenuItems = ['Change Icon/Label','Edit Group Contents', 'Explode Iconized Group']
  ICO_GROUP_CHANGE_ICON_INDEX = 0
  ICO_GROUP_EDIT_INDEX = 1
  ICO_GROUP_EXPAND_INDEX = 2

  function drawSelfLoop(node, dir=DIR_UP) {  //will also eventuall add an arrow if edges are directed
        let x = node.x
        let y = node.y
        ctx.lineWidth = EDGE_WIDTH;  
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        if(dir==DIR_UP) {
            ctx.arc(x, y-SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_RIGHT) {
            ctx.arc(x+SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_DOWN) {
            ctx.arc(x, y+SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else {
            ctx.arc(x-SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        ctx.stroke(); 

        if(edge_type == TYPE_DIRECTED) {
            let dx = dy = 0;
            let midX = node.x
            let midY = node.y
            if(dir == DIR_UP) {
                dx = 10  //arrow should point right
                midX += ARROW_HEAD_LENGTH/2
                midY -= 2*(SELF_LOOP_RADIUS)
            }
            else if(dir == DIR_RIGHT) {
                dy = 10  //arrow should point down
                midX += 2*(SELF_LOOP_RADIUS)
                midY += ARROW_HEAD_LENGTH/2
            }
            else if(dir == DIR_DOWN) {
                dx = -10  //arrow should point to the left
                midX -= ARROW_HEAD_LENGTH/2
                midY += 2*(SELF_LOOP_RADIUS)
            }
            else {
                dy = -10  //arrow should pont left
                midX -= 2*(SELF_LOOP_RADIUS)
                midY -= ARROW_HEAD_LENGTH/2
            }
            let angle = Math.atan2(-dy, -dx);

            ctx.beginPath();
            ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX, midY);
            ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = EDGE_COLOR
            ctx.fill();
        }
    }

    function eraseSelfLoop(node, dir=DIR_UP) {  
        let x = node.x
        let y = node.y
        ctx.lineWidth = EDGE_WIDTH*2;  
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        if(dir==DIR_UP) {
            ctx.arc(x, y-SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_RIGHT) {
            ctx.arc(x+SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_DOWN) {
            ctx.arc(x, y+SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else {
            ctx.arc(x-SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }

        ctx.stroke(); 

        if(edge_type == TYPE_DIRECTED) {  //a lot of redundant code here!!
            let dx = dy = 0;
            let midX = node.x
            let midY = node.y
            ERASURE_BUFF = 4
            if(dir == DIR_UP) {
                dx = 10  //arrow should point right
                midX += (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
                midY -= 2*(SELF_LOOP_RADIUS)
            }
            else if(dir == DIR_RIGHT) {
                dy = 10  //arrow should point down
                midX += 2*(SELF_LOOP_RADIUS)
                midY += (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
            }
            else if(dir == DIR_DOWN) {
                dx = -10  //arrow should point to the left
                midX -= (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
                midY += 2*(SELF_LOOP_RADIUS)
            }
            else {
                dy = -10  //arrow should pont left
                midX -= 2*(SELF_LOOP_RADIUS)
                midY -= (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
            }
            let angle = Math.atan2(-dy, -dx);

            ctx.beginPath();
            ctx.lineWidth = 2*EDGE_WIDTH
            ctx.strokeStyle = "white"
            ctx.moveTo(midX + (ARROW_HEAD_LENGTH+ERASURE_BUFF) * Math.cos(angle - Math.PI / 6), midY + (ARROW_HEAD_LENGTH+ERASURE_BUFF) * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX, midY);
            ctx.lineTo(midX + (ARROW_HEAD_LENGTH+ERASURE_BUFF)  * Math.cos(angle + Math.PI / 6), midY + (ARROW_HEAD_LENGTH+ERASURE_BUFF) * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = "white"
            ctx.fill();
        }
        draw_node(node)
    }

  function getNodeSelfLoopDir(node) {
    for(let edge of node.edges) {
        if(edge.dir != DIR_NONE) {
            return edge.dir
        }
    }
    return DIR_NONE
  }

  document.addEventListener('contextmenu', function(event) { //clean up this code at some point!!
        event.preventDefault();
        if(isAModalDialogOpen()) {
            return
        }
        contextMenuClickPoint = new Point(event.clientX, event.clientY)
        subMenuItems = []
        clicked_on_node = get_clicked_on_node(event)
        clicked_on_iconizedGroup = get_clicked_on_iconizedGroup(event)
        if(clicked_on_node != undefined) {   //context menu when someone clicks on a node
            clearSelectionFromAllButNode(clicked_on_node)
            select_node(clicked_on_node)
            contextMenuApproximateSize = 140 //in pixels
            constantBox = node_id_to_constantBox_map.get(clicked_on_node.id)
            if(constantBox == undefined) {
                nodeContextMenuItems[ASSIGN_CONSTANT_INDEX] = 'Assign a Constant'
            }
            else {
                nodeContextMenuItems[ASSIGN_CONSTANT_INDEX] = 'Remove Constant'
            }
            let self_loop_dir = getNodeSelfLoopDir(clicked_on_node)
            if(self_loop_dir != DIR_NONE) {
                nodeContextMenuItems[SELF_LOOP_INDEX] = 'Move Self-Loop    \u25BE'
            }
            else {
                nodeContextMenuItems[SELF_LOOP_INDEX] = 'Create a Self-Loop    \u25BE'
            }
            
            for(let i=0; i < nodeContextMenuItems.length; i++) {
                subMenuItems.push({ text: nodeContextMenuItems[i], action: () => nodeContextMenuHandler(clicked_on_node, i)})
            }

            contextMenuList.innerHTML = '';
            selfLoopMenuItemElement = undefined
            selfLoopMenuList.replaceChildren();
            subSubMenuItemsCreated = false

            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                subMenuItemElement.style.color = "black"
                subMenuItemElement.addEventListener('click', item.action);    
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == SELF_LOOP_INDEX) {
                    selfLoopMenuItemElement = subMenuItemElement
                    subMenuItemElement.addEventListener('mouseover', function(event) {
                        //new stuff for subSubMenuItems
                        if(!subSubMenuItemsCreated) {
                            subSubMenuItems = []
                            subSubMenuItemsCreated = true
                            selfLoopMenuList.replaceChildren();
                            selfLoopMenuItemElement.appendChild(selfLoopMenuList)
                            for(let i=0; i < selfLoopMenuItems.length; i++) {
                                subSubMenuItems.push({ text: selfLoopMenuItems[i], action: () => selfLoopContextMenuHandler(clicked_on_node, i)})
                            }
                            for(let i=0; i<subSubMenuItems.length; i++) {
                                item = subSubMenuItems[i]
                                let subSubMenuItemElement = document.createElement('li');
                                subSubMenuItemElement.textContent = item.text;
                                if(self_loop_dir != i) {
                                    subSubMenuItemElement.style.color = "black"
                                }
                                else {
                                    subSubMenuItemElement.style.color = "grey"
                                }
                                subSubMenuItemElement.addEventListener('click', item.action); 
                                selfLoopMenuList.appendChild(subSubMenuItemElement);
                            }
                        }
                    });
                }
                else {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                    subMenuItemElement.addEventListener('mouseover', function(event) { 
                        subSubMenuItems = [] 
                        selfLoopMenuList.replaceChildren();
                        subSubMenuItemsCreated = false
                    })
                }
                ctr++
            });

            

        }
        //Check if context click is on a grouping rectangle
        else if(active_grouping_rectangle != undefined && 
            isPointWithinToleranceOfDistanceToGroupingRectangle(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop)) {
            contextMenuApproximateSize = 50 //needs to be more carefully specified
            for(let i=0; i < groupMenuItems.length; i++) {
                if(i == ICONIZE_INDEX) {
                    subMenuItems.push({ text: groupMenuItems[i], action: () => iconizeGroup()})
                }
                else {
                    subMenuItems.push({ text: groupMenuItems[i], action: () => killGroupingRectangle()})
                }
            }
            contextMenuList.innerHTML = '';
            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                subMenuItemElement.style.color = "black"
                subMenuItemElement.addEventListener('click', item.action);
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == ICONIZE_INDEX) {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                }
                ctr++
            });
            group_processing_active = true
        }
        else if(clicked_on_iconizedGroup != undefined) { //submenu when someone clicks on an icoGroup
            clearSelectionFromAllButIconizedGroup(clicked_on_iconizedGroup)
            select_iconizedGroup(clicked_on_iconizedGroup)
            contextMenuApproximateSize = 200 //in pixels
            for(let i=0; i < iconizedGroupContextMenuItems.length; i++) {
                subMenuItems.push({ text: iconizedGroupContextMenuItems[i], action: () => iconizedGroupContextMenuHandler(clicked_on_iconizedGroup, i)})
            }
            contextMenuList.innerHTML = '';
            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                subMenuItemElement.style.color = "black"
                subMenuItemElement.addEventListener('click', item.action);
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == ICO_GROUP_EDIT_INDEX) {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                }
                ctr++
            });
        }
        else {  //context menu when someone clicks on anything other than a node, iconizedGroup, 
                // or a grouping rectangle (perhaps we need one for clicking on an edge too....)
            contextMenuApproximateSize = 270 //in pixels
            for(let i=0; i < contextMenuItems.length; i++) {
                subMenuItems.push({ text: contextMenuPrefix[i] + contextMenuItems[i], action: () => contextMenuHandler(i)})
            }

            contextMenuList.innerHTML = '';

            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                if( (ctr == DISPLAY_ORDERINGS_INDEX && !nodes_are_ordered) ||
                    ctr == ORDER_LEFT_TO_RIGHT_INDEX && (!nodes_are_ordered || selected_nodes.size == 0) ||
                    (ctr == SHRINK_SELECTED_INDEX || ctr == EXPAND_SELECTED_INDEX) && selected_nodes.size + selected_iconizedGroups.size < 2) {
                    subMenuItemElement.style.color = "grey"
                    subMenuItemElement.style.pointerEvents = "none"
                }
                else {
                    subMenuItemElement.style.color = "black"
                    subMenuItemElement.addEventListener('click', item.action);
                }
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == ORDER_LEFT_TO_RIGHT_INDEX || ctr == EXPAND_SELECTED_INDEX) {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                }
                ctr++
            });
        }

       
        let CONTEXT_MENU_PUSHUP_BUFF = 0
        if(event.clientY + contextMenuApproximateSize > window.innerHeight) {
            CONTEXT_MENU_PUSHUP_BUFF = event.clientY + contextMenuApproximateSize - window.innerHeight
        }
        contextMenuDiv.style.left = `${event.clientX}px`;
        contextMenuDiv.style.top = `${event.clientY - CONTEXT_MENU_PUSHUP_BUFF}px`;
        contextMenuDiv.style.display = 'block';
        contextMenuDiv.style.fontFamily = "Arial, Helvetica, sans-serif";
        contextMenuDiv.style.fontWeight = "Bold";
        contextMenuDiv.style.fontSize = "10pt";
  }, false);

  function iconizeGroup() {
    if(active_grouping_rectangle.x < DIVIDING_LINE_LOC &&
        active_grouping_rectangle.x + active_grouping_rectangle.width > DIVIDING_LINE_LOC) {
            alert("You can only iconize a group that is completely on the \u2203 side or completely on the \u2200 side.")
            group_processing_active = false
            return
    }
    else {
        //make sure: (i) all edges associated with all nodes are selected 
        for(let node of selected_nodes) {
            for(let edge of node.edges) {
                if(selected_nodes.has(edge.node1) && selected_nodes.has(edge.node2) && !selected_edges.has(edge)) {
                    alert("You must be sure to select all edges associated with the nodes in a group you wish to iconize.")
                    group_processing_active = false
                    return
                }
            }
        }
        //make sure (ii) no edges associated with nodes not in the group are selected
        for(let edge of selected_edges) {
            if(!selected_nodes.has(edge.node1) || !selected_nodes.has(edge.node2)) {
                alert("You cannot iconize a group that has an edge to a node not in the selected group.")
                group_processing_active = false
                return
            }
        }
        //make sure (iii) there are no edges between nodes in the group and nodes not in the group
        for(let node of selected_nodes) {
            for(let edge of node.edges) {
                if(!selected_nodes.has(edge.node1) || !selected_nodes.has(edge.node2)) {
                    alert("You can only iconize a group that is disconnected from all other nodes.")
                    group_processing_active = false
                    return
                }
            }
        }
        //make sure (iv) there are no ultraEdges assocaited with all sected nodes or iconizedGroups are also selected
        let msg = "You can only iconize a group that that is disconnected from all other objects."
        for(let node of selected_nodes) {
            for(let ultraEdge of node.ultraEdges) {
                if(!selected_ultraEdges.has(ultraEdge)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            for(let ultraEdge of icoGroup.ultraEdges) {
                if(!selected_ultraEdges.has(ultraEdge)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
        }


        //make sure (v) if an ultraEdge is selected the objects on both sides are in the group
        msg = "You cannot iconize a group that has an ultraEdge to an objectgg not in the selected group."
        for(let ultraEdge of selected_ultraEdges) {
            if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                if(!selected_iconizedGroups.has(ultraEdge.obj1)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
            else if(!selected_nodes.has(ultraEdge.obj1)) {
                alert(msg)
                group_processing_active = false
                return
            }
            if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                if(!selected_iconizedGroups.has(ultraEdge.obj2)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
            else if(!selected_nodes.has(ultraEdge.obj2)) {
                alert(msg)
                group_processing_active = false
                return
            }
        }

        requestGroupIconization(undefined)  //not starting with an existing IconizedGoup
    }

  }

  function iconizationDialogKeyHandler(event) {
    if (event.key === 'Escape' || event.keyCode === 27) {
        iconizationDailogCancelHandler()
    }
    else if(event.key === 'Enter' || event.keyCode === 13) {
        captureIconizationDialogDetails()
    }
  }

  iconizationDialogHasEventListeners = false  
  activeIcoGroup = undefined //a bit clugey, but....
  function requestGroupIconization(icoGroup) {
    const dialog = document.getElementById("iconization_dialog") 
    
    let submitButton = document.getElementById("ico_submit_button")
    activeIcoGroup = icoGroup
    if(!iconizationDialogHasEventListeners) {
        submitButton.addEventListener('click', (event) => {
            captureIconizationDialogDetails()
        });  
        dialog.addEventListener('keydown', iconizationDialogKeyHandler(event))
        iconizationDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
    if(icoGroup != undefined) {
        document.getElementById("n_gon").value = icoGroup.num_sides
        document.getElementById("radius").value = icoGroup.radius
        const radios = document.getElementsByName("color");
        for (let i = 0; i < radios.length; i++) {
            if (radios[i].value == icoGroup.fill_color) {
                radios[i].checked = true
                break;
            }
        }
        document.getElementById("label").value = icoGroup.label
    }
    else {
        document.getElementById("label").value = ""
    }
    redrawSamplePolygon()
  }

  function redrawSamplePolygon() {   
    eraseCanvas("iconization-canvas", 135 - 50, 50 - 50, 100, 100)
    let sides = document.getElementById("n_gon").value
    let circumradius = Number(document.getElementById("radius").value)
    let fill_color = "cyan"  //the default
    const radios = document.getElementsByName("color");
    for (let i = 0; i < radios.length; i++) {
        if (radios[i].checked) {
            fill_color = radios[i].value;
            break;
        }
    }
    let label = document.getElementById("label").value
    drawPolygon("iconization-canvas", 135, 50, circumradius, sides, fill_color, label)
  }

  function areThereNodesOnBothSides() {  //also includes IconizedGroups
    let nodesOnLeft = nodesOnRight = false
    for(let node of nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            nodesOnLeft = true
            if(nodesOnLeft && nodesOnRight) {
                return true
            }
        }
        else {
            nodesOnRight = true
            if(nodesOnLeft && nodesOnRight) {
                return true
            }
        }
    }
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.x < DIVIDING_LINE_LOC) {
            nodesOnLeft = true
            if(nodesOnLeft && nodesOnRight) {
                return true
            }
        }
        else {
            nodesOnRight = true
            if(nodesOnLeft && nodesOnRight) {
                return true
            }
        }
    }
    return false
  }

  function isPointWithinToleranceOfDistanceToGroupingRectangle(x, y) {  //this is a tiny bit crude 
    tolerance = 10
    if((x >= active_grouping_rectangle.x && x <= active_grouping_rectangle.x + active_grouping_rectangle.width) && 
            ((y >= active_grouping_rectangle.y - tolerance && y <= active_grouping_rectangle.y + tolerance) ||
            (y >= active_grouping_rectangle.y + active_grouping_rectangle.height - tolerance && y <= active_grouping_rectangle.y + active_grouping_rectangle.height + tolerance))) {
                return true
    }
    if((y >= active_grouping_rectangle.y && y <= active_grouping_rectangle.y + active_grouping_rectangle.height) &&
            ((x >= active_grouping_rectangle.x - tolerance && x <= active_grouping_rectangle.x + tolerance) ||
            (x >= active_grouping_rectangle.x + active_grouping_rectangle.width - tolerance && x <= active_grouping_rectangle.x + active_grouping_rectangle.width + tolerance))) {
                return true
    }
    
    return false
     
  }

  function testSafeGroupingRectangleDragPoint(dx, dy) {
    //If too high or too low, return false regardless of the case
    if((active_grouping_rectangle.y + dy + GROUPING_BOX_BUFFER <= TOP_BUFFER) || 
            (active_grouping_rectangle.y + active_grouping_rectangle.height + dy - GROUPING_BOX_BUFFER >= canvas.height - NODE_DRAW_RADIUS)) {
        return false
    }
    
    //case grouping box just on the left
    if(active_grouping_rectangle.x + active_grouping_rectangle.width - GROUPING_BOX_BUFFER < DIVIDING_LINE_LOC) {
        return active_grouping_rectangle.x + dx + GROUPING_BOX_BUFFER > DIVIDING_LINE_BUFFER && 
                    active_grouping_rectangle.x + active_grouping_rectangle.width + dx - GROUPING_BOX_BUFFER < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER
    }
    //case grouping box just on the right
    if(active_grouping_rectangle.x + GROUPING_BOX_BUFFER > DIVIDING_LINE_LOC) {
        return active_grouping_rectangle.x + dx + GROUPING_BOX_BUFFER > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
                    active_grouping_rectangle.x + active_grouping_rectangle.width + dx - GROUPING_BOX_BUFFER < canvas.width - NODE_DRAW_RADIUS
    }
    //case grouping box spans both sides
    return active_grouping_rectangle.x + dx + GROUPING_BOX_BUFFER > DIVIDING_LINE_BUFFER && 
        exists_side_grouping_control_point + dx < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER &&
        forall_side_grouping_control_point + dx > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
        active_grouping_rectangle.x + active_grouping_rectangle.width + dx - GROUPING_BOX_BUFFER < canvas.width - NODE_DRAW_RADIUS      
  }

  function handleGroupingRectangleDrag() {
    let dx = endX - startX
    let dy = endY - startY
    if(!testSafeGroupingRectangleDragPoint(dx, dy)) {
        return
    }
    startX = endX
    startY = endY
    for(let node of selected_nodes) {
        node.x += dx
        node.y += dy
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.left = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
        orderInputBox.style.top = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        constantBox = node_id_to_constantBox_map.get(node.id)
        if(constantBox != undefined) {
            constantBox.style.left = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
            constantBox.style.top = "" + (node.y + CONSTANT_BOX_OFFSET_Y) + "px"
        }
    }
    for(let icoGroup of selected_iconizedGroups) {
        icoGroup.x += dx
        icoGroup.y += dy
    }
    redrawAll()
    drawGroupingRectangle(UNSELECT_COLOR)
    active_grouping_rectangle.x += dx
    active_grouping_rectangle.y += dy
    exists_side_grouping_control_point += dx
    forall_side_grouping_control_point += dx
    drawGroupingRectangle("grey")
  }

  document.addEventListener('mousemove', function(event) {
    BUFF = 100 //Buffer for redrawing around node mins and maxes
    endX = event.clientX - canvas.offsetLeft;
    endY = event.clientY - canvas.offsetTop;
    if(active_grouping_rectangle != undefined) {
        if(isPointWithinToleranceOfDistanceToGroupingRectangle(endX, endY)) {
            document.body.style.cursor = "move"
        }
        else {
            document.body.style.cursor = "default"
        }
    }
    else {
        document.body.style.cursor = "default"
    }
    if (!isDragging) return;

    if(active_grouping_rectangle != undefined) {
        handleGroupingRectangleDrag(event)
    }
    else if(Math.abs(endX-startX) > 5 || Math.abs(endY-startY) > 5 ) {
        wasDragging = true
        if(dragging_node == undefined && dragging_iconizedGroup == undefined) {
            drawDragRectangle(event);
        }
        else {
            if(dragging_node != undefined) {
                if(  //don't allow dragging of a node too close to dividing line, too close to left edge,  or above top buffer
                    endY > TOP_BUFFER && endX > DIVIDING_LINE_BUFFER && endX < canvas.width - NODE_DRAW_RADIUS && endY < canvas.height - NODE_DRAW_RADIUS &&
                    ((startX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER && 
                            endX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) ||
                    (startX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
                            endX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER))) {
                    if(!selected_nodes.has(dragging_node)) {
                        select_node(dragging_node)
                    }
                    if(selected_nodes.size + selected_iconizedGroups.size + selected_edges.size 
                        + selected_ultraEdges.size > 1) {
                        clearSelectionFromAllButNode(dragging_node)
                    }
                    dragging_node.x = endX
                    dragging_node.y = endY
                    orderInputBox = node_id_to_inputBox_map.get(dragging_node.id)
                    orderInputBox.style.left = "" + (endX + ORDERING_BOX_OFFSET_X) + "px"
                    orderInputBox.style.top = "" + (endY + ORDERING_BOX_OFFSET_Y) + "px"
                    constantBox = node_id_to_constantBox_map.get(dragging_node.id)
                    if(constantBox != undefined) {
                        constantBox.style.left = "" + (endX + CONSTANT_BOX_OFFSET_X) + "px"
                        constantBox.style.top = "" + (endY + CONSTANT_BOX_OFFSET_Y) + "px"
                    }
                    minX = minY = INFINITE
                    maxX = maxY = INFINITE
                    for(let node of nodes) {
                        if(node.x - BUFF < minX) {
                            minX = node.x - BUFF
                        }
                        if(node.x + BUFF > maxX) {
                            maxX = node.x + BUFF
                        }
                        if(node.y - BUFF < minY) {
                            minY = node.y - BUFF
                        }
                        if(node.y + BUFF > maxY) {
                            maxY = node.x + BUFF
                        }
                    }
                    for(let icoGroup of iconizedGroups) {
                        if(icoGroup.x - BUFF < minX) {
                            minX = icoGroup.x - BUFF
                        }
                        if(icoGroup.x + BUFF > maxX) {
                            maxX = icoGroup.x + BUFF
                        }
                        if(icoGroup.y - BUFF < minY) {
                            minY = icoGroup.y - BUFF
                        }
                        if(icoGroup.y + BUFF > maxY) {
                            maxY = icoGroup.x + BUFF
                        }
                    }
                    redrawRectangle(minX, minY, maxX-minX, maxY-minY)
                }
            }
            else { //case we are dragging an IconizedGroup
                if(  //don't allow dragging of a node too close to dividing line, too close to left edge,  or above top buffer
                    endY > TOP_BUFFER && endX > DIVIDING_LINE_BUFFER && endX < canvas.width - dragging_iconizedGroup.radius && endY < canvas.height - dragging_iconizedGroup.radius &&
                    ((startX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER && 
                            endX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) ||
                    (startX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
                            endX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER))) {
                    if(!selected_iconizedGroups.has(dragging_iconizedGroup)) {
                        select_iconizedGroup(dragging_iconizedGroup)
                    }
                    if(selected_nodes.size + selected_iconizedGroups.size + selected_edges.size 
                        + selected_ultraEdges.size > 1) {
                        clearSelectionFromAllButIconizedGroup(dragging_iconizedGroup)
                    }
                    dragging_iconizedGroup.x = endX
                    dragging_iconizedGroup.y = endY
                    minX = minY = INFINITE
                    maxX = maxY = INFINITE
                    for(let node of nodes) {
                        if(node.x - BUFF < minX) {
                            minX = node.x - BUFF
                        }
                        if(node.x + BUFF > maxX) {
                            maxX = node.x + BUFF
                        }
                        if(node.y - BUFF < minY) {
                            minY = node.y - BUFF
                        }
                        if(node.y + BUFF > maxY) {
                            maxY = node.x + BUFF
                        }
                    }
                    for(let icoGroup of iconizedGroups) {
                        if(icoGroup.x - BUFF < minX) {
                            minX = icoGroup.x - BUFF
                        }
                        if(icoGroup.x + BUFF > maxX) {
                            maxX = icoGroup.x + BUFF
                        }
                        if(icoGroup.y - BUFF < minY) {
                            minY = icoGroup.y - BUFF
                        }
                        if(icoGroup.y + BUFF > maxY) {
                            maxY = icoGroup.x + BUFF
                        }
                    }
                    redrawRectangle(minX, minY, maxX-minX, maxY-minY)
                }
            }
        }
    }
      
  }, true);

  document.addEventListener('mouseup', function(event) {
    let grid_dialog = document.getElementById("grid_dialog")
    let iconization_dialog = document.getElementById("iconization_dialog")
    if(grid_dialog.open || iconization_dialog.open) { 
        isDragging = false 
        return
    }
    isDragging = false;
    if(wasDragging) {
        if(active_grouping_rectangle == undefined) {
            smartClearRect(event)
            if(dragging_node == undefined && dragging_iconizedGroup == undefined) {
                selectionRect = new Rectangle(startX, startY, endX - startX, endY - startY)
                if(!event.shiftKey && !event.metaKey) { 
                    clearSelection()
                }
                for(const node of nodes) {
                    if(nodeInRect(node, selectionRect)) {
                        select_node(node)
                    }
                }
                for(const icoGroup of iconizedGroups) {
                    if(iconizedGroupInRect(icoGroup, selectionRect)) {
                        select_iconizedGroup(icoGroup)
                    }
                }
                for(const edge of edges) {
                    if(nodeInRect(edge.node1, selectionRect) && nodeInRect(edge.node2, selectionRect)) {
                        select_edge(edge)
                    }
                }
                for(const ultraEdge of ultraEdges) {
                    let obj1_in = obj2_in = false
                    if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                        obj1_in = iconizedGroupInRect(ultraEdge.obj1 , selectionRect)
                    }
                    else {
                        obj1_in = nodeInRect(ultraEdge.obj1 , selectionRect)
                    }
                    if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                        obj2_in = iconizedGroupInRect(ultraEdge.obj2 , selectionRect)
                    }
                    else {
                        obj2_in = nodeInRect(ultraEdge.obj2 , selectionRect)
                    }
                    if(obj1_in && obj2_in) {
                        select_ultraEdge(ultraEdge)
                    }
                }
            }
            else {
                draw_all_nodes()
                for(let node of selected_nodes) {
                    select_node(node)
                }
                for(let icoGroup of selected_iconizedGroups) {
                    select_iconizedGroup(icoGroup)
                }
                for(let edge of selected_edges) {
                    select_edge(edge)
                }
                for(let ultraEdge of selected_ultraEdges) {
                    select_ultraEdge(ultraEdge)
                }
            }
        }
    }

  }, true);

  function isAModalDialogOpen() {
    let new_game_dialog = document.getElementById("new_game_dialog")
    let cycle_dialog = document.getElementById("cycle_dialog")
    let grid_dialog = document.getElementById("grid_dialog")
    let iconization_dialog = document.getElementById("iconization_dialog")
    return (grid_dialog.open || cycle_dialog.open || iconization_dialog.open || new_game_dialog.open) 
  }

  document.addEventListener('click', function(event) {  
    if(isAModalDialogOpen()) {
        return
    }
    
    if (contextMenu.style.display != '') { // && !contextMenuDiv.contains(event.target)) {
      contextMenu.style.display = '';
      return
    }
    if(killClickEvent || !process_click(event)) {
        return
    }
    click_point = new Point(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop)
    icoGroup = get_clicked_on_iconizedGroup(event)    
    if(icoGroup != undefined) {
        if(event.shiftKey || event.metaKey) {
            toggle_select_iconizedGroup(icoGroup)  
        }
        else {
            clearSelectionFromAllButIconizedGroup(icoGroup)  //check that this works properply with icoGroups!
            toggle_select_iconizedGroup(icoGroup)   
        }
    }
    else {
        node = click_to_node(event)
        if(!nodes.has(node)) {
            //did user click near an existing edge? If so, select it 
            let distance_to_closest_edge = INFINITE
            let closest_edge = undefined
            for(let edge of edges) {
                let d = getPointToEdgeDistance(click_point, edge)
                if(d < distance_to_closest_edge) {
                    closest_edge = edge
                    distance_to_closest_edge = d
                }
            }
            if(distance_to_closest_edge <= EDGE_CLICK_TOLERANCE) {
                if(event.shiftKey || event.metaKey) {
                    toggle_select_edge(closest_edge)
                }
                else {
                    clearSelectionFromAllButEdge(closest_edge)
                    toggle_select_edge(closest_edge)
                }
                return
            }
            //did user click near an existing UltraEdge? If so, select it 
            let distance_to_closest_ultraEdge = INFINITE
            let closest_ultraEdge = undefined
            for(let ultraEdge of ultraEdges) {
                let d = getPointToUltraEdgeDistance(click_point, ultraEdge)
                if(d < distance_to_closest_ultraEdge) {
                    closest_ultraEdge = ultraEdge
                    distance_to_closest_ultraEdge = d
                }
            }
            if(distance_to_closest_ultraEdge <= EDGE_CLICK_TOLERANCE) {
                if(event.shiftKey || event.metaKey) {
                    toggle_select_ultraEdge(closest_ultraEdge)
                }
                else {
                    clearSelectionFromAllButUltraEdge(closest_ultraEdge)
                    toggle_select_ultraEdge(closest_ultraEdge)
                }
            }
            else if(selected_nodes.size > 0 || selected_edges.size > 0 || 
                selected_iconizedGroups.size > 0 || selected_ultraEdges.size > 0) {
                clearSelection()
            }
            else {
                create_node(node)
            }
        }
        else {
            if(event.shiftKey || event.metaKey) {
                toggle_select_node(node)
            }
            else {
                clearSelectionFromAllButNode(node)
                toggle_select_node(node)
            }
            
        }
    }
  });

  function deleteSelectedNodes() {
    selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
        delete_node(selected_nodes_list[i])
    }
  }

  function deleteSelectedEdges() {
    selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
        delete_edge(selected_edge_list[i])
    }
  }

  function deleteSelectedUltraEdges() {
    selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
        delete_ultraEdge(selected_ultraEdge_list[i])
    }
  }

  function deleteSelectedIconizedGroups() {
    selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
        for(let uEdge of selected_iconizedGroup_list[i].ultraEdges) {
            delete_ultraEdge(uEdge)
        }
        delete_iconizedGroup(selected_iconizedGroup_list[i])
    }
  }

  function getAllPairsOfSelectedElements() {  //only return pairs on the same side
    pairs = []
    selected_nodes_list = Array.from(selected_nodes)
    for (let i = 0; i < selected_nodes_list.length - 1; i++) {
        for (let j = i + 1; j < selected_nodes_list.length; j++) {
            if((selected_nodes_list[i].x - DIVIDING_LINE_LOC)*(selected_nodes_list[j].x - DIVIDING_LINE_LOC) > 0) {
                pairs.push([selected_nodes_list[i], selected_nodes_list[j]]);
            }
        }
    }
    selected_icoGroup_list = Array.from(selected_iconizedGroups)
    for (let i = 0; i < selected_icoGroup_list.length - 1; i++) {
        for (let j = i + 1; j < selected_icoGroup_list.length; j++) {
            if((selected_icoGroup_list[i].x - DIVIDING_LINE_LOC)*(selected_icoGroup_list[j].x - DIVIDING_LINE_LOC) > 0) {
                pairs.push([selected_icoGroup_list[i], selected_icoGroup_list[j]]);
            }
        }
    }
    for (let i = 0; i < selected_nodes_list.length; i++) {
        for (let j = 0; j < selected_icoGroup_list.length; j++) {
            if((selected_nodes_list[i].x - DIVIDING_LINE_LOC)*(selected_icoGroup_list[j].x - DIVIDING_LINE_LOC) > 0) {
                pairs.push([selected_nodes_list[i], selected_icoGroup_list[j]]);
            }
        }
    }

    return pairs
  }

  function equalEdges(edge1, edge2) { 
    if(edge_type == TYPE_UNDIRECTED) {
        return ((edge1.node1 == edge2.node1 && edge1.node2 == edge2.node2) ||
        (edge1.node1 == edge2.node2 && edge1.node2 == edge2.node1))
    }
    else {
        return edge1.node1 == edge2.node1 && edge1.node2 == edge2.node2
    }
  }

  function equalUltraEdges(uEdge1, uEdge2) { 
    if(edge_type == TYPE_UNDIRECTED) {
        return ((uEdge1.obj1 == uEdge2.obj1 && uEdge1.obj2 == uEdge2.obj2) ||
        (uEdge1.obj1 == uEdge2.obj2 && uEdge1.obj2 == uEdge2.obj1))
    }
    else {
        return uEdge1.obj1 == uEdge2.obj1 && uEdge1.obj2 == uEdge2.obj2
    }
  }

  function edgeInEdges(edge) {
    for(const e of edges) {
        if(equalEdges(e, edge)) {
            return true
        }
    }
    return false
  }

  function ultraEdgeInUltraEdges(ultraEdge) {
    for(const u of ultraEdges) {
        if(equalUltraEdges(u, ultraEdge)) {
            return true
        }
    }
    return false
  }

  function getYCoordOfLowestNodeOrIconizedGroup(whichSide) {
    lowestY = 0
    for(let node of nodes) {
        if(whichSide == BOTH_SIDES || (whichSide == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) || 
            (whichSide == FORALL_SIDE && node.x > DIVIDING_LINE_LOC)) {
            if(node.y > lowestY) {
                lowestY = node.y
            }
        }
    }
    for(let icoGroup of iconizedGroups) {
        if(whichSide == BOTH_SIDES || (whichSide == EXISTS_SIDE && icoGroup.x < DIVIDING_LINE_LOC) || 
            (whichSide == FORALL_SIDE && icoGroup.x > DIVIDING_LINE_LOC)) {
            if(icoGroup.y > lowestY) {
                lowestY = icoGroup.y
            }
        }
    }

    return lowestY
  }

  function getYCoordOfHighestNodeOrIconizedGroup(whichSide) {
    highestY = 0
    for(let node of nodes) {
        if(whichSide == BOTH_SIDES || (whichSide == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) || 
            (whichSide == FORALL_SIDE && node.x > DIVIDING_LINE_LOC)) {
            if(node.y < highestY) {
                highestY = node.y
            }
        }
    }
    for(let icoGroup of iconizedGroups) {
        if(whichSide == BOTH_SIDES || (whichSide == EXISTS_SIDE && icoGroup.x < DIVIDING_LINE_LOC) || 
            (whichSide == FORALL_SIDE && icoGroup.x > DIVIDING_LINE_LOC)) {
            if(icoGroup.y < highestY) {
                highestY = icoGroup.y
            }
        }
    }

    return highestY
  }

  //pass undefined to this function to learn this fact for the entire graph (onn both sides)
  function areThereNestedEdgesOrUltraEdges(icoGroup) {
    if(icoGroup == undefined) {
        if(edges.size > 0 || ultraEdges.size > 0) {
            return true
        }
        else {
            for(let i of iconizedGroups) {
                if(areThereNestedEdgesOrUltraEdges(i)) {
                    return true
                }
            }
            return false
        }
    }
    else {
        if(icoGroup.inner_edges.size > 0 || icoGroup.inner_ultraEdges.size > 0) {
            return true
        }
        else {
            for(let i of icoGroup.inner_iconizedGroups) {
                if(areThereNestedEdgesOrUltraEdges(i)) {
                    return true
                }
            }
            return false
        }
    }
    
  }

  document.addEventListener('keydown', function(event) {   //was a keyup listener
    if(isAModalDialogOpen()) { //ignore if modal dialog open
        return
    }

    if(event.key == "Delete" || event.key == "Backspace") {
        deleteSelectedEdges() 
        deleteSelectedUltraEdges()
        deleteSelectedNodes()
        deleteSelectedIconizedGroups()
    }
    else if(event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27) {
        contextMenu.style.display = "none"
    }
    else if(event.key == "e" || event.key == "E") {
        if(edge_type == TYPE_DIRECTED) {
            //if(edges.size > 0 || ultraEdges.size > 0) {
            if(areThereNestedEdgesOrUltraEdges(undefined)) {
                beep()
                return
            }
            else {
                edge_type = TYPE_UNDIRECTED
            }
        }
        if(selected_nodes.size + selected_iconizedGroups.size >= 2) {
            pairs = getAllPairsOfSelectedElements()  //will only return pairs on the same side of the dividing line
            clearSelection()
            for(let i=0; i< pairs.length; i++) {
                if(!pairs[i][0].hasOwnProperty("num_sides") &&  !pairs[i][1].hasOwnProperty("num_sides")) {
                    edge = new Edge(pairs[i][0], pairs[i][1])
                    if(!edgeInEdges(edge)) {
                        create_edge(edge)
                    }
                }
                else {
                    ultraEdge = new UltraEdge(pairs[i][0], pairs[i][1])
                    if(!ultraEdgeInUltraEdges(ultraEdge)) {
                        create_ultraEdge(ultraEdge)
                    }
                }
            }
        }
    }
    else if(event.key == "d") {
        if(edge_type == TYPE_UNDIRECTED) {
            if(areThereNestedEdgesOrUltraEdges(undefined)) {
                beep()
                return
            }
            else {
                edge_type = TYPE_DIRECTED
            }
        }
        if(selected_nodes.size + selected_iconizedGroups.size >= 2) {
            pairs = getAllPairsOfSelectedElements()  //will only return pairs on the same side of the dividing line
            clearSelection()
            for(let i=0; i< pairs.length; i++) {
                if(!pairs[i][0].hasOwnProperty("num_sides") &&  !pairs[i][1].hasOwnProperty("num_sides")) {
                    edge = new Edge(pairs[i][0], pairs[i][1])
                    if(!edgeInEdges(edge)) {
                        create_edge(edge)
                    }
                }
                else {
                    ultraEdge = new UltraEdge(pairs[i][0], pairs[i][1])
                    if(!ultraEdgeInUltraEdges(ultraEdge)) {
                        create_ultraEdge(ultraEdge)
                    }
                }
            }
        }
    }
    else if(event.key == "r") {  //reverse the direction of any selected directed edges
        if(edge_type == TYPE_UNDIRECTED || (selected_edges.size == 0 && selected_ultraEdges == 0)) {
            //beep()
            return
        }
        for(let edge of selected_edges) {
            erase_edge(edge)
            temp_node = edge.node1
            edge.node1 = edge.node2
            edge.node2 = temp_node
            draw_edge(edge) 
            select_edge(edge)   
        }
        for(let ultraEdge of selected_ultraEdges) {
            erase_ultraEdge(ultraEdge)
            temp_obj = ultraEdge.obj1
            ultraEdge.obj1 = ultraEdge.obj2
            ultraEdge.obj2 = temp_obj
            draw_ultraEdge(ultraEdge) 
            select_ultraEdge(ultraEdge)   
        }
    }
    else if(event.key == "R") {  //add an additional edge in the reverse direction (needs to be completely implemented)
                                //also need to be able to directly add a second directed edge by clicking on respective 
                                // ordered vertices
        if(edge_type == TYPE_UNDIRECTED || (selected_edges.size == 0 && selected_ultraEdges == 0)) {
            //beep()
            return
        }
        for(let edge of selected_edges) {
            reverse_edge = new Edge(edge.node2, edge.node1)
            edge.node1.edges.add(reverse_edge)
            edge.node2.edges.add(reverse_edge)
            edges.add(reverse_edge)
            draw_edge(reverse_edge)    
        }
        for(let ultraEdge of selected_ultraEdges) {
            reverse_ultraEdge = new UltraEdge(ultraEdge.obj2, ultraEdge.obj1)
            ultraEdge.obj1.edges.add(reverse_ultraEdge)
            ultraEdge.obj2.edges.add(reverse_ultraEdge)
            ultraEdges.add(reverse_ultraEdge)
            draw_ultraEdge(reverse_ultraEdge)    
        }
        clearSelection()
    }
    else if(event.key == 'g') {
        if(!event.metaKey) {
            handleGrouping()
        }
        else {
            event.preventDefault()
            if(areThereNodesOnBothSides()) {
                startGame()
            }
            else {
                beep()
            }
        }
    }
    else if(event.key == 'u') {  //for undirected ultraEdge
        if(selected_nodes.size + selected_iconizedGroups.size >= 2) {
            pairs = getAllPairsOfSelectedElements()  //will only return pairs on the same side of the dividing line
            let someViableUltraPairs = false
            for(let i=0; i< pairs.length; i++) {
                if(!pairs[i][0].hasOwnProperty("num_sides") && !pairs[i][1].hasOwnProperty("num_sides")) {
                    //ignore
                }
                else {
                    if(!someViableUltraPairs) {
                        clearSelection()
                        someViableUltraPairs = true
                    }
                    ultraEdge = new UltraEdge(pairs[i][0], pairs[i][1])
                    if(!ultraEdgeInUltraEdges(ultraEdge)) {
                        create_ultraEdge(ultraEdge)
                    }
                }
            }
            if(!someViableUltraPairs) {
                beep()
            }
        }
    }

  });

  function handleGrouping() {
    //handle grouping/ungrouping
    if(selected_nodes.size + selected_iconizedGroups.size == 0) {
        beep()
        return
    }
    else if(selected_nodes.size + selected_iconizedGroups.size == 1) {
        alert("Cannot group a single node or iconized group!")
        return
    }
    else if(active_grouping_rectangle != undefined) {
        killGroupingRectangle()
    }
    else {
        let minX = canvas.width
        let maxX = 0
        let minY = canvas.height
        let maxY = 0
        let right_mostX_on_left_side = 0
        let left_mostX_on_right_side = canvas.width
        for(let node of selected_nodes) {
            if(node.x - NODE_DRAW_RADIUS < minX) {
                minX = node.x - NODE_DRAW_RADIUS
            }
            if(node.x + NODE_DRAW_RADIUS > maxX) {
                maxX = node.x + NODE_DRAW_RADIUS
            }
            if(node.y - NODE_DRAW_RADIUS < minY) {
                minY = node.y - NODE_DRAW_RADIUS
            }
            if(node.y + NODE_DRAW_RADIUS > maxY) {
                maxY = node.y + NODE_DRAW_RADIUS
            }
            if(node.x < DIVIDING_LINE_LOC && node.x + NODE_DRAW_RADIUS > right_mostX_on_left_side) {
                right_mostX_on_left_side = node.x + NODE_DRAW_RADIUS
            }
            else if(node.x > DIVIDING_LINE_LOC && node.x - NODE_DRAW_RADIUS < left_mostX_on_right_side) {
                left_mostX_on_right_side = node.x - NODE_DRAW_RADIUS
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            if(icoGroup.x - icoGroup.radius < minX) {
                minX = icoGroup.x - icoGroup.radius
            }
            if(icoGroup.x + icoGroup.radius > maxX) {
                maxX = icoGroup.x + icoGroup.radius
            }
            if(icoGroup.y - icoGroup.radius < minY) {
                minY = icoGroup.y - icoGroup.radius
            }
            if(icoGroup.y + icoGroup.radius > maxY) {
                maxY = icoGroup.y + icoGroup.radius
            }
            if(icoGroup.x < DIVIDING_LINE_LOC && icoGroup.x + icoGroup.radius > right_mostX_on_left_side) {
                right_mostX_on_left_side = icoGroup.x + icoGroup.radius
            }
            else if(icoGroup.x > DIVIDING_LINE_LOC && icoGroup.x - icoGroup.radius < left_mostX_on_right_side) {
                left_mostX_on_right_side = icoGroup.x - icoGroup.radius
            }
        }
        active_grouping_rectangle = new Rectangle(minX - GROUPING_BOX_BUFFER, minY - GROUPING_BOX_BUFFER, 
                maxX - minX + 2*GROUPING_BOX_BUFFER, maxY - minY + 2*GROUPING_BOX_BUFFER)
        if(maxX > DIVIDING_LINE_LOC && minX < DIVIDING_LINE_LOC) {
            exists_side_grouping_control_point = right_mostX_on_left_side
            forall_side_grouping_control_point = left_mostX_on_right_side
        }
        else {
            exists_side_grouping_control_point = undefined
            forall_side_grouping_control_point = undefined
        }
        console.log("exists_side_grouping_control_point = " + exists_side_grouping_control_point)
        console.log("forall_side_grouping_control_point = " + forall_side_grouping_control_point)
        drawGroupingRectangle("grey")
    }
  }



  function killGroupingRectangle() {
    drawGroupingRectangle(UNSELECT_COLOR)
    active_grouping_rectangle = undefined
    redrawAll()
  }

  function drawGroupingRectangleHandle(x, y, color) {
    ctx.beginPath()
    ctx.strokeStyle = color; // Set stroke color
    line_width = 1
    if(color == UNSELECT_COLOR) {
        line_width += 2
    }
    ctx.lineWidth = line_width; // Set line width 
    ctx.fillStyle = "white"; 
    ctx.fillRect(x-5, y-5, 10, 10); 
    ctx.strokeRect(x-5, y-5, 10, 10); 
    ctx.stroke()
    ctx.closePath()
  }

  function drawGroupingRectangle(color) {
    ctx.beginPath()
    ctx.strokeStyle = color; // Set stroke color
    line_width = 1
    if(color == UNSELECT_COLOR) {
        line_width += 2
    }
    ctx.lineWidth = line_width; // Set line width 
    ctx.setLineDash([10, 5]); // 5px line, 10px gap
    ctx.strokeRect(active_grouping_rectangle.x, active_grouping_rectangle.y, active_grouping_rectangle.width, active_grouping_rectangle.height); 
    ctx.stroke()
    ctx.closePath()
    ctx.setLineDash([])

    drawGroupingRectangleHandle(active_grouping_rectangle.x, active_grouping_rectangle.y, color)
    drawGroupingRectangleHandle(active_grouping_rectangle.x + active_grouping_rectangle.width, active_grouping_rectangle.y, color)
    drawGroupingRectangleHandle(active_grouping_rectangle.x, active_grouping_rectangle.y + active_grouping_rectangle.height, color)
    drawGroupingRectangleHandle(active_grouping_rectangle.x + active_grouping_rectangle.width, active_grouping_rectangle.y + active_grouping_rectangle.height, color)
  }



  function createButton(text, x, y) {
    const button = document.createElement('button');
    button.textContent = text;
    button.style.fontSize = "16px"
    button.style.position = 'absolute';
    button.style.left = `${x}px`;
    button.style.top = `${y}px`;
    document.body.appendChild(button);
    return button;
    }

  //exists button stuff
  existsButtonPressed = false
  const existsButton = document.createElement('img');
  existsButton.src = 'exists_button.png';
  existsButton.draggable = false
  existsButton.width = 100
  existsButton.height = 25
  const span1 = document.createElement('span');
  document.body.appendChild(span1)
  span1.appendChild(existsButton)
  span1.style.fontSize = "20px"
  span1.style.position = 'absolute';
  loc_exists = DIVIDING_LINE_LOC/2 - 50
  span1.style.left = loc_exists.toString()+'px'; 
  span1.style.top = '10px';
  existsButton.addEventListener('click', function() {
        if(!existsButtonPressed) {
            existsButton.src = 'exists_button_pressed_red2.png';
            forallButtonPressed = false;
            forallButton.src = 'forall_button.png';
        }
        else {
            existsButton.src = 'exists_button.png';
        }
        existsButtonPressed = !existsButtonPressed;
  });
  existsButton.addEventListener('mousedown', function() {
        existsButton.src = 'exists_button_pressed.png';
  });
  existsButton.addEventListener('mouseleave', function() {
    if(existsButtonPressed) {
        existsButton.src = 'exists_button_pressed_red2.png';
    }
    else {
        existsButton.src = 'exists_button.png';
    }
  });
  const span1a = document.createElement('span');  //this sits underneath the button and is just 
                                                  //so we can catch select all
  span1a.style.fontSize = "0px"  //effectively hidden
  span1a.style.position = 'absolute';
  span1a.style.left = loc_exists.toString()+'px'; 
  span1a.style.top = '10px';
  document.body.appendChild(span1a)
  textNode1 = document.createTextNode('\u2203 Side');
  span1a.appendChild(textNode1)

  span1.addEventListener("mouseover", function() {
    span1.style.cursor = "pointer";
  });
  span1.addEventListener("mouseleave", function() {
    span1.style.cursor = "default";
  });

  //forall button stuff
  forallButtonPressed = false
  const forallButton = document.createElement('img');
  forallButton.src = 'forall_button.png';
  forallButton.draggable = false
  forallButton.width = 100
  forallButton.height = 25
  const span2 = document.createElement('span');
  document.body.appendChild(span2)
  span2.appendChild(forallButton)
  span2.style.fontSize = "20px"
  span2.style.position = 'absolute';
  loc_forall = 3*DIVIDING_LINE_LOC/2 - 50
  span2.style.left = loc_forall.toString()+'px'; 
  span2.style.top = '10px';
  forallButton.addEventListener('click', function() {
        if(!forallButtonPressed) {
            forallButton.src = 'forall_button_pressed_red2.png';
            existsButtonPressed = false;
            existsButton.src = 'exists_button.png';
        }
        else {
            forallButton.src = 'forall_button.png';
        }
        forallButtonPressed = !forallButtonPressed;
  });
  forallButton.addEventListener('mousedown', function() {
    forallButton.src = 'forall_button_pressed.png';
  });
  forallButton.addEventListener('mouseleave', function() {
    if(forallButtonPressed) {
        forallButton.src = 'forall_button_pressed_red2.png';
    }
    else {
        forallButton.src = 'forall_button.png';
    }
  });
  const span2a = document.createElement('span');  //this sits underneath the button and is just 
                                                  //so we can catch select all
  span2a.style.fontSize = "0px"  //effectively hidden
  span2a.style.position = 'absolute';
  span2a.style.left = loc_forall.toString()+'px'; 
  span2a.style.top = '10px';
  document.body.appendChild(span2a)
  textNode2 = document.createTextNode('\u2200 Side');
  span2a.appendChild(textNode2)

  span2.addEventListener("mouseover", function() {
    span2.style.cursor = "pointer";
  });
  span2.addEventListener("mouseleave", function() {
    span2.style.cursor = "default";
  });

  document.addEventListener('selectionchange', function(event) {
    selectedText = document.getSelection().toString()
    if(selectedText.includes('\u2200') && selectedText.includes('\u2203')) {
        selectAll()
        window.getSelection().removeAllRanges()
    }
  }, true);

  document.addEventListener('copy', function(event) {
    handleCopy()
  }, true);

  document.addEventListener('cut', function(event) {  //nodes and edges should be deleted immediately in this case
    handleCut()
  }, true);

  function getNodeById(id) {
    for(node of nodes) {
        if(node.id == id) {
            return node
        }
    }
    return undefined
  }

  function getEdgeByNodeIdPair(id1, id2) {
    for(let edge of edges) {
        if(edge.node1.id == id1 && edge.node2.id == id2) {
            return edge
        }
    }
    return undefined
  }

  function getUltraEdgeByObjectPair(obj1, obj2) {
    for(let ultraEdge of ultraEdges) {
        if(ultraEdge.obj1.x == obj1.x && ultraEdge.obj1.y == obj1.y &&
            ultraEdge.obj2.x == obj2.x && ultraEdge.obj2.y == obj2.y) {
            return ultraEdge 
        }
    }
    return undefined
  }

  async function launchIconizedGroupPopup(icoGroup) {   
    wh_string = "width=" + canvas.width/2 + ",height=" + canvas.height      
    if(icoGroup.x > DIVIDING_LINE_LOC) {
        wh_string += (",left=" + canvas.width/2)
    }
    const newWindow = window.open("ico_group_editor.html", "_blank", wh_string)  
    await delay(250); 
    newWindow.postMessage(getIcoGroupJSON(icoGroup), '*'); 
  }

  function getIcoGroupJSON(icoGroup) {
    let inner_nodes = new Set()
    for(let n of icoGroup.inner_nodes) {
        inner_nodes.add(coerceToNode(n))
    }
    let inner_edges = new Set()
    for(let e of icoGroup.inner_edges) {
        inner_edges.add(coerceToEdge(e))
    }
    let inner_icoGroups = new Set()
    for(let i of icoGroup.inner_iconizedGroups) {
        inner_icoGroups.add(coerceToIconizedGroup(i))
    }
    let inner_ultraEdges = new Set()
    for(let u of icoGroup.inner_ultraEdges) {
        inner_ultraEdges.add(coerceToUltraEdge(u))
    }
   
    let which_side = (icoGroup.x < DIVIDING_LINE_LOC ? EXISTS_SIDE : FORALL_SIDE)
    return clipifyIcoGroup(which_side, icoGroup.x, icoGroup.y, inner_nodes, inner_edges, inner_icoGroups, inner_ultraEdges)
  }

  function clipifyIcoGroup(which_side, center_x, center_y, inner_nodes, inner_edges, inner_iconizedGroups, inner_ultraEdges) {
    
    zoomLevel = getZoomLevel()
    zoomPortion = "\"zoom_level\": " + zoomLevel + ",\n"
    zoomPortion += "\"canvas_width\": " + CANVAS_WIDTH + ",\n"
    zoomPortion += "\"canvas_height\": " + CANVAS_HEIGHT
    roundCounterPortion = "\"round_counter\":" + 1   //not relevant
    nodeIdCounterPortion = "\"node_id_counter\": " + node_id_counter
    icoGroupIdCounterPortion = "\"iconizedGroup_id_counter\": " + iconizedGroup_id_counter
    whichSidePortion = "\"which_side\": " + which_side
    constantsPortion = "\"in_use_constants\": " + JSON.stringify(Array.from(getConstantsInUseOnSide(which_side, undefined)))
    locationPortion = "\"center_x\": " + center_x + ",\"center_y\": " + center_y
    edgeTypePortion = "\"edge_type\": " + (edge_type == TYPE_DIRECTED ? "\"directed\"" : "\"undirected\"")
    orderPortion = "\"node_ordering\": " + nodes_are_ordered
    nodesPortion = "\"nodes\": " + arrayToJson(Array.from(inner_nodes))
    edgesPortion = "\"edges\": " + arrayToJson(Array.from(inner_edges))
    icoGrouPortion =  "\"iconizedGroups\": " + arrayToJson(Array.from(inner_iconizedGroups)) //innnerIcos become icos!!
    ultraEdgePortion =  "\"ultraEdges\": " + arrayToJson(Array.from(inner_ultraEdges))
    let relative_innerIconizedGroups = []
    for(let i of inner_iconizedGroups) {
        relative_innerIconizedGroups = relative_innerIconizedGroups.concat(getAllNestedIconizedGroups(i))
    }
    innerIcoGroupPortion =  "\"innerIconizedGroups\": " + arrayToJson(relative_innerIconizedGroups)
    moveQueuePortion = "\"move_queue\": []" //not relevant

    
    return "{" + zoomPortion + ",\n" + roundCounterPortion + ",\n" + nodeIdCounterPortion  + ",\n" 
        + icoGroupIdCounterPortion + ",\n" + whichSidePortion + ",\n" + constantsPortion + ",\n"
        + locationPortion + ",\n" + edgeTypePortion + ",\n" 
        + orderPortion + ",\n" + nodesPortion + ",\n" + edgesPortion + ",\n" 
        + icoGrouPortion + ",\n" + ultraEdgePortion + ",\n" + innerIcoGroupPortion + ",\n" 
        + moveQueuePortion + "}"
  }

  function getGameJSON(additionalStuff = "") {
    return clipifyGameState(nodes, edges, iconizedGroups, ultraEdges, additionalStuff)
  }

  function clipifyGameState(nodes, edges, iconizedGroups, ultraEdges, additionalStuff) {
    
    zoomLevel = getZoomLevel()
    zoomPortion = "\"zoom_level\": " + zoomLevel + ",\n"
    zoomPortion += "\"canvas_width\": " + CANVAS_WIDTH + ",\n"
    zoomPortion += "\"canvas_height\": " + CANVAS_HEIGHT
    nodeIdCounterPortion = "\"node_id_counter\": " + node_id_counter
    icoGroupIdCounterPortion = "\"iconizedGroup_id_counter\": " + iconizedGroup_id_counter
    edgeTypePortion = "\"edge_type\": " + (edge_type == TYPE_DIRECTED ? "\"directed\"" : "\"undirected\"")
    orderPortion = "\"node_ordering\": " + nodes_are_ordered
    nodesPortion = "\"nodes\": " + arrayToJson(Array.from(nodes))
    edgesPortion = "\"edges\": " + arrayToJson(Array.from(edges))
    icoGrouPortion =  "\"iconizedGroups\": " + arrayToJson(Array.from(iconizedGroups))
    ultraEdgePortion =  "\"ultraEdges\": " + arrayToJson(Array.from(ultraEdges))
    let innerIconizedGroups = []
    for(let icoGroup of iconizedGroups) {
        innerIconizedGroups = innerIconizedGroups.concat(getAllNestedIconizedGroups(icoGroup))
    }
    innerIcoGroupPortion =  "\"innerIconizedGroups\": " + arrayToJson(innerIconizedGroups)
    moveQueuePortion = "\"move_queue\": []"
    
    return "{" + zoomPortion + ",\n" + nodeIdCounterPortion + ",\n" + icoGroupIdCounterPortion + ",\n" 
        + edgeTypePortion + ",\n" + orderPortion + ",\n" + nodesPortion + ",\n" + edgesPortion + ",\n" 
        + icoGrouPortion + ",\n" + ultraEdgePortion + ",\n" + innerIcoGroupPortion + ",\n"
        + moveQueuePortion + (additionalStuff == "" ? "" : ",\n") + additionalStuff + "}"
  }

  window.addEventListener("message",(event) => {    //Sets up the icoGroup to edit based on the passed in JSON
    console.log("Received a message: ")
    console.log(event.data)
  });


  function handleCopy() {
    if(selected_nodes.size > 0 || selected_edges.size > 0 || selected_iconizedGroups.size > 0 || selected_ultraEdges.size > 0) {
        cutPending = false   //must get overruled after calling if this is a cut!
        copied_nodes = structuredNodesClone(selected_nodes)
        copied_edges = structuredEdgesClone(selected_edges)
        copied_iconizedGroups = structuredIconizedGroupsClone(selected_iconizedGroups)  //does not handle nesting. Will have to be done by hand!
        copied_ultraEdges = structuredUltraEdgesClone(selected_ultraEdges)

        //somehow the below does not always work!! (This will ultimately also have to include copied_iconizedGroups and copied_ultraEdges)
        copyToClipboard(clipifyGameState(copied_nodes, copied_edges, copied_iconizedGroups, copied_ultraEdges))
    }
    else {
        beep()
    }
  }

  function handleCut() {
    let all_associated_edges = new Set()  //make sure that all_associated_edges is local
    let all_associated_ultraEdges = new Set()
    for(let node of selected_nodes) {
        all_associated_edges = all_associated_edges.union(node.edges)
        all_associated_ultraEdges = all_associated_ultraEdges.union(node.ultraEdges)
    }
    for(let icoGroup of selected_iconizedGroups) {
        all_associated_ultraEdges = all_associated_ultraEdges.union(icoGroup.ultraEdges)
    }
    all_associated_edges = all_associated_edges.union(selected_edges)
    all_associated_ultraEdges = all_associated_ultraEdges.union(selected_ultraEdges)
    all_cut_edges = structuredEdgesClone(all_associated_edges)
    all_cut_ultraEdges = structuredUltraEdgesClone(all_associated_ultraEdges)
    handleCopy()
    cutPending = true
    deleteSelectedEdges() 
    deleteSelectedUltraEdges() 
    deleteSelectedNodes()
    deleteSelectedIconizedGroups()
  }

  function isPasteToRepairAMistakenCut() {   
    let stuff_on_left = false
    let stuff_on_right = false
    for(let node of copied_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            stuff_on_left = true
        }
        else if (node.x > DIVIDING_LINE_LOC) {
            stuff_on_right = true
        }
    }
    for(let edge of copied_edges) {
        if(edge.node1.x < DIVIDING_LINE_LOC) {
            stuff_on_left = true
        }
        else if (edge.node1.x > DIVIDING_LINE_LOC) {
            stuff_on_right = true
        }
    }
    for(let icoGroup of copied_iconizedGroups) {
        if(icoGroup.x < DIVIDING_LINE_LOC) {
            stuff_on_left = true
        }
        else if (icoGroup.x > DIVIDING_LINE_LOC) {
            stuff_on_right = true
        }
    }
    for(let ultraEdge of copied_ultraEdges) {
        if(ultraEdge.obj1.x < DIVIDING_LINE_LOC) {
            stuff_on_left = true
        }
        else if (ultraEdge.obj1.x > DIVIDING_LINE_LOC) {
            stuff_on_right = true
        }
    }

    if(stuff_on_left && stuff_on_right) {
        return true
    }
    else if(stuff_on_left && (existsButtonPressed || (!forallButtonPressed && endX < DIVIDING_LINE_LOC))) {
        return true
    }
    else if(stuff_on_right && (forallButtonPressed || (!existsButtonPressed && endX > DIVIDING_LINE_LOC))) {
        return true
    }
    else {
        return false
    }
  }

  function isConstantInUseOnLeft(constant) {
    return isConstantInUseOnGivenSide(EXISTS_SIDE, constant)
  }

  function isConstantInUseOnRight(constant) {
    return isConstantInUseOnGivenSide(FORALL_SIDE, constant)
  }

  function isConstantInUseOnGivenSide(side, constant) {
    for(let node of nodes) {
        if((node.x < DIVIDING_LINE_LOC && side == EXISTS_SIDE) || 
            (node.x > DIVIDING_LINE_LOC && side == FORALL_SIDE)) {
            if(node.constant == constant) {
                return true
            }
        }
    }
    for(let icoGroup of iconizedGroups) {
        if((icoGroup.x < DIVIDING_LINE_LOC && side == EXISTS_SIDE) || 
            (icoGroup.x > DIVIDING_LINE_LOC && side == FORALL_SIDE)) {
            for(let node of icoGroup.inner_nodes) {
                if(node.constant == constant) {
                    return true
                }
            }
        }
    }

    return false
  }

  function getIconoizedGroupById(id) {
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.id == id) {
            return icoGroup
        }
    }

    return undefined
  }
  

  function pasteToRepairMistakenCut() {  //this is a tricky case - may not be worth it....
                                         //don't handle if graph on the given side has been changed
    
    //make sure that any nodes that copied edges were attached to, 
    // that were not part of the coped set, still exist!
    for(let node of copied_nodes) {
        node.edges = new Set()
        orderInputBox = createNodeOrderingBox(node)
        node_id_to_inputBox_map[node.id] = orderInputBox
        if(orderings_are_being_displayed) {
            orderInputBox.style.display = "initial"
        }
        else {
            orderInputBox.style.display = "none"
        }
        if(node.constant != '') {
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
    }
    nodes = nodes.union(copied_nodes)
    for(let edge of all_cut_edges) {
        node1 = getNodeById(edge.node1.id)
        node2 = getNodeById(edge.node2.id)
        if(node1 != undefined && node2 != undefined) {
            edge.node1 = node1
            edge.node2 = node2
            node1.edges.add(edge)
            node2.edges.add(edge)
            edges.add(edge)
        }
    }  
     for(let icoGroup of copied_iconizedGroups) {  
        icoGroup.ultraEdges = new Set()
    }
    iconizedGroups = iconizedGroups.union(copied_iconizedGroups) 
    for(let ultraEdge of all_cut_ultraEdges) {
        let obj1 = obj2 = undefined
        if(ultraEdge.obj1.hasOwnProperty('num_sides')) {
            obj1 = getIconoizedGroupById(ultraEdge.obj1.id)
        }
        else {
            obj1 = getNodeById(ultraEdge.obj1.id)
        }
        if(ultraEdge.obj2.hasOwnProperty('num_sides')) {
            obj2 = getIconoizedGroupById(ultraEdge.obj2.id)
        }
        else {
            obj2 = getNodeById(ultraEdge.obj2.id)
        }
        if(obj1 != undefined && obj2 != undefined) {
            ultraEdge.obj1 = obj1
            ultraEdge.obj2 = obj2
            obj1.ultraEdges.add(ultraEdge)
            obj2.ultraEdges.add(ultraEdge)
            ultraEdges.add(ultraEdge)
        }
    }  

    selected_nodes = copied_nodes  
    selected_edges = new Set()
    for(let edge of copied_edges) {
        sel_edge = getEdgeByNodeIdPair(edge.node1.id, edge.node2.id) 
        if(sel_edge != undefined) {
            selected_edges.add(sel_edge)
        }
    }
    selected_iconizedGroups = copied_iconizedGroups
    selected_ultraEdges = new Set()
    for(let ultraEdge of copied_ultraEdges) {  //needs completion....
        sel_ultraEdge = getUltraEdgeByObjectPair(ultraEdge.obj1, ultraEdge.obj2) 
        if(sel_ultraEdge != undefined) {
            selected_ultraEdges.add(sel_ultraEdge)
        }
    }
   
    redrawAll()
    copied_nodes = new Set()
    copied_edges = new Set()
    copied_iconizedGroups = new Set()
    copied_ultraEdges = new Set()
    cutPending = false
  }

  function handlePaste() {
    VERTICAL_PASTE_BUFFER = 20
    if(iconizedGroups.size > 0) {
        VERTICAL_PASTE_BUFFER = 90    //Still a bit crude....
    } 

    //We will need to restore these at the end. 
    let pre_selected_nodes = new Set(selected_nodes)  
    let pre_selected_edges = new Set(selected_edges)  
    let pre_selected_iconizedGroups = new Set(selected_iconizedGroups)
    let pre_selected_ultraEdges = new Set(selected_ultraEdges)
    let pre_copied_nodes = structuredNodesClone(copied_nodes)
    let pre_copied_edges = structuredEdgesClone(copied_edges)
    let pre_copied_iconizedGroups = structuredIconizedGroupsClone(copied_iconizedGroups)
    let pre_copied_ultraEdges = structuredUltraEdgesClone(copied_ultraEdges)
    //json = readFromClipboard()
    //clipObject = JSON.parse(json)
    if(cutPending && isPasteToRepairAMistakenCut()) {
        pasteToRepairMistakenCut()
        return
    }

    if(copied_nodes.size == 0  && copied_iconizedGroups.size == 0) {  //can only paste edges that are between copied nodes!!
        beep()
        return
    }
    else {
        //First remove any edges from the selection for which both nodes are not selected
        edges_to_remove = new Set()
        for(let edge of copied_edges) {
            has_node1 = false
            has_node2 = false
            for(let node of copied_nodes) {
                if(edge.node1.id == node.id) {
                    has_node1 = true
                    edge.node1 = node
                }
                if(edge.node2.id == node.id) {  //Not an else if in the case of a self-loop!
                    has_node2 = true
                    edge.node2 = node
                }
            }
            if(!has_node1 || !has_node2) {
                edges_to_remove.add(edge)
            }
        }
        for(let edge of edges_to_remove) {
            copied_edges.delete(edge)
        }
        //next remove any ultraEdges from the selection for which both obj1 and obj2 are not selected
        ultraEdges_to_remove = new Set()
        for(let ultraEdge of copied_ultraEdges) {
            has_obj1 = false
            has_obj2 = false
            if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                for(let icoGroup of copied_iconizedGroups) {
                    if(ultraEdge.obj1.id == icoGroup.id) {
                        has_obj1 = true
                    }
                }
            }
            else {
                for(let node of copied_nodes) {
                    if(ultraEdge.obj1.id == node.id) {
                        has_obj1 = true
                    }
                }
            }
            if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                for(let icoGroup of copied_iconizedGroups) {
                    if(ultraEdge.obj2.id == icoGroup.id) {
                        has_obj2 = true
                    }
                }
            }
            else {
                for(let node of copied_nodes) {
                    if(ultraEdge.obj2.id == node.id) {
                        has_obj2 = true
                    }
                }
            }
            if(!has_obj1 || !has_obj2) {
                ultraEdges_to_remove.add(ultraEdge)
            }
        }
        for(let ultraEdge of edges_to_remove) {
            copied_ultraEdges.delete(ultraEdge)
        }



        //decide which side to copy to and reference point of where to copy to
        which_side_to_copy_to = FORALL_SIDE  //the default
        //if there are selected nodes on both sides paste must be to both sides
        //after pasting, pasted nodes should be selected
        stuff_on_left = false
        stuff_on_right = false
        lowest_y_left = TOP_BUFFER
        lowest_y_right = TOP_BUFFER
        for(let node of copied_nodes) {
            if(node.x < DIVIDING_LINE_LOC) {
                stuff_on_left = true
                if(node.y > lowest_y_left) {
                    lowest_y_left = node.y
                }
            }
            else if (node.x > DIVIDING_LINE_LOC) {
                stuff_on_right = true
                if(node.y > lowest_y_right) {
                    lowest_y_right = node.y
                }
            }
        }
        highesttSelectedY = canvas.height
        for(let node of copied_nodes) {
            if(node.y < highesttSelectedY) {
                highesttSelectedY = node.y
            }
        }
        for(let icoGroup of copied_iconizedGroups) {
            if(icoGroup.x < DIVIDING_LINE_LOC) {
                stuff_on_left = true
                if(icoGroup.y > lowest_y_left) {
                    lowest_y_left = icoGroup.y
                }
            }
            else if (icoGroup.x > DIVIDING_LINE_LOC) {
                stuff_on_right = true
                if(icoGroup.y > lowest_y_right) {
                    lowest_y_right = icoGroup.y
                }
            }
        }
        for(let icoGroup of copied_iconizedGroups) {
            if(icoGroup.y < highesttSelectedY) {
                highesttSelectedY = icoGroup.y
            }
        }

        if(stuff_on_left && stuff_on_right) {
            which_side_to_copy_to = BOTH_SIDES
            lowestY = Math.max(getYCoordOfLowestNodeOrIconizedGroup(BOTH_SIDES), TOP_BUFFER)
            if(Math.max(lowest_y_left, lowest_y_right) + (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER > 
                canvas.height - BOTTOM_BUFFER) {
                alert("Not enough room to complete paste!")
                return
            }
            for(let node of copied_nodes) {
                node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
            }
            for(let icoGroup of copied_iconizedGroups) {
                icoGroup.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
            }
        }
        else if(stuff_on_left) {
            if(existsButtonPressed || (!forallButtonPressed && endX < DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = EXISTS_SIDE
                lowestY = Math.max(getYCoordOfLowestNodeOrIconizedGroup(EXISTS_SIDE), TOP_BUFFER)
                if(Math.max(lowest_y_left, lowest_y_right) + (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER > 
                    canvas.height - BOTTOM_BUFFER) {
                    alert("Not enough room to complete paste!")
                    return
                }
                for(let node of copied_nodes) {
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
                for(let icoGroup of copied_iconizedGroups) {
                    icoGroup.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
            else if(forallButtonPressed|| (!existsButtonPressed && endX > DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = FORALL_SIDE
                lowestY = Math.max(getYCoordOfLowestNodeOrIconizedGroup(FORALL_SIDE), TOP_BUFFER)
                if(Math.max(lowest_y_left, lowest_y_right) + (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER > 
                    canvas.height - BOTTOM_BUFFER) {
                    alert("Not enough room to complete paste!")
                    return
                }
                for(let node of copied_nodes) {
                    node.x += DIVIDING_LINE_LOC
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
                for(let icoGroup of copied_iconizedGroups) {
                    icoGroup.x += DIVIDING_LINE_LOC
                    icoGroup.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
        }
        else if(stuff_on_right) {
            if(existsButtonPressed || (!forallButtonPressed && endX < DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = EXISTS_SIDE
                lowestY = Math.max(getYCoordOfLowestNodeOrIconizedGroup(EXISTS_SIDE), TOP_BUFFER)
                if(Math.max(lowest_y_left, lowest_y_right) + (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER > 
                    canvas.height - BOTTOM_BUFFER) {
                    alert("Not enough room to complete paste!")
                    return
                }
                for(let node of copied_nodes) {
                    node.x -= DIVIDING_LINE_LOC
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
                for(let icoGroup of copied_iconizedGroups) {
                    icoGroup.x -= DIVIDING_LINE_LOC
                    icoGroup.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
            else if(forallButtonPressed|| (!existsButtonPressed && endX > DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = FORALL_SIDE
                lowestY = Math.max(getYCoordOfLowestNodeOrIconizedGroup(FORALL_SIDE), TOP_BUFFER)
                if(Math.max(lowest_y_left, lowest_y_right) + (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER > 
                    canvas.height - BOTTOM_BUFFER) {
                    alert("Not enough room to complete paste!")
                    return
                }
                for(let node of copied_nodes) {
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
                for(let icoGroup of copied_iconizedGroups) {
                    icoGroup.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
        }
        //Alter node ids so they are distinct from existing node ids; 
        //Make sure the edge set for the nodes correspond to the edges to be added
        //Also add the selected_nodes and selected_edges to nodes and edges
        old_id_to_node_map = new Map()
        for(let node of copied_nodes) {
            old_id_to_node_map.set(node.id, node)
            node.id = node_id_counter++
            node.edges = new Set()
            if(node.constant != '' && ((node.x < DIVIDING_LINE_LOC && isConstantInUseOnLeft(node.constant)) 
                || (node.x > DIVIDING_LINE_LOC && isConstantInUseOnRight(node.constant)))) {
                node.constant = ''
            }
            node.ultraEdges = new Set()
        }
        
        let icoGroupNodes = new Set()
        let old_id_to_iconizedGroup_map = new Map()
        for(let icoGroup of copied_iconizedGroups) {  //this has to handle all the icoGroup pasting business since copied_iconizedGroups is a structuredClone!!
            let whichSide = (icoGroup.x < DIVIDING_LINE_LOC ? EXISTS_SIDE : FORALL_SIDE)
            let newIcoGroup = deepIconizedGroupClone(icoGroup, whichSide)   //not sure why we are doing this
            old_id_to_iconizedGroup_map.set(icoGroup.id, newIcoGroup)
            let nestedNodes = new Set(getAllNestedNodes(newIcoGroup))  //have to segregate left hand nodes and right hand nodes!!
            for(let node of nestedNodes) {
                if(node.x < DIVIDING_LINE_LOC && whichSide == FORALL_SIDE) {
                    node.x += DIVIDING_LINE_LOC
                }
                else if(node.x > DIVIDING_LINE_LOC && whichSide == EXISTS_SIDE) {
                    node.x -= DIVIDING_LINE_LOC
                }
            }
            icoGroupNodes = icoGroupNodes.union(nestedNodes)
            let nestedIcoGroups = new Set(getAllNestedIconizedGroups(newIcoGroup))
            for(let i of nestedIcoGroups) {
                if(i.x < DIVIDING_LINE_LOC && whichSide == FORALL_SIDE) {
                    i.x += DIVIDING_LINE_LOC
                }
                else if(i.x > DIVIDING_LINE_LOC && whichSide == EXISTS_SIDE) {
                    i.x -= DIVIDING_LINE_LOC
                }
            }
            //old_id_to_iconizedGroup_map.set(icoGroup.id, icoGroup)  //this undoes the prior map
            //icoGroup.id = iconizedGroup_id_counter++
            newIcoGroup.id = iconizedGroup_id_counter++
            let old_id_to_icoGroupNode_map = new Map()
            //for(let node of icoGroup.inner_nodes) {
            for(let node of newIcoGroup.inner_nodes) {
                old_id_to_icoGroupNode_map.set(node.id, node)
                node.id = node_id_counter++
                node.edges = new Set()
                if(node.constant != '' && ((icoGroup.x < DIVIDING_LINE_LOC && isConstantInUseOnLeft(node.constant)) 
                    || (icoGroup.x > DIVIDING_LINE_LOC && isConstantInUseOnRight(node.constant)))) {
                    node.constant = ''
                }
                icoGroupNodes.add(node)
            }
            //for(let edge of icoGroup.inner_edges) {  
            for(let edge of newIcoGroup.inner_edges) {
                //sometimes the javascript structuredClone does not reach deeply enough, so be careful!!
                if(old_id_to_icoGroupNode_map.get(edge.node1.id) != undefined) {
                    edge.node1 = old_id_to_icoGroupNode_map.get(edge.node1.id)
                    edge.node2 = old_id_to_icoGroupNode_map.get(edge.node2.id)
                }
                edge.node1.edges.add(edge)
                edge.node2.edges.add(edge)
            }
            newIcoGroup.ultraEdges = new Set()
            //icoGroup.ultraEdges = new Set()
        }
        for(let ultraEdge of copied_ultraEdges) {
            if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                newIcoGroup = old_id_to_iconizedGroup_map.get(ultraEdge.obj1.id)
                newIcoGroup.ultraEdges.add(ultraEdge)
                ultraEdge.obj1 = newIcoGroup
            }
            else {
                newNode = old_id_to_node_map.get(ultraEdge.obj1.id)
                newNode.ultraEdges.add(ultraEdge)
                ultraEdge.obj1 = newNode
            }
            if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                newIcoGroup = old_id_to_iconizedGroup_map.get(ultraEdge.obj2.id)
                newIcoGroup.ultraEdges.add(ultraEdge)
                ultraEdge.obj2 = newIcoGroup
            }
            else {
                newNode = old_id_to_node_map.get(ultraEdge.obj2.id)
                newNode.ultraEdges.add(ultraEdge)
                ultraEdge.obj2 = newNode
            }
            ultraEdges.add(ultraEdge)
        }
        for(let edge of copied_edges) {
            edge.node1.edges.add(edge)
            edge.node2.edges.add(edge)
        }
        copied_iconizedGroups = new Set(old_id_to_iconizedGroup_map.values()) 
        //Now create the ordering (and constant) boxes NOTE: nodes should be ordered 
        // in the same order as they were copied in. 
        // (keep in left hand and right hand side groups when doing this....)
        let highestOrderOnLeft = getHightestNodeOrderOnSide(EXISTS_SIDE)
        if(highestOrderOnLeft == NO_ORDER) {
            highestOrderOnLeft = 0
        }
        let highestOrderOnRight = getHightestNodeOrderOnSide(FORALL_SIDE)
        if(highestOrderOnRight == NO_ORDER) {
            highestOrderOnRight = 0
        }

        sortedCopiedNodes = Array.from(copied_nodes).concat(Array.from(icoGroupNodes))  //now includes the copied highest level nodes as well as the nested nodes
        sortedCopiedNodes.sort((a,b) => {
            if(a.order != b.order) {
                return a.order - b.order
            }
            else {
                return a.id - b.id
            }
        });

        let existingLeftHandNodes = getAllNestedNodesBySide(EXISTS_SIDE)
        let existingLeftHandOrders = new Set()
        for(let node of existingLeftHandNodes) {
            if(node.order != NO_ORDER) {
                existingLeftHandOrders.add(node.order)
            }
        }
        let existingRightHandNodes = getAllNestedNodesBySide(FORALL_SIDE)
        let existingRightHandOrders = new Set()
        for(let node of existingRightHandNodes) {
            if(node.order != NO_ORDER) {
                existingRightHandOrders.add(node.order)
            }
        }

        for(let node of sortedCopiedNodes) {  //START HERE!!
            if(node.constant != '') {
                constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
                node_id_to_constantBox_map.set(node.id, constantBox)
                constantBox.style.display = 'none'
            }
            orderInputBox = undefined
            if(node.order == NO_ORDER) {
                node.order = 0 //to save time in the next call
                orderInputBox = createNodeOrderingBox(node)  //will assign an order if node.order == NO_ORDER
                orderInputBox.value = ''
                node.order = NO_ORDER
            }
            else if(stuff_on_left && which_side_to_copy_to == FORALL_SIDE) {
                //see if or the order is available - if so, snag it
                order_available = !existingRightHandOrders.has(node.order)
                if(!order_available) {
                    node.order = ++highestOrderOnRight
                    orderInputBox = createNodeOrderingBox(node)
                    existingRightHandOrders.add(node.order) //so doesn't get used again!
                }
                else {
                    orderInputBox = createNodeOrderingBox(node)
                }
            }
            else if(stuff_on_right && which_side_to_copy_to == EXISTS_SIDE) {
                //see if or the order is available - if so, snag it
                order_available = !existingLeftHandOrders.has(node.order)
                if(!order_available) {
                    node.order = ++highestOrderOnLeft
                    orderInputBox = createNodeOrderingBox(node)
                    existingLeftHandOrders.add(node.order) //so doesn't get used again!
                }
                else {
                    orderInputBox = createNodeOrderingBox(node)
                }
            }
            else {
                if(node.x < DIVIDING_LINE_LOC) {
                    node.order = ++highestOrderOnLeft
                    existingLeftHandOrders.add(node.order)
                }
                else {
                    node.order = ++highestOrderOnRight
                    existingRightHandOrders.add(node.order)
                }
                orderInputBox = createNodeOrderingBox(node)
            }
            node_id_to_inputBox_map[node.id] = orderInputBox
            if(orderings_are_being_displayed  && !icoGroupNodes.has(node)) {
                orderInputBox.style.display = "initial"
            }
            else {
                orderInputBox.style.display = "none"
            }
            if(!icoGroupNodes.has(node)) {  //only become highest level nodes if not icoGroupNodes!!!
                nodes.add(node)
            }
        }
        iconizedGroups = iconizedGroups.union(copied_iconizedGroups) 
        edges = edges.union(copied_edges)
        selected_nodes = pre_selected_nodes  
        selected_edges = pre_selected_edges  
        selected_iconizedGroups = pre_selected_iconizedGroups
        selected_ultraEdges = pre_selected_ultraEdges
        copied_nodes = pre_copied_nodes
        copied_edges = pre_copied_edges
        copied_iconizedGroups = pre_copied_iconizedGroups
        copied_ultraEdges = pre_copied_ultraEdges
        //now redraw everything ()
        redrawAll()
        cutPending = false
    }
  }

  document.addEventListener('paste', function(event) {
    handlePaste()
  }, true);

  internal_clipboard = ""
  async function copyToClipboard(text) {
    try {
        internal_clipboard = text //for safety
        await navigator.clipboard.writeText(text);
        console.log('JSON copied to clipboard');
    } 
    catch (err) {
        console.warn('Failed to copy to external clipboard: ', err);
        console.log("Using internal clipboard instead")
    }
  }

  async function readFromClipboard() {
    try {
        
        const text = await navigator.clipboard.readText();
        console.log('Text read from clipboard');
        return text
    } 
    catch (err) {
        console.warn('Failed to read from clipboard: ', err);
        console.log("Using internal clipboard instead")
        return internal_clipboard
    }
  }

  function orderSelectedNodesLeftToRight() {
    left_hand_node_orders = []
    left_hand_nodes = []
    right_hand_node_orders = []
    right_hand_nodes = []
    for(let node of selected_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            if(node.order != NO_ORDER) {
                left_hand_node_orders.push(node.order)
                left_hand_nodes.push(node)
            }
        }
        else {
            if(node.order != NO_ORDER) {
                right_hand_node_orders.push(node.order)
                right_hand_nodes.push(node)
            }
        }
    }
    left_hand_nodes.sort((a,b)=> {
        if(a.x < b.x || (a.x == b.x && a.y < b.y)) {
            return -1
        }
        else if(a.x > b.x || (a.x == b.x && a.y > b.y)) {
            return 1
        } 
        else { //should never happen -- means nodes are on top of each other
            return 0
        }
    });
    left_hand_node_orders.sort((a,b)=>a-b)
    right_hand_nodes.sort((a,b)=> {
        if(a.x < b.x || (a.x == b.x && a.y < b.y)) {
            return -1
        }
        else if(a.x > b.x || (a.x == b.x && a.y > b.y)) {
            return 1
        } 
        else { //should never happen -- means nodes are on top of each other
            return 0
        }
    });
    right_hand_node_orders.sort((a,b)=>a-b)
    for(i = 0; i<left_hand_node_orders.length; i++) {
        left_hand_nodes[i].order = left_hand_node_orders[i]
    }
    for(i = 0; i<right_hand_node_orders.length; i++) {
        right_hand_nodes[i].order = right_hand_node_orders[i]
    }
  }


  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function getZoomLevel() {
    return Math.round(window.devicePixelRatio * 100);
  }

  async function startGame() {
    requestNewGame()
  }

  function shrinkSelection(amount) {    
    let left_hand_nodes = new Set()
    let right_hand_nodes = new Set()
    let left_hand_iconizedGroups = new Set()
    let right_hand_iconizedGroups = new Set()
    topMostLeft = canvas.height
    leftMostLeft = canvas.width
    topMostRight = canvas.height
    leftMostRight = canvas.width
    for(let node of selected_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            left_hand_nodes.add(node)
            if(node.x < leftMostLeft) {
                leftMostLeft = node.x
            }
            if(node.y < topMostLeft) {
                topMostLeft = node.y
            }
        }
        else {
            right_hand_nodes.add(node)
            if(node.x < leftMostRight) {
                leftMostRight = node.x
            }
            if(node.y < topMostRight) {
                topMostRight = node.y
            }
        }
    }
    for(let icoGroup of selected_iconizedGroups) {
        if(icoGroup.x < DIVIDING_LINE_LOC) {
            left_hand_iconizedGroups.add(icoGroup)
            if(icoGroup.x < leftMostLeft) {
                leftMostLeft = icoGroup.x
            }
            if(icoGroup.y < topMostLeft) {
                topMostLeft = icoGroup.y
            }
        }
        else {
            right_hand_iconizedGroups.add(icoGroup)
            if(icoGroup.x < leftMostRight) {
                leftMostRight = icoGroup.x
            }
            if(icoGroup.y < topMostRight) {
                topMostRight = icoGroup.y
            }
        }
    }
    //Make sure it is safe to do the expansion
    if(amount > 1) {
        rightMostLeft = rightMostRight = 0
        bottomMostLeft = bottomMostRight = 0
        for(let node of selected_nodes) {
            if(node.x < DIVIDING_LINE_LOC) {
                if(node.x > rightMostLeft) {
                    rightMostLeft = node.x
                }
                if(node.y > bottomMostLeft) {
                    bottomMostLeft = node.y
                }
            }
            else {
                if(node.x > rightMostRight) {
                    rightMostRight = node.x
                }
                if(node.y > bottomMostRight) {
                    bottomMostRight = node.y
                }
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            if(icoGroup.x < DIVIDING_LINE_LOC) {
                if(icoGroup.x > rightMostLeft) {
                    rightMostLeft = icoGroup.x
                }
                if(icoGroup.y > bottomMostLeft) {
                    bottomMostLeft = icoGroup.y
                }
            }
            else {
                if(icoGroup.x > rightMostRight) {
                    rightMostRight = icoGroup.x
                }
                if(icoGroup.y > bottomMostRight) {
                    bottomMostRight = icoGroup.y
                }
            }
        }
        //test that these are safe
        testLeftX = (1-amount)*leftMostLeft + amount*rightMostLeft
        testRightX = (1-amount)*leftMostRight + amount*rightMostRight
        testLeftY = (1-amount)*topMostLeft + amount*bottomMostLeft
        testRightY = (1-amount)*topMostRight + amount*bottomMostRight
        if(testLeftX > DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) {
            alert("Expansion would take objects on the \u2203 side to far right! Bailing out.")
            return
        }
        else if(testRightX > canvas.width - DIVIDING_LINE_BUFFER) {
            alert("Expansion would take objects on the \u2200 side to far right! Bailing out.")
            return
        }
        else if(testLeftY > canvas.height - DIVIDING_LINE_BUFFER) {
            alert("Expansion would take objects on the \u2203 side to far down! Bailing out.")
            return
        }
        else if(testRightY > canvas.height - DIVIDING_LINE_BUFFER) {
            alert("Expansion gwould take objects on the \u2200 side to far down! Bailing out.")
            return
        }
    }
    if(topMostLeft < canvas.height && leftMostLeft < canvas.width) {
        //shrink nodes on left
        for(let node of left_hand_nodes) {
            node.x = (1-amount)*leftMostLeft + amount*node.x
            node.y = (1-amount)*topMostLeft + amount*node.y
        }
        //shrink iconizedGroups on left
        for(let icoGroup of left_hand_iconizedGroups) {
            icoGroup.x = (1-amount)*leftMostLeft + amount*icoGroup.x
            icoGroup.y = (1-amount)*topMostLeft + amount*icoGroup.y
        }
    }
    if(topMostRight < canvas.height && leftMostRight < canvas.width) {
        //shrink nodes on right
        for(let node of right_hand_nodes) {
            node.x = (1-amount)*leftMostRight + amount*node.x
            node.y = (1-amount)*topMostRight + amount*node.y
        }
        //shrink iconizedGroups on right
        for(let icoGroup of right_hand_iconizedGroups) {
            icoGroup.x = (1-amount)*leftMostRight + amount*icoGroup.x
            icoGroup.y = (1-amount)*topMostRight + amount*icoGroup.y
        }
    }

    //now move constant boxes
    let all_nodes = left_hand_nodes.union(right_hand_nodes)
    for(let node of all_nodes) {
        constantBox = node_id_to_constantBox_map.get(node.id)
        if(constantBox != undefined) {
            constantBox.style.left = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
            constantBox.style.top = "" + (node.y  + CONSTANT_BOX_OFFSET_Y) + "px"
        }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height)  //since the redrawAll will just know about new node positions
    redrawAll()
    if(orderings_are_being_displayed) {
        displayNodeOrderings()   //redisplays at new locations
    }
  }

  function removeConstantBox(node) {
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        constantBox.remove()
        eraseConstantBoxFlagPole(node)
        node_id_to_constantBox_map.delete(node.id)
        redrawRectangle(node.x - 50, node.y - 50, 100, 100) 
    }
  }

  function nodeContextMenuHandler(node, which) {
    if(which == ASSIGN_CONSTANT_INDEX) {
        constantBox = node_id_to_constantBox_map.get(node.id)
        if(constantBox == undefined) {
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            drawConstantBoxFlagPole(node) 
            constantBox.focus()
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
        else { 
            node.constant = ''
            removeConstantBox(node)
        }
    }
  }


  function requestExplodeIconizedGroup(icoGroup) {
    let topMost = canvas.height
    let leftMost = canvas.width
    let bottomMost = rightMost = 0
    let idToNodeMap = new Map()
    for(let node of icoGroup.inner_nodes) {
        idToNodeMap.set(node.id, node)
        if(node.y < topMost) {
            topMost = node.y
        }
        if(node.x < leftMost) {
            leftMost = node.x
        }
        if(node.y > bottomMost) {
            bottomMost = node.y
        }
        if(node.x > rightMost) {
            rightMost = node.x
        }
        node.edges = new Set()  //will rebuild these
        node.ultraEdges = new Set() //will reubuild these too!
    }
    let idToIconizedGroupMap = new Map()
    for(let i of icoGroup.inner_iconizedGroups) {
        idToIconizedGroupMap.set(i.id, i)
        if(i.y < topMost) {
            topMost = i.y
        }
        if(i.x < leftMost) {
            leftMost = i.x
        }
        if(i.y > bottomMost) {
            bottomMost = i.y
        }
        if(i.x > rightMost) {
            rightMost = i.x
        }
        i.ultraEdges = new Set() //will reubuild these!
    }
    //Now confirm there is enough space to do explosion
    formerCenterX = (leftMost + rightMost)/2
    formerCenterY = (topMost + bottomMost)/2
    newLeftMost = leftMost + (icoGroup.x - formerCenterX)
    newRightMost = rightMost + (icoGroup.x - formerCenterX)
    newTopMost = topMost + (icoGroup.y - formerCenterY)
    newBottomMost = bottomMost + (icoGroup.y - formerCenterY)

    let whichSide = EXISTS_SIDE
    if(icoGroup.x > DIVIDING_LINE_LOC) {
        whichSide = FORALL_SIDE
    }
    let errMsg = "Explosion would push some objects off the canvas. Please move icon to a more centralized portion of the canvas and try again."
    if(newTopMost < TOP_BUFFER || newBottomMost > canvas.height - BOTTOM_BUFFER) {
        alert(errMsg)
        return
    }
    if(whichSide == EXISTS_SIDE && (newLeftMost < DIVIDING_LINE_BUFFER || newRightMost > DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER)) {
        alert(errMsg)
        return
    }
    if(whichSide == FORALL_SIDE && (newLeftMost < DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER || newRightMost > canvas.width - DIVIDING_LINE_BUFFER)) {
        alert(errMsg)
        return
    }
     
    errMsg = "Not enough room to perform explositon. Please move icon to a portion of the canvas with more space and try again."
    for(let node of nodes) {
        if(node.x + NODE_DRAW_RADIUS > newLeftMost && node.x - NODE_DRAW_RADIUS < newRightMost
            && node.y + NODE_DRAW_RADIUS > newTopMost && node.y - NODE_DRAW_RADIUS < newBottomMost) {
                alert(errMsg)
                return
        }
    }
    for(let ig of iconizedGroups) {
        if(ig != icoGroup) {
            if(ig.x + ig.radius > newLeftMost && ig.x - icoGroup.radius < newRightMost
                && ig.y + icoGroup.radius > newTopMost && ig.y - ig.radius < newBottomMost) {
                    alert(errMsg)
                    return
            }
        }
    }

    for(let node of icoGroup.inner_nodes) {
        orderInputBox = createNodeOrderingBox(node)  //this has been lost in the shuffle
        if(orderings_are_being_displayed) {
            orderInputBox.style.display = "default"
        }
        else {
            orderInputBox.style.display = "none"
        }
        if(node.constant != '') {  //and this too...
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
    }

    clearSelection()
    //if(selected_iconizedGroups.has(icoGroup)) {
    //    unselect_iconizedGroup(icoGroup)
    //}
    oldCenter = new Point((rightMost + leftMost)/2, (topMost + bottomMost)/2)
    if(oldCenter.x != icoGroup.x || oldCenter.y != icoGroup.y) {
        for(let node of icoGroup.inner_nodes) {
            node.x += (icoGroup.x - oldCenter.x)
            node.y += (icoGroup.y - oldCenter.y)
            let constantBox = node_id_to_constantBox_map.get(node.id)
            if(constantBox != undefined) {
                constantBox.style.left = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
                constantBox.style.top = "" + (node.y + CONSTANT_BOX_OFFSET_Y) + "px"
            }
            let orderInputBox = node_id_to_inputBox_map.get(node.id)
            orderInputBox.style.left = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
            orderInputBox.style.top = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            i.x += (icoGroup.x - oldCenter.x)
            i.y += (icoGroup.y - oldCenter.y)
        }
    } 
    //Repair the edges and the edges in node.edges using the idToNodeMap!
    for(let edge of icoGroup.inner_edges) {
        id1 = edge.node1.id
        id2 = edge.node2.id
        edge.node1 = idToNodeMap.get(id1)
        edge.node2 = idToNodeMap.get(id2)
        edge.node1.edges.add(edge)
        edge.node2.edges.add(edge)
    }
    //Repair ultraedges
    for(let ultraEdge of icoGroup.inner_ultraEdges) {
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            ultraEdge.obj1 = idToIconizedGroupMap.get(ultraEdge.obj1.id)
        }
        else {
            ultraEdge.obj1 = idToNodeMap.get(ultraEdge.obj1.id)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            ultraEdge.obj2 = idToIconizedGroupMap.get(ultraEdge.obj2.id)
        }
        else {
            ultraEdge.obj2 = idToNodeMap.get(ultraEdge.obj2.id)
        }
        //also have to modify the ultraEdges of the objects on each side!!
        ultraEdge.obj1.ultraEdges.add(ultraEdge)
        ultraEdge.obj2.ultraEdges.add(ultraEdge)
    }
    //Now replace any ultraEdges going from this icoGroup outward with edges and ultraEdges
    for(let ultraEdge of icoGroup.ultraEdges) {
        otherObj = ultraEdge.obj1
        if(ultraEdge.obj1 == icoGroup) {
            otherObj = ultraEdge.obj2
        }
        otherObjIsNode = !otherObj.hasOwnProperty("num_sides")
        //now deal with replacements....
        for(let node of icoGroup.inner_nodes) {
            if(otherObjIsNode) {
                edge = new Edge(otherObj, node)
                otherObj.edges.add(edge)
                node.edges.add(edge)
                edges.add(edge)
            }
            else {
                ultraEdge = new UltraEdge(otherObj, node)
                otherObj.ultraEdges.add(ultraEdge)
                node.ultraEdges.add(ultraEdge)
                ultraEdges.add(ultraEdge)
            }
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            ultraEdge = new UltraEdge(otherObj, i)
            otherObj.ultraEdges.add(ultraEdge)
            i.ultraEdges.add(ultraEdge)
            ultraEdges.add(ultraEdge)
        }
    }
    nodes = nodes.union(icoGroup.inner_nodes)
    edges = edges.union(icoGroup.inner_edges)
    ultraEdges = ultraEdges.union(icoGroup.inner_ultraEdges)
    iconizedGroups = iconizedGroups.union(icoGroup.inner_iconizedGroups)

    selected_nodes = new Set()
    selected_nodes = selected_nodes.union(icoGroup.inner_nodes)
    selected_edges = new Set()
    selected_edges = selected_edges.union(icoGroup.inner_edges)
    selected_iconizedGroups = new Set()
    selected_iconizedGroups = selected_iconizedGroups.union(icoGroup.inner_iconizedGroups)
    selected_ultraEdges = new Set()
    selected_ultraEdges = selected_ultraEdges.union(icoGroup.inner_ultraEdges)
    
    //unselect_iconizedGroup(icoGroup)
    for(let uEdge of icoGroup.ultraEdges) {
        delete_ultraEdge(uEdge)
    }
    delete_iconizedGroup(icoGroup)
    
    redrawAll()
  }

  function iconizedGroupContextMenuHandler(icoGroup, which) {
    if(which == ICO_GROUP_CHANGE_ICON_INDEX) {
        requestGroupIconization(icoGroup)
    }
    else if(which == ICO_GROUP_EDIT_INDEX) {
        launchIconizedGroupPopup(icoGroup)
    }
    else if(which == ICO_GROUP_EXPAND_INDEX) {
        requestExplodeIconizedGroup(icoGroup)
    }
  }

  function selfLoopContextMenuHandler(clicked_on_node, whichSide) {
    edge = new Edge(clicked_on_node, clicked_on_node, whichSide)
    self_loop_already_exists = false
    for(e of edges) {   //determine if self-loop already exists, and if so, which side it was drawn on
        if(e.node1 == clicked_on_node && e.node2 == clicked_on_node) {
            self_loop_already_exists = true
            e.dir = whichSide
            eraseSelfLoop(clicked_on_node, e.dir)
            redrawRectangle(clicked_on_node.x - 50, clicked_on_node.y - 50, 100, 100)
            return
        }
    }
    create_edge(edge) 
  }

  function contextMenuHandler(which) { 
    if(which == ORDER_NODES_INDEX) {
        hideNodeOrderings()
        nodes_are_ordered = !nodes_are_ordered
        if(nodes_are_ordered) {
            orderUnorderedNodesById()
        }
    }
    else if(which == DISPLAY_ORDERINGS_INDEX) {  
        orderings_are_being_displayed = !orderings_are_being_displayed
        if(orderings_are_being_displayed) {
            displayNodeOrderings()
        }
        else {
            hideNodeOrderings()
        }
    }
    else if(which == ORDER_LEFT_TO_RIGHT_INDEX) {
        orderSelectedNodesLeftToRight()
        displayNodeOrderings()
    }
    else if(which == SHRINK_SELECTED_INDEX) {
        shrinkSelection(0.67)   //inverse of the expand amount
    }
    else if(which == EXPAND_SELECTED_INDEX) {   
        shrinkSelection(1.5)    //inverse of the shrink amount
    }
    else if(which == INSERT_GRID_INDEX) {
        requestInsertGrid()  
        return
    }
    else if(which == INSERT_CYCLE_INDEX) {
        requestInsertCycle()  //ideally get location of where they right clicked and pass that on!
        return
    }
    if(nodes_are_ordered) {
        contextMenuPrefix[ORDER_NODES_INDEX] = '\u2713 '
        if(orderings_are_being_displayed) {
            contextMenuPrefix[DISPLAY_ORDERINGS_INDEX] = '\u2713 '
        }
        else {
            contextMenuPrefix[DISPLAY_ORDERINGS_INDEX] = '\xa0\xa0\xa0'
        }
        contextMenuPrefix[ORDER_LEFT_TO_RIGHT_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[SHRINK_SELECTED_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[EXPAND_SELECTED_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[INSERT_GRID_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[INSERT_CYCLE_INDEX] = '\xa0\xa0\xa0'
    }
    else {
        orderings_are_being_displayed = false 
        for(i=0; i<contextMenuPrefix.length; i++) {
            contextMenuPrefix[i] = ''
        }
    }
    console.log('Option ' + which + ' clicked.');
    contextMenu.style.display = 'none';
  }

  gridDialogHasEventListeners = false  //a bit clugey, but....
  function requestInsertGrid() {
    //const dialog = document.querySelector("dialog");
    const dialog = document.getElementById("grid_dialog")
    document.getElementById("order_tb_lr").disabled = !nodes_are_ordered
    document.getElementById("order_lr_tb").disabled = !nodes_are_ordered

    document.getElementById("via_undirected_edges").disabled = (edges.size + ultraEdges.size > 0 || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_directed_edges").disabled = (edges.size + ultraEdges.size > 0 || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_undirected_edges").checked = (edge_type == TYPE_UNDIRECTED)
    document.getElementById("via_directed_edges").checked = (edge_type == TYPE_DIRECTED)
    
    submitButton = document.getElementById("grid_submit_button")
    if(!gridDialogHasEventListeners) {
        submitButton.addEventListener('click',(event) => {
            captureGridDialogDetails(event)
        });
        dialog.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                gridDailogCancelHandler()
            }
            else if(event.key === 'Enter' || event.keyCode === 13) {
                captureGridDialogDetails(event)
            }
        });
        gridDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
  }

  function areThereEmbddedEdgesOrUltraEdges() {
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.inner_edges.size > 0 || icoGroup.inner_ultraEdges.size > 0) {
            return true
        }
        else {
            nestedIcos = getAllNestedIconizedGroups(icoGroup)
            for(let i of nestedIcos) {
                if(i.inner_edges.size > 0 || i.inner_ultraEdges.size > 0) {
                    return true
                }
            }
        }
    }

    return false
  }

  async function captureNewGameDialogDetails(event) {
    console.log("submit requested")
    let num_rounds = Number(document.getElementById("num_rounds").value)
    if(isNaN(Number(num_rounds)) || num_rounds <= 0) {
        beep()
        document.getElementById("num_rounds").focus()
        event.preventDefault()
        return
    }
    let comp_spoiler = document.getElementById("comp_spoiler").checked
    let comp_duplicator = document.getElementById("comp_duplicator").checked
    //let comp_analysis = document.getElementById("comp_analysis").checked
    console.log("num_rounds = " + num_rounds)
    console.log("comp_spoiler = " + comp_spoiler)
    console.log("comp_duplicator = " + comp_duplicator)
    //console.log("comp_analysis = " + comp_analysis)

    const newWindow = window.open("ef_game_play.html", '_blank', width=window.innerWidth,height=window.innerHeight)
    await delay(250); 
    let additional_stuff = "\"num_rounds\": " + num_rounds + ",\n"
    additional_stuff += "\"comp_spoiler\": " + comp_spoiler + ",\n"
    additional_stuff += "\"comp_duplicator\": " + comp_duplicator //+ ",\n"
    //additional_stuff += "\"comp_analysis\": " + comp_analysis + "\n"
    newWindow.postMessage(getGameJSON(additional_stuff), '*'); //need to also pass the collected parameters!
  }

  function newGameDailogCancelHandler() {
    console.log("User requested to cancel The new game request!")
  }

  newGameDialogHasEventListeners = false  //the usual cluge
  function requestNewGame() {
    console.log("Requested New Game....")
    let dialog = document.getElementById("new_game_dialog")
    
    submitButton = document.getElementById("new_game_submit_button")
    if(!newGameDialogHasEventListeners) {
        submitButton.addEventListener('click',(event) => {
            captureNewGameDialogDetails(event)
        });
        dialog.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                newGameDailogCancelHandler()
            }
            else if(event.key === 'Enter' || event.keyCode === 13) {
                captureNewGameDialogDetails(event)
            }
        });
        newGameDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
  }

  cycleDialogHasEventListeners = false  //again a bit clugey, but....
  function requestInsertCycle() {
    console.log("Requested Insert Cycle....")
    const dialog = document.getElementById("cycle_dialog")
    document.getElementById("via_undir_edges").disabled = (edges.size + ultraEdges.size > 0  || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_dir_edges").disabled = (edges.size + ultraEdges.size > 0  || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_undir_edges").checked = (edge_type == TYPE_UNDIRECTED)
    document.getElementById("via_dir_edges").checked = (edge_type == TYPE_DIRECTED)
    
    submitButton = document.getElementById("cycle_submit_button")
    if(!cycleDialogHasEventListeners) {
        submitButton.addEventListener('click',(event) => {
            captureCycleDialogDetails(event)
        });
        dialog.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                cycleDailogCancelHandler()
            }
            else if(event.key === 'Enter' || event.keyCode === 13) {
                captureCycleDialogDetails(event)
            }
        });
        cycleDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
  }

  function cycleDailogCancelHandler() {
    console.log("cancel requested")
  }

  function captureCycleDialogDetails(event) {
    console.log("submit requested")
    let height = Number(document.getElementById("height").value)
    let width = Number(document.getElementById("width").value)
    let num_nodes = Number(document.getElementById("num_nodes").value)
    if(document.getElementById("via_undir_edges").checked) {
        edge_type = TYPE_UNDIRECTED
    }
    else {
        edge_type = TYPE_DIRECTED
    }
    res = sanityCheckCycleDialogEntries(height, width, num_nodes, event)
    if(res) {
        renderCycleOfNodes(height, width, num_nodes)
        clearSelection()
    } 
    else {
        event.preventDefault()
    }
  } 

  function sanityCheckCycleDialogEntries(height, width, num_nodes, event) {
    if(num_nodes < 3) {
        alert("# nodes must be at least 3!")
        document.getElementById("num_nodes").focus()
        return false
    }
    if(Math.ceil(num_nodes/2)*NODE_DRAW_RADIUS > Math.max(height,width)) {
        alert("Not enough pixels to accomodate requested number of nodes!")
        document.getElementById("height").focus()
        return false
    }

    //now verify that we have room for the new nodes!
    left_edge = contextMenuClickPoint.x - width/2 - NODE_DRAW_RADIUS
    right_edge = left_edge + width + 2*NODE_DRAW_RADIUS
    top_edge = contextMenuClickPoint.y - height/2 - NODE_DRAW_RADIUS
    bottom_edge = top_edge + height + 2*NODE_DRAW_RADIUS

    return validateSpaceForNodes(left_edge, right_edge, top_edge, bottom_edge)
}

function renderCycleOfNodes(height, width, num_nodes) {
    console.log("Would be rendering a cycle of " + num_nodes + " nodes.")
    //first create nodes
    let new_nodes = []
    let new_edges = []
    let x = contextMenuClickPoint.x
    let y = contextMenuClickPoint.y
    let p_x = p_y = 0
    if(num_nodes % 2 == 1) {
        if(width >= height) {
            p_x = x - width/2
            p_y = y
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=0; i<(num_nodes-1)/2; i++) {
                p_x = x - width/2 + (i+1)*width/((num_nodes-1)/2)
                p_y = y - height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            for(i = (num_nodes-3)/2; i>=0; i--) {
                p_x = x - width/2 + (i+1)*width/((num_nodes-1)/2)
                p_y = y + height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
        else {
            p_x = x
            p_y = y - height/2
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=0; i<(num_nodes-1)/2; i++) {
                p_x = x - width/2
                p_y = y - height/2 + (i+1)*height/((num_nodes-1)/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            for(i = (num_nodes-3)/2; i>=0; i--) {
                p_x = x + width/2
                p_y = y - height/2 + (i+1)*height/((num_nodes-1)/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
    }
    else {
        if(width >= height) {
            p_x = x - width/2
            p_y = y
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=1; i<num_nodes/2; i++) {
                p_x = x - width/2 +i*width/(num_nodes/2)
                p_y = y - height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            p_x = x + width/2
            p_y = y
            node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(i = (num_nodes/2) - 1; i>=1; i--) {
                p_x = x - width/2 + i*width/(num_nodes/2)
                p_y = y + height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
        else {
            p_x = x
            p_y = y - height/2
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=1; i<num_nodes/2; i++) {
                p_x = x - width/2
                p_y = y - height/2 + i*height/(num_nodes/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            p_x = x
            p_y = y + height/2
            node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(i = (num_nodes/2) - 1; i>=1; i--) {
                p_x = x + width/2
                p_y = y - height/2 + i*height/(num_nodes/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
    }
    for(i = 0; i<new_nodes.length - 1; i++) {
        let edge = new Edge(new_nodes[i], new_nodes[i+1])
        create_edge(edge)
    }
    edge = new Edge(new_nodes[new_nodes.length - 1], new_nodes[0])
    create_edge(edge)
    redrawAll()
}



  function getOS() {
    const platform = navigator.platform;
    if (platform.startsWith('Win')) {
        return 'Windows';
    } else if (platform.startsWith('Mac')) {
        return 'macOS';
    } else if (platform.startsWith('Linux')) {
        return 'Linux';
    } else if (platform.startsWith('X11')) {
        return 'UNIX';
    } else if (platform.startsWith('iPhone') || platform.startsWith('iPad') || platform.startsWith('iPod')) {
        return 'iOS';
    } else if (platform.startsWith('Android')) {
        return 'Android';
    }
    return 'Unknown OS';
  }

  function getBrowser() {
    const userAgent = navigator.userAgent;
    if (userAgent.indexOf("Edg") > -1) {
        return "Microsoft Edge";
    } else if (userAgent.indexOf("Chrome") > -1) {
        return "Chrome";
    } else if (userAgent.indexOf("Firefox") > -1) {
        return "Firefox";
    } else if (userAgent.indexOf("Safari") > -1) {
        return "Safari";
    } else if (userAgent.indexOf("Opera") > -1) {
        return "Opera";
    } else if (userAgent.indexOf("Trident") > -1 || userAgent.indexOf("MSIE") > -1) {
        return "Internet Explorer";
    }
    return "Unknown";
  }

</script>

<style>
  .mainMenu {
    display: grid;
    grid-template-columns: auto auto;
    grid-gap: 10px;
  }

  .shortcut {
    text-align: right;
    min-width: 80px; /* Adjust as needed */
  }

    #contextMenu {
        display: none;
        position: fixed;
        background-color: #f9f9f9;
        border: 1px solid #ccc;
        padding: 5px 0;
        min-width: 100px;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 1000;
    }

    #contextMenu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #contextMenu li {
        padding: 8px 15px;
        cursor: pointer;
    }

    #contextMenu li:hover {
        background-color: #e1e1e1;
    }

    #selfLoopMenu {
        display: none;
        position: fixed;
        background-color: #f9f9f9;
        border: 1px solid #ccc;
        padding: 5px 0;
        min-width: 100px;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 1000;
    }

    #selfLoopMenu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #selfLoopMenu li {
        padding: 8px 15px;
        cursor: pointer;
    }

    #selfLoopMenu li:hover {
        background-color: #e1e1e1;
    }

    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      background-color: #f0f0f0;  /**Gives the top menu its background color **/
      display: flex;
    }

    nav li {
      margin-right: 10px;  /** Controls the padding between top menu items **/
      font-family: Arial, Helvetica, sans-serif;
      font-weight: Bold;
      font-size: 12pt;
    }

    nav a {
      display: block;
      padding: 6px;  /** Controls the padding all around top menu items (top, bottom, left, right) **/
      text-decoration: none;
      color: #333;
    }
</style>


</body>
</html>