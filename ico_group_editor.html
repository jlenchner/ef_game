
<!DOCTYPE html>
<html>
<body>

<div id="contextMenu">
    <ul>
    </ul>
</div>

<div id="selfLoopMenu">
    <ul>
    </ul>
</div>

<dialog id="grid_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="grid_form">
    <table cellpadding="3">
    <tr><td colspan="2" align="center"># Rows: <input type="text" id="num_rows" size=3 value="3">&nbsp;&nbsp;&nbsp;# Columns: <input id="num_cols" type="text" size=3 value="3"></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" colspan="2">Pixel separation: <input id="separation" value="30" size=3 align="right">&nbsp;&nbsp;&nbsp;(Minimum 20)</td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" colspan="2"><input type="checkbox" id="l1_connect" name="l1_connect" value="yes" checked> L1 connect nodes</td></tr>
    <tr><td colspan="2"><input type="radio" id="via_undirected_edges" name="edge_dir" value="undirected" checked><label>Via Undirected Edges</label><input type="radio" id="via_directed_edges" name="edge_dir" value="directed"><label>Via Directed Edges</label></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" rowspan="2">Order:</td><td><input type="radio" id="order_tb_lr" name="order" value="order_tb_lr" checked><label>Top to Bottom, then Left to Right</label></td></tr>
    <tr><td><input type="radio" id="order_lr_tb" name="order" value="order_lr_tb"><label>Left to Right, then Top to Bottom</label></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td colspan="2" align="center"><input type="Submit" id="grid_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="gridDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<dialog id="cycle_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="cycle_form">
    <table cellpadding="3">
    <tr><td colspan="2" align="center">Height (in pixels): <input type="text" id="height" size=4 value="100">&nbsp;&nbsp;&nbsp;Width (in pixels): <input id="width" type="text" size=4 value="100"></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td align="center" colspan="2"># of Nodes: <input id="num_nodes" value="10" size=3 align="right"></td></tr>
    <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td colspan="2">Connect via: <input type="radio" id="via_undir_edges" name="edge_dir" value="undirected" checked><label>Undirected Edges</label><input type="radio" id="via_dir_edges" name="edge_dir" value="directed"><label>Directed Edges</label></td></tr>
     <tr><td colspan="2">&nbsp;</td></tr>
    <tr><td colspan="2" align="center"><input type="Submit" id="cycle_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="cycleDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<dialog id="iconization_dialog">
    <style>
        input {
            text-align: right;
        }
    </style>
  <form method="dialog" id="iconization_form">
    <table cellpadding="3">
    <tr><td align="left" colspan="2">Iconize to a (an): &nbsp;&nbsp;<select id="n_gon" onchange="redrawSamplePolygon()"><option value="3">Equilateral Triangle</option><option value="4">Square</option><option value="5">Regular Pentagon</option><option value="6">Regular Hexagon</option><option value="7">Regular Heptagon</option><option value="8">Regular Octagon</option></select></td></tr>
    <!--<tr><td colspan="2">&nbsp;</td></tr>-->
    <tr><td align="left" colspan="2">Circumcircle radius: <select id="radius" onchange="redrawSamplePolygon()"><option value="20">20</option><option value="25">25</option><option value="30">30</option><option value="35">35</option><option value="40">40</option></select>&nbsp;&nbsp;pixels</td></tr>
    <tr><td align="left" colspan="2">Fill color:</td></tr>
    </table>

    <table cellpadding="6">
    <tr>
    <td><input type="radio" id="color" name="color" value="cyan"  onclick="redrawSamplePolygon()" checked/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="cyan"/>
    </svg>
    <td><input type="radio" id="color" name="color" value="chartreuse" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="chartreuse"/>
    </svg>
    </td>
    <td><input type="radio" id="color" name="color" value="orange" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="orange"/>
    </svg>
    </td>
    </tr>

    <tr>
    <td><input type="radio" id="color" name="color" value="brown" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="brown"/>
    </svg>
    <td><input type="radio" id="color" name="color" value="purple" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="purple"/>
    </svg>
    </td>
    <td><input type="radio" id="color" name="color" value="grey" onclick="redrawSamplePolygon()"/></td>
    <td>
    <svg width="40" height="30">
        <rect width="100%" height="100%" x="0" y="0" rx="0" ry="0" fill="grey"/>
    </svg>
    </td>
    </tr>
    </table>
    <table>
    <tr><td colspan=3>Label (3 chars max):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="text" id="label" style="text-align: center;" size=3 maxlength=3 value="" oninput="redrawSamplePolygon()"> </td></tr>    
    </table>
    <table width="100%">
    <canvas id="iconization-canvas" width="270" height="100"></canvas>
    <tr><td colspan="2" align="center"><input type="Submit" id="ico_submit_button" style="font-weight:bold;" value="OK">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button onClick="iconizationDailogCancelHandler();">Cancel</button></td></tr>
    </table>
  </form>
</dialog>

<nav id="topMenu"></nav>

<canvas id="mainCanvas"></canvas> 
<script>

document.body.style.overflow = 'hidden'; //prevents coordinate problems when scrolling


class Rectangle {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
}

nodes = new Set()
edges = new Set()
iconizedGroups = new Set() 
ultraEdges = new Set()

innerIconizedGroups = new Set()

all_nodes = new Set()
all_edges = new Set()

selected_nodes = new Set()
selected_edges = new Set()
selected_ultraEdges = new Set()
selected_iconizedGroups = new Set()

copied_nodes = new Set()
copied_edges = new Set()

active_grouping_rectangle = undefined
exists_side_grouping_control_point = undefined //if the grouping box spans both sides, this is the x-coord of the right-most node on the left side
forall_side_grouping_control_point = undefined //if the grouping box spans both sides, this is the x-coord of the left-most node on the right side
GROUPING_BOX_BUFFER = 15        //number of pixels beyond the most extreme nodes to draw bounding rectangle
group_processing_active = false   //turned to true when user chooses to iconize group

const NODE_DRAW_RADIUS = 5
const NODE_CLICK_TOLERANCE = 7  //how close to center of node you have to be to count as having clicked on it
const EDGE_CLICK_TOLERANCE = 20  //how close to center of edge you have to be to count as having clicked on it
const EDGE_WIDTH = 2

const ARROW_OFFSET_PCT = 0.60  //On directed edges, how far from from-node1 to node2 to place arrow.
                               //SHOULD NOT BE USED DIRECTLY!! Call getSmartArrowOffsetPct(edge) instead.
const ARROW_HEAD_LENGTH = 15   //Pixels of headlength in a directed edge arrow

const EXISTS_SIDE = -1
const FORALL_SIDE = -2
const BOTH_SIDES = -3

which_side = undefined
move = undefined

//TOP_BUFFER = 30  //Clicks in this region are ignored
NAV_BAR_MARGIN = 30
TOP_BUFFER = 2   //Clicks above here are ignored (does not count nav bar pixels)
BOTTOM_BUFFER = 5  //Clicks below here are ignored

node_id_counter = 1
nodes_are_ordered = false  //the default
orderings_are_being_displayed = false
const ORDERING_BOX_OFFSET_X = -15   //determines how the ordering boxes are offset from the node centers
const ORDERING_BOX_OFFSET_Y = NAV_BAR_MARGIN + 15
const CONSTANT_BOX_OFFSET_X = 10
const CONSTANT_BOX_OFFSET_Y = NAV_BAR_MARGIN - 22 // NAV_BAR_MARGIN -18 
const CONSTANT_BOX_WIDTH = 22
const CONSTANT_BOX_HEIGHT = 15
const CONSTANT_FLAGPOLL_TOP_OFFSET = CONSTANT_BOX_OFFSET_Y + 7
node_id_to_inputBox_map = new Map()
const NO_ORDER = -999999
node_id_to_constantBox_map = new Map()

iconizedGroup_id_counter = 1

const INFINITE = 999999

constants_in_use_on_left = new Set()
constants_in_use_on_right = new Set()
in_use_constants = new Set()

CANVAS_WIDTH = window.screen.width  
CANVAS_HEIGHT = window.screen.height 

const canvas = document.getElementById('mainCanvas');
canvas.width = CANVAS_WIDTH
canvas.height = CANVAS_HEIGHT
const ctx = canvas.getContext('2d');

page_is_frozen = false
child_window = undefined
icoGroup_being_edited = undefined
dont_send_cancel_on_close = false  //turns to true when we send a close when user hits the Submit button

DIVIDING_LINE_BUFFER = 10  //Clicks in this region are ignored (does not count dividing line width)
DIVIDING_LINE_LOC = CANVAS_WIDTH/2

DISK_COLOR = "black"
EDGE_COLOR = "black"
NODE_SELECT_COLOR = "red"
UNSELECT_COLOR = "white"
EDGE_SELECT_COLOR = "lime"
ICONIZED_GROUP_SELECT_COLOR = "DodgerBlue"

TYPE_UNDIRECTED = -1
TYPE_DIRECTED = -2

edge_type = TYPE_UNDIRECTED //the default

ctx.imageSmoothingEnabled = false; 

isDragging = false   //is user dragging the mouse
cutPending = false   //set to true if there is a cut pending rather than a copy

const SPOILER_MOVE = 0
const DUPLICATOR_MOVE = 1
round_counter = 1
whose_move = SPOILER_MOVE
move_queue = []
redo_queue = []
pre_move_queue = []  //these are just "moves" on constants
last_side_played = BOTH_SIDES //not relevant at the start of the game
num_rounds = INFINITE

const MOVE_BG_COLORS = ["red", "blue", "green", "yellow"]
const MOVE_TEXT_COLORS = ["white", "white", "white", "black"]

drawDividingLine()

const contextMenuDiv = document.getElementById('contextMenu');
const contextMenuList = contextMenuDiv.querySelector('ul');
const selfLoopMenuDiv = document.getElementById('selfLoopMenu');
const selfLoopMenuList = selfLoopMenuDiv.querySelector('ul');

contextMenuClickPoint = undefined  //gets where the context menu click was in case it is needed by submenus

SELF_LOOP_RADIUS = 15   //radius in pixels for drawing self-loops
//directions for drawing self-loops
DIR_NONE = -1
DIR_UP = 0
DIR_RIGHT = 1
DIR_DOWN = 2
DIR_LEFT = 3

const menuItems = ["I"];  //no real menu bar
const nav = document.getElementById("topMenu");
const ul = document.createElement("ul");
menuItems.forEach(itemText => {
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.textContent = itemText;
    li.appendChild(a);
    ul.appendChild(li);
});
nav.appendChild(ul);

function getZoomLevel() {
    return Math.round(window.devicePixelRatio * 100);
  }

function scaleNodeToZoomLevel(parentZoomLevel, ourZoomLevel, node) {  //This is not working properly. Scales to uniform position on the screen regardless of zoom
    if(parentZoomLevel != ourZoomLevel) {
        node.x *= (parentZoomLevel/ourZoomLevel)
        node.y *= (parentZoomLevel/ourZoomLevel)
    }
}

function fetchById(id, setOfObjects) {
    for(let ob of setOfObjects) {
        if(ob.id == id) {
            return ob
        }
    }

    return undefined
}

function createExplodedGraph(nodes, edges, iconizedGroups, ultraEdges, innerIconizedGroups) {
    all_OneLevelNodes = new Set(nodes)  //accumulate these
    all_OneLevelEdges = new Set(edges)  //accumulate these
    all_OneLevelUltraEdges = new Set()  //just the new ones
    all_OneLevelIconizedGroups = new Set() //just the new ones

    for(let icoGroup of iconizedGroups) {
        //recenterIcoGroupContents(icoGroup)   //should be done within this side
        let coerced_inner_nodes = new Set()
        for(let node of icoGroup.inner_nodes) {
            coerced_inner_nodes.add(coerceToNode(node))
        }
        let coerced_inner_edges = new Set()
        for(let edge of icoGroup.inner_edges) {
            edge = coerceToEdge(edge)
            edge.node1 = fetchById(edge.node1.id, coerced_inner_nodes)
            edge.node2 = fetchById(edge.node2.id, coerced_inner_nodes)
            edge.node1.edges.add(edge)
            edge.node2.edges.add(edge)
            coerced_inner_edges.add(coerceToEdge(edge))
        }
        let coerced_inner_iconizedGroups = new Set()
        for(let i of icoGroup.inner_iconizedGroups) {
            let trueIcoGroup = fetchById(i.id, innerIconizedGroups) //these are already coerced
            coerced_inner_iconizedGroups.add(trueIcoGroup)
        }
        let coerced_inner_ultraEdges = new Set()  
        for(let ultraEdge of icoGroup.inner_ultraEdges) {
            ultraEdge = coerceToUltraEdge(ultraEdge)
            if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                ultraEdge.obj1 = fetchById(ultraEdge.obj1.id, coerced_inner_iconizedGroups)
            }
            else {
                ultraEdge.obj1 = fetchById(ultraEdge.obj1.id, coerced_inner_nodes)
            }
            ultraEdge.obj1.ultraEdges.add(ultraEdge)
            if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                ultraEdge.obj2 = fetchById(ultraEdge.obj2.id, coerced_inner_iconizedGroups)
            }
            else {
                ultraEdge.obj2 = fetchById(ultraEdge.obj2.id, coerced_inner_nodes)
            }
            ultraEdge.obj2.ultraEdges.add(ultraEdge)
            coerced_inner_ultraEdges.add(coerceToUltraEdge(ultraEdge))
        }
        
        all_OneLevelNodes = all_OneLevelNodes.union(coerced_inner_nodes)
        all_OneLevelEdges = all_OneLevelEdges.union(coerced_inner_edges)
        all_OneLevelUltraEdges = all_OneLevelUltraEdges.union(coerced_inner_ultraEdges)
        all_OneLevelIconizedGroups = all_OneLevelIconizedGroups.union(coerced_inner_iconizedGroups)
    }
    for(let ultraEdge of ultraEdges) {
        if(!ultraEdge.obj1.hasOwnProperty("num_sides")) {  //obj2 must be an icoGroup
            for(let node of ultraEdge.obj2.inner_nodes) {
                let edge = new Edge(ultraEdge.obj1, node)
                all_OneLevelEdges.add(edge)
            }
            for(let icoGroup of ultraEdge.obj2.inner_iconizedGroups) {
                let trueIcoGroup = fetchById(icoGroup.id, innerIconizedGroups) 
                let u = new UltraEdge(ultraEdge.obj1, trueIcoGroup)
                all_OneLevelUltraEdges.add(u)
            }
        }
        else if(!ultraEdge.obj2.hasOwnProperty("num_sides")) {  //obj1 must be an icoGroup
            for(let node of ultraEdge.obj1.inner_nodes) {
                let edge = new Edge(node, ultraEdge.obj2)
                all_OneLevelEdges.add(edge)
            }
            for(let icoGroup of ultraEdge.obj1.inner_iconizedGroups) {
                let trueIcoGroup = fetchById(icoGroup.id, innerIconizedGroups)
                let u = new UltraEdge(trueIcoGroup, ultraEdge.obj2)
                all_OneLevelUltraEdges.add(u)
            }
        }
        else { //both obj1 and obj2 are icoGroups
            for(let node of ultraEdge.obj1.inner_nodes) {
                for(let n of ultraEdge.obj2.inner_nodes) {
                    let edge = new Edge(node, n)
                    all_OneLevelEdges.add(edge)
                }
                for(let i of ultraEdge.obj2.inner_iconizedGroups) {
                    let trueIcoGroup = fetchById(i.id, innerIconizedGroups)
                    let u = new UltraEdge(node, trueIcoGroup)
                    all_OneLevelUltraEdges.add(u)
                }
            }
            for(let icoGroup of ultraEdge.obj1.inner_iconizedGroups) {
                trueIcoGroup = fetchById(icoGroup.id, innerIconizedGroups)
                for(let n of ultraEdge.obj2.inner_nodes) {
                    let u = new UltraEdge(trueIcoGroup, n)
                    all_OneLevelUltraEdges.add(u)
                }
                for(let i of ultraEdge.obj2.inner_iconizedGroups) {
                    trueIcoGroup2 = fetchById(i.id, innerIconizedGroups)
                    let u = new UltraEdge(trueIcoGroup, trueIcoGroup2)
                    all_OneLevelUltraEdges.add(u)
                }
            }
        }
        
    }

    //remove duplicates
    let all_id_to_node_map = new Map()
    for(let node of all_OneLevelNodes) {
        let prior_node = all_id_to_node_map.get(node.id)
        if(prior_node == undefined) {
            all_id_to_node_map.set(node.id, node)
        }
    }
    all_OneLevelNodes = new Set(all_id_to_node_map.values())

    OneLevelInnerIconizedGroups = new Set(innerIconizedGroups)
    OneLevelInnerIconizedGroups.delete(all_OneLevelIconizedGroups) 

    if(all_OneLevelIconizedGroups.size > 0) {
        createExplodedGraph(all_OneLevelNodes, all_OneLevelEdges, all_OneLevelIconizedGroups,
            all_OneLevelUltraEdges, OneLevelInnerIconizedGroups)
    }
    else {
        all_nodes = all_OneLevelNodes
        all_edges = all_OneLevelEdges
        safelyRecreateAllNodesAndAllEdges()
    }
    
}

//important to do this so the nodes and edges in all_nodes and all_edges are not mixed up with the real ones!!
function safelyRecreateAllNodesAndAllEdges() {
    id_to_all_nodes_map = new Map()
    let safe_all_nodes = new Set()
    let safe_all_edges = new Set()
    for(let node of all_nodes) {
        let safe_node = structuredNodeClone(node)
        safe_node.edges = new Set()
        safe_node.ultraEdges = new Set()
        safe_all_nodes.add(safe_node)
        id_to_all_nodes_map.set(safe_node.id, safe_node)
    }

    for(let edge of all_edges) {
        let node1 = id_to_all_nodes_map.get(edge.node1.id)
        let node2 = id_to_all_nodes_map.get(edge.node2.id)
        let safe_edge = new Edge(node1, node2, edge.dir)
        safe_all_edges.add(safe_edge)
        node1.edges.add(safe_edge)
        node2.edges.add(safe_edge)
    }

    all_nodes = safe_all_nodes
    all_edges = safe_all_edges
}

function getVisibleParent(object) {
    console.log("getting visible parent of object id = " + object.id)
    if(!object.hasOwnProperty("parent") || object.parent == undefined) {
        console.log("Check 1. Returning object.id = " + object.id)
        return object
    }
    else {
        visibleParent = fetchById(object.parent.id, iconizedGroups)
        if(visibleParent != undefined) {
            console.log("Check 2. Returning parent with object.id = " + visibleParent.id)
            return visibleParent
        }
        else {
            return getVisibleParent(object.parent)
        }
    }
}

function findInnerNodeById(id) {
    for(let icoGroup of iconizedGroups) {
        for(let node of icoGroup.inner_nodes) {
            if(node.id == id) {
                return node
            }
        }
    }

    for(let icoGroup of innerIconizedGroups) {
        for(let node of icoGroup.inner_nodes) {
            if(node.id == id) {
                return node
            }
        }
    }

    return undefined
}

function computeAllParents() {
    for(let icoGroup of innerIconizedGroups) {
        for(let node of icoGroup.inner_nodes) {
            node.parent = icoGroup
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            correctInnerIcoGroup = fetchById(i.id, innerIconizedGroups)
            correctInnerIcoGroup.parent = icoGroup
            i.parent = icoGroup
        }
    }

    for(let icoGroup of iconizedGroups) {
        for(let node of icoGroup.inner_nodes) {
            node.parent = icoGroup
        }
        //correctInnerIcoGroups = new Set()
        for(let i of icoGroup.inner_iconizedGroups) {
            correctInnerIcoGroup = fetchById(i.id, innerIconizedGroups)
            //correctInnerIcoGroups.add(correctInnerIcoGroup)  //if these are corrected would have to also correct inner_ultraEdges!
            correctInnerIcoGroup.parent = icoGroup   
            i.parent = icoGroup
        }
    }
}

function removeAllParents() {
    for(let icoGroup of innerIconizedGroups) {
        for(let node of icoGroup.inner_nodes) {
            node.parent = undefined
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            correctInnerIcoGroup = fetchById(i.id, innerIconizedGroups)
            correctInnerIcoGroup.parent = undefined
            i.parent = undefined
        }
    }

    for(let icoGroup of iconizedGroups) {
        for(let node of icoGroup.inner_nodes) {
            node.parent = undefined
        }
        //correctInnerIcoGroups = new Set()
        for(let i of icoGroup.inner_iconizedGroups) {
            correctInnerIcoGroup = fetchById(i.id, innerIconizedGroups)
            //correctInnerIcoGroups.add(correctInnerIcoGroup)  //if these are corrected would have to also correct inner_ultraEdges!
            if(correctInnerIcoGroup != undefined) {   //this can happen if user created icoGroups within icoGroups in the editor
                correctInnerIcoGroup.parent = undefined   
                i.parent = undefined
            }
        }
    }
}

async function ricochetMessageUp(msg) {  //this method should not be used (an artifact of ef_game_play_popup.html)
    await delay(1000); 
    window.opener.postMessage(msg, '*');   
    window.close();  //comment this out to debug
}

function handleIcoGroupPopupEdit(icoGroupObject) {
    unfreezePage()
    child_window = undefined
    console.log("Back from a commited change to an embedded icoGroup!")
    //do processing
    node_id_counter = icoGroupObject.node_id_counter
    iconizedGroup_id_counter = icoGroupObject.iconizedGroup_id_counter

    icoGroup_being_edited = undefined
}

window.addEventListener("message",(event) => {    //Sets up the icoGroup to edit based on the passed in JSON
    console.log(event.data)

    const icoGroupObject = JSON.parse(event.data);
    if(icoGroupObject.hasOwnProperty("cancel")) {
        console.log("received cancel message")
        unfreezePage()
        icoGroup_being_edited = undefined
        child_window = undefined
        return
    }
    else if(icoGroupObject.hasOwnProperty("die")) {
        sendDieMessageDown()
        window.close();
        return
    }
    else if(icoGroup_being_edited != undefined) {
        handleIcoGroupPopupEdit(icoGroupObject)
    }
    parentZoomLevel = icoGroupObject.zoom_level
    ourZoomLevel = getZoomLevel() //not doing anything with this currently

    round_counter = icoGroupObject.round_counter  //not used
    //these next are key
    node_id_counter = icoGroupObject.node_id_counter
    iconizedGroup_id_counter = icoGroupObject.iconizedGroup_id_counter

    which_side = icoGroupObject.which_side
    if(which_side == EXISTS_SIDE) {
        existsButton.src = 'exists_button.png';
    }
    else {
        existsButton.src = 'forall_button.png';
    }

    in_use_constants = new Set(icoGroupObject.in_use_constants)

    center_x = icoGroupObject.center_x
    center_y = icoGroupObject.center_y
    if(icoGroupObject.edge_type == "directed") {
        edge_type = TYPE_DIRECTED
    }
    else {
        edge_type = TYPE_UNDIRECTED
    }
    nodes_are_ordered = icoGroupObject.node_ordering
    if(nodes_are_ordered) {
        orderings_are_being_displayed = true  //default to starting out showing them
    }
    max_id = 0
    for(let i=0; i<icoGroupObject.nodes.length; i++) {
        n = icoGroupObject.nodes[i]
        node = new Node(n.x, n.y, n.id, n.constant)
        //scaleNodeToZoomLevel(parentZoomLevel, ourZoomLevel, node)
        node.order = n.order
        nodes.add(node)
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        if(orderings_are_being_displayed) {
            if(node.order != NO_ORDER) {
                orderInputBox.value = node.order
            }
            else {
                orderInputBox.value = ''
            }
            orderInputBox.style.display = "initial"
        }
        else {
            orderInputBox.style.display = "none"
        }
        if(node.constant != '') {
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
    }
    
    for(let i=0; i<icoGroupObject.edges.length; i++) {
        nodeId1 = icoGroupObject.edges[i].node1.id
        node1 = getNodeById(nodeId1)
        nodeId2 = icoGroupObject.edges[i].node2.id
        node2 = getNodeById(nodeId2)
        dir = icoGroupObject.edges[i].dir
        edge = new Edge(node1, node2, dir)
        node1.edges.add(edge)
        node2.edges.add(edge)
        edges.add(edge)
    }

    count_left_side_nodes = 0
    count_right_side_nodes = 0
    for(let node of nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            count_left_side_nodes++
        }
        else {
            count_right_side_nodes++
        }
    }
    for(let i=0; i<icoGroupObject.iconizedGroups.length; i++) {
        iconizedGroups.add(coerceToIconizedGroup(icoGroupObject.iconizedGroups[i]))
    }
    for(let i=0; i<icoGroupObject.ultraEdges.length; i++) {
        if(icoGroupObject.ultraEdges[i].obj1.hasOwnProperty("num_sides")) {
            icoGroupObject.ultraEdges[i].obj1 = getIconoizedGroupById(icoGroupObject.ultraEdges[i].obj1.id)
        }
        else {
            icoGroupObject.ultraEdges[i].obj1 = getNodeById(icoGroupObject.ultraEdges[i].obj1.id)
        }
        if(icoGroupObject.ultraEdges[i].obj2.hasOwnProperty("num_sides")) {
            icoGroupObject.ultraEdges[i].obj2 = getIconoizedGroupById(icoGroupObject.ultraEdges[i].obj2.id)
        }
        else {
            icoGroupObject.ultraEdges[i].obj2 = getNodeById(icoGroupObject.ultraEdges[i].obj2.id)
        }
        icoGroupObject.ultraEdges[i] = coerceToUltraEdge(icoGroupObject.ultraEdges[i])
        ultraEdges.add(icoGroupObject.ultraEdges[i])
        icoGroupObject.ultraEdges[i].obj1.ultraEdges.add(icoGroupObject.ultraEdges[i])
        icoGroupObject.ultraEdges[i].obj2.ultraEdges.add(icoGroupObject.ultraEdges[i])  
    }
    for(let i=0; i<icoGroupObject.innerIconizedGroups.length; i++) {
        innerIcoGroup = coerceToIconizedGroup(icoGroupObject.innerIconizedGroups[i])
        innerIconizedGroups.add(innerIcoGroup)
    }
    //num_rounds = Math.min(count_left_side_nodes, count_right_side_nodes)
    //inputNumRds.value = num_rounds

    centerObjectsWithRespectToExplodedIcoGroup(center_x, center_y)

    createExplodedGraph(nodes, edges, iconizedGroups, ultraEdges, innerIconizedGroups) 
    computeAllParents()  

    move_queue = []

    redrawAll()
    //reportIfGameDecided()

 },false);


 document.addEventListener('keydown', function(event) {
    if(page_is_frozen) {
        return
    }
    if(event.key == "t") {  //for debug purposes only!!
        console.log("received a t... for testing!")
        let moveNode = findInnerNodeById(61)
        moveNode = coerceToNode(moveNode)
        console.log(moveNode.toJson())
        let visibleParent = getVisibleParent(moveNode)
        let loc = getMoveBoxDisplayLocforIcoGroup(visibleParent)
    }
    
  });

 function centerObjectsWithRespectToExplodedIcoGroup(center_x, center_y) {
    if(center_x > DIVIDING_LINE_LOC) {
        center_x -= DIVIDING_LINE_LOC
    }
    let topMost = canvas.height
    let leftMost = canvas.width
    let bottomMost = 0
    let rightMost = 0
    for(let node of nodes) {
        if(node.x < leftMost) {
            leftMost = node.x
        }
         if(node.x > rightMost) {
            rightMost = node.x
        }
        if(node.y < topMost) {
            topMost = node.y
        }
        if(node.y > bottomMost) {
            bottomMost = node.y
        }
    }
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.x < leftMost) {
            leftMost = icoGroup.x
        }
         if(icoGroup.x > rightMost) {
            rightMost = icoGroup.x
        }
        if(icoGroup.y < topMost) {
            topMost = icoGroup.y
        }
        if(icoGroup.y > bottomMost) {
            bottomMost = icoGroup.y
        }
    }
    prev_center_x = (leftMost + rightMost)/2
    prev_center_y = (topMost + bottomMost)/2

    for(let node of nodes) {
        node.x += (center_x - prev_center_x)
        node.y += (center_y - prev_center_y)
        if(orderings_are_being_displayed) {
            let orderingBox = node_id_to_inputBox_map.get(node.id)
            orderingBox.style.left  = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
            orderingBox.style.top  = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        }
        if(node.constant != '') {
            let constantBox = node_id_to_constantBox_map.get(node.id)
            constantBox.style.left  = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
            constantBox.style.top  = "" + (node.y + CONSTANT_BOX_OFFSET_Y) + "px"
        }
    }
    for(let icoGroup of iconizedGroups) {
        icoGroup.x += (center_x - prev_center_x)
        icoGroup.y += (center_y - prev_center_y)
    }
 }

 //pass icoGroup == undefined to get all constants in use on a given side
 function getConstantsInUseOnSide(side, icoGroup) {
    let constants = new Set()
    let setOfNodes = nodes  //replaced if icoGroup != undefined
    let setofIcoGroups = iconizedGroups //replaced if icoGroup != undefined
    if(icoGroup != undefined) {
        setOfNodes = icoGroup.inner_nodes
        setofIcoGroups = icoGroup.inner_iconizedGroups
    }
    for(let node of setOfNodes) {
        if((icoGroup == undefined && side == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) ||
            (icoGroup == undefined && side == FORALL_SIDE && node.x > DIVIDING_LINE_LOC) || 
            icoGroup != undefined) {
                if(node.constant != '') {
                    constants.add(node.constant)
                }
        }  
    }
    for(let i of setofIcoGroups) {
        if((icoGroup == undefined && side == EXISTS_SIDE && i.x < DIVIDING_LINE_LOC) ||
            (icoGroup == undefined && side == FORALL_SIDE && i.x > DIVIDING_LINE_LOC) || 
            icoGroup != undefined) {
                constants = constants.union(getConstantsInUseOnSide(side, i))
        }  
    }

    return constants
 }

function Point(x, y) {
  this.x = x;
  this.y = y;
}

function Segment(pt1, pt2) {
    this.pt1 = pt1
    this.pt2 = pt2
}

function Node(x, y, id=node_id_counter++, constant='', createOrderInputBox=true) {  //Note: this constructor includes the id, unlike the Node constructor in ef.html!!
    this.x = x
    this.y = y
    this.edges = new Set()
    this.ultraEdges = new Set()
    this.id = id
    this.constant = constant
    this.order = NO_ORDER
    this.parent = undefined  //parent icoGroup if any
    if(createOrderInputBox) {
        orderInputBox = createNodeOrderingBox(this)
        orderInputBox.style.display = "none"
    }
}

function structuredNodeClone(node) {  //does not create an ordering box
    let n0 = structuredClone(node)
    let n = new Node(n0.x, n0.y, n0.id, n0.constant, false)
    n.edges = n0.edges
    n.ultraEdges = n0.ultraEdges
    n.order = n0.order
    return n
  }

  function structuredNodesClone(nodes) {
    clone = new Set()
    for(let node of nodes) {
        clone.add(structuredNodeClone(node))
    }
    return clone
  }

  function structuredEdgeClone(edge) {
    let e0 = structuredClone(edge)
    let e = new Edge(e0.node1, e0.node2, e0.dir)
    return e
  }

  function structuredEdgesClone(edges) {
    clone = new Set()
    for(let edge of edges) {
        clone.add(structuredEdgeClone(edge))
    }
    return clone
  }

  function structuredIconizedGroupClone(icoGroup) {
    let i0 = structuredClone(icoGroup)
    let i = new IconizedGroup(i0.inner_nodes, i0.inner_edges, i0.inner_iconizedGroups, 
                i0.inner_ultraEdges, i0.ultraEdges, i0.x, i0.y, i0.num_sides, i0.radius, 
                i0.fill_color, i0.label)
    i.id = i0.id
    iconizedGroup_id_counter--
    
    return i
  }

  function structuredIconizedGroupsClone(icoGroups) {
    clone = new Set()
    for(let icoGroup of icoGroups) {
        clone.add(structuredIconizedGroupClone(icoGroup))
    }
    return clone
  }

  function structuredUltraEdgeClone(ultraEdge) {
    let u0 = structuredClone(ultraEdge)
    let u = new UltraEdge(u0.obj1, u0.obj2, u0.dir)
    return u
}

function structuredUltraEdgesClone(ultraEdges) {
    clone = new Set()
    for(let ultraEdge of ultraEdges) {
        clone.add(structuredUltraEdgeClone(ultraEdge))
    }
    return clone
}

Node.prototype.toJson = function() {
    return JSON.stringify({x: this.x, 
                           y: this.y,
                           id: this.id,
                           order: this.order,
                           constant: this.constant
    })
}

function Edge(node1, node2, dir=DIR_NONE) {  //all edges assumed to be of type edge_type, dir is just used to know how to draw self-loops
    this.node1 = node1
    this.node2 = node2
    this.dir = dir
}

Edge.prototype.toJson = function() {
    return JSON.stringify({node1: this.node1, 
                           node2: this.node2, 
                           dir: this.dir
    })
}

function IconizedGroup(inner_nodes, inner_edges, inner_iconizedGroups, inner_ultraEdges, ultraEdges, x, y, num_sides, radius, fill_color, label="") {
    this.inner_nodes = inner_nodes   
    this.inner_edges = inner_edges 
    this.inner_iconizedGroups = inner_iconizedGroups
    this.inner_ultraEdges = inner_ultraEdges
    this.ultraEdges = ultraEdges  

    this.x = x
    this.y = y
    this.num_sides = num_sides
    this.radius = radius
    this.fill_color = fill_color
    this.label = label
    this.id = iconizedGroup_id_counter++
    this.parent = undefined  //parent icoGroup if any
}

IconizedGroup.prototype.toJson = function() {
    return JSON.stringify({inner_nodes: Array.from(this.inner_nodes), 
                           inner_edges: Array.from(this.inner_edges),
                           inner_iconizedGroups: Array.from(this.inner_iconizedGroups),
                           inner_ultraEdges: Array.from(this.inner_ultraEdges),
                           x: this.x,
                           y: this.y,
                           num_sides: this.num_sides,
                           radius: this.radius,
                           fill_color: this.fill_color,
                           label: this.label,
                           id: this.id
    })
}

function UltraEdge(obj1, obj2, dir=DIR_NONE) {
    this.obj1 = obj1
    this.obj2 = obj2
    this.dir = dir  //just for drawing self-loops; currently unused
}

UltraEdge.prototype.toJson = function() {
    return JSON.stringify({obj1: this.obj1, 
                           obj2: this.obj2, 
                           dir: this.dir
    })
}

function arrayToJson(array) {
    json = "["
    for(i=0; i<array.length; i++) {
       json += array[i].toJson()
        if(i < array.length-1) {
            json += ","
        }
    }
    json += ']'
    return json
}

function Move(node, move_box, side_played, last_side_played) {  //last_side_played is the last_side_played at the time of making this move
    this.node = node
    this.move_box = move_box
    this.side_played = side_played
    this.last_side_played =  last_side_played
}

Move.prototype.toJson = function() {
    json = "{\"node\": " + this.node.toJson() + ", \"move_box\": " + 
        JSON.stringify(this.move_box) + ", \"side_played\": " +
        this.side_played + ", \"last_side_played\": " +
        this.last_side_played + "}"
    return json
}

function beep() {
    var snd = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");  
    snd.play();
}

function eraseCanvas(canvasId, x, y, width, height) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = "white"
  ctx.fillRect(x, y, width, height);
}

function drawDividingLine() {
    /*
    ctx.beginPath()
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.moveTo(DIVIDING_LINE_LOC, TOP_BUFFER);
    ctx.lineTo(DIVIDING_LINE_LOC, CANVAS_HEIGHT);
    ctx.stroke();
    ctx.closePath()
    */
}

function get_clicked_on_node(event) {
    x = event.clientX - canvas.offsetLeft
    y = event.clientY - canvas.offsetTop
    nodeList = Array.from(nodes)
    //can be very close nodes so find closest, not just node within click tolerance
    closest_distance = INFINITE
    closet_node = undefined
    for(let i=0; i<nodeList.length; i++) {
        node = nodeList[i]
        distance = Math.pow(x-node.x, 2) + Math.pow(y-node.y, 2)
        if(distance <= Math.pow(NODE_DRAW_RADIUS + NODE_CLICK_TOLERANCE,2) && distance < closest_distance) {
            closet_node = node
            closest_distance = distance
        }
    }

    return closet_node
}

function click_to_node(event) {
    //first see if click is in one of the existing nodes
    node = get_clicked_on_node(event)
    if(node != undefined) {
        return node
    }
   else {
        return new Node(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop)
   }
}

function get_clicked_on_iconizedGroup(event) {
    x = event.clientX - canvas.offsetLeft
    y = event.clientY - canvas.offsetTop
     for(icoGroup of iconizedGroups) {
        let d = Math.sqrt(Math.pow(x - icoGroup.x, 2) + Math.pow(y - icoGroup.y, 2))
        if(d <= icoGroup.radius) {
            return icoGroup
        }
    }

    return undefined
}


function draw_node(node) {
    ctx.beginPath()
    ctx.strokeStyle = DISK_COLOR;
    ctx.moveTo(node.x, node.y);
    ctx.arc(node.x, node.y, NODE_DRAW_RADIUS, 0, 2*Math.PI)
    ctx.fillStyle = DISK_COLOR; // Fill the circle with DOISK_COLOR
    ctx.fill();
    ctx.lineWidth = 1
    ctx.stroke();
    ctx.closePath()
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        drawConstantBoxFlagPole(node)
    }
}

function erase_node(node) {
    ctx.beginPath()
    ctx.strokeStyle = "white";
    ctx.moveTo(node.x, node.y);
    ctx.arc(node.x, node.y, NODE_DRAW_RADIUS+2, 0, 2*Math.PI)
    ctx.fillStyle = "white"; 
    ctx.fill();
    ctx.lineWidth = 2
    ctx.stroke();
    ctx.closePath()
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        eraseConstantBoxFlagPole(node)
    }
}

function create_node(node) {
    nodes.add(node)
    draw_node(node)
    if(orderings_are_being_displayed) {
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.display = "initial"
    }
}

function delete_node(node) {
    let edge_list = Array.from(node.edges)
    for(let i=0; i<edge_list.length; i++) {
        unselect_edge(edge_list[i])
        delete_edge(edge_list[i])
    }
    let ultraEdge_list = Array.from(node.ultraEdges)
    for(let i=0; i<ultraEdge_list.length; i++) {
        unselect_ultraEdge(ultraEdge_list[i])
        delete_ultraEdge(ultraEdge_list[i])
    }
    erase_node(node)
    node_id_to_inputBox_map.get(node.id).style.display = "none"
    node_id_to_inputBox_map.delete(node.id)
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        constantBox.remove()
        node_id_to_constantBox_map.delete(node.id)
    }
    nodes.delete(node)
    draw_all_edges()  //could be more clever about edges needing to be redrawn....
    draw_all_ultraEdges()
}

function delete_iconizedGroup(icoGroup) {  //note that parent is responsible for deleting the associated ultraEdges and this should be done first!
    erase_iconizedGroup(icoGroup)
    iconizedGroups.delete(icoGroup)
    draw_all_edges()
    draw_all_ultraEdges()
}

function draw_all_nodes() {
    for(let node of nodes) {
        draw_node(node)
    }
}

function draw_directed_edge(edge) {
    fromX = edge.node1.x
    toX = edge.node2.x
    fromY = edge.node1.y
    toY = edge.node2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(edge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.strokeStyle = EDGE_COLOR
    ctx.lineWidth = EDGE_WIDTH
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = EDGE_COLOR
    ctx.fill();
}

function draw_edge(edge) {
    if(edge.node1 != edge.node2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = EDGE_COLOR
            ctx.lineWidth = EDGE_WIDTH
            ctx.moveTo(edge.node1.x, edge.node1.y);
            ctx.lineTo(edge.node2.x, edge.node2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            draw_directed_edge(edge)
        }
    }
    else {
        drawSelfLoop(edge.node1, edge.dir)
    }
}

function erase_edge(edge) {  //have to be sure to delete directed edge if needed 
    if(edge.node1 != edge.node2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = "white"
            ctx.lineWidth = 2*EDGE_WIDTH
            ctx.moveTo(edge.node1.x, edge.node1.y);
            ctx.lineTo(edge.node2.x, edge.node2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            erase_directed_edge(edge)
        }
        draw_node(edge.node1)
        draw_node(edge.node2)
    }
    else {
        eraseSelfLoop(edge.node1, edge.dir)
    }
 }

 function erase_directed_edge(edge) {   
    fromX = edge.node1.x
    toX = edge.node2.x
    fromY = edge.node1.y
    toY = edge.node2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(edge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.strokeStyle = "white"
    ctx.lineWidth = 2*EDGE_WIDTH
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = 2*EDGE_WIDTH
    ctx.strokeStyle = "white"
    ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = "white"
    ctx.fill();
    ctx.stroke()
 }

 function create_edge(edge) {
    edge.node1.edges.add(edge)
    edge.node2.edges.add(edge)
    edges.add(edge)
    draw_edge(edge)
 }

 function delete_edge(edge) {
    erase_edge(edge)
    edge.node1.edges.delete(edge)
    edge.node2.edges.delete(edge)
    edges.delete(edge)
    draw_all_edges()  //repair crosses
 }

 function create_ultraEdge(ultraEdge) {
    ultraEdge.obj1.ultraEdges.add(ultraEdge)
    ultraEdge.obj2.ultraEdges.add(ultraEdge)
    ultraEdges.add(ultraEdge)
    draw_ultraEdge(ultraEdge)
 }

 function delete_ultraEdge(ultraEdge) {
    erase_ultraEdge(ultraEdge)
    ultraEdge.obj1.ultraEdges.delete(ultraEdge)
    ultraEdge.obj2.ultraEdges.delete(ultraEdge)
    ultraEdges.delete(ultraEdge)
    draw_all_edges()  //repair crosses 
    draw_all_ultraEdges()
 }

 function draw_all_edges() {
    for(let edge of edges) {
        draw_edge(edge)
    }
 }

 function draw_all_ultraEdges() {
    for(let ultraEdge of ultraEdges) {
        draw_ultraEdge(ultraEdge)
    }
 }

 function draw_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = EDGE_COLOR
            ctx.lineWidth = EDGE_WIDTH*2
            ctx.setLineDash([10, 5]);
            ctx.moveTo(ultraEdge.obj1.x, ultraEdge.obj1.y);
            ctx.lineTo(ultraEdge.obj2.x, ultraEdge.obj2.y); 
            ctx.stroke();
            ctx.closePath()
            ctx.setLineDash([]);
        }
        else {
            draw_directed_ultraEdge(ultraEdge)
        }
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {  
            draw_iconizedGroup(ultraEdge.obj1)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj2)
        }
    }
    else {
        drawUltraSelfLoop(ultraEdge.obj1, ultraEdge.dir)
        draw_iconizedGroup(ultraEdge.obj1)
    }
}

function erase_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = "white"
            ctx.lineWidth = EDGE_WIDTH*4
            ctx.moveTo(ultraEdge.obj1.x, ultraEdge.obj1.y);
            ctx.lineTo(ultraEdge.obj2.x, ultraEdge.obj2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            erase_directed_ultraEdge(ultraEdge)
        }
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj1)
        }
        else {
            draw_node(ultraEdge.obj1)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj2)
        }
        else {
            draw_node(ultraEdge.obj2)
        }
    }
    else {
        eraseUltraSelfLoop(ultraEdge.obj1, ultraEdge.dir)
    }
}

function select_ultraEdge(ultraEdge) {
    alreadyInSelectedSet = false
    for(let u of selected_ultraEdges) {
        if(equalUltraEdges(u, ultraEdge)) {
            alreadyInSelectedSet = true
        }
    }
    if(!alreadyInSelectedSet) {
        selected_ultraEdges.add(ultraEdge)
    }
    else {
        //return  IMMEDIATELY RETURNING CAUSES MOVES OF SELECTED EDGES NOT TO DRAW!!
    }
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        let ultraEdge_length = Math.sqrt(Math.pow(ultraEdge.obj1.x - ultraEdge.obj2.x, 2) + Math.pow(ultraEdge.obj1.y - ultraEdge.obj2.y, 2))
        radius1 = radius2 = NODE_DRAW_RADIUS
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj2.x, ultraEdge.obj2.y), ultraEdge.obj1)
            radius1 = ultraEdge_length - d
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj1.x, ultraEdge.obj1.y), ultraEdge.obj2)
            radius2 = ultraEdge_length - d
        }
        //key_ratio1 = key_ratio2 = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        key_ratio1 = (ultraEdge_length - (radius2 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
        key_ratio2 = (ultraEdge_length - (radius1 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
    
        square1_x = (1-key_ratio1)*ultraEdge.obj1.x + key_ratio1*ultraEdge.obj2.x
        square1_y = (1-key_ratio1)*ultraEdge.obj1.y + key_ratio1*ultraEdge.obj2.y
        square2_x = key_ratio2*ultraEdge.obj1.x + (1-key_ratio2)*ultraEdge.obj2.x
        square2_y = key_ratio2*ultraEdge.obj1.y + (1-key_ratio2)*ultraEdge.obj2.y
    }
    else {
        square1_x = square2_x = ultraEdge.obj1.x
        square1_y = square2_y = ultraEdge.obj1.y
        let dt = 5
        if(ultraEdge.dir == DIR_UP) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y -= dt
            square2_y -= dt
        }
        else if(ultraEdge.dir == DIR_DOWN) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y += dt
            square2_y += dt
        }
        else if(ultraEdge.dir == DIR_RIGHT) {
            square1_x += dt
            square2_x += dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
        else {
            square1_x -= dt
            square2_x -= dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
    }
    drawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    drawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    if(edge_type == TYPE_DIRECTED) {
        drawSelectionTriangle(ultraEdge)
    }
}

function unselect_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        let ultraEdge_length = Math.sqrt(Math.pow(ultraEdge.obj1.x - ultraEdge.obj2.x, 2) + Math.pow(ultraEdge.obj1.y - ultraEdge.obj2.y, 2))
        radius1 = radius2 = NODE_DRAW_RADIUS
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj2.x, ultraEdge.obj2.y), ultraEdge.obj1)
            radius1 = ultraEdge_length - d
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            d = getPointToIconizedGroupIconDistance(new Point(ultraEdge.obj1.x, ultraEdge.obj1.y), ultraEdge.obj2)
            radius2 = ultraEdge_length - d
        }
        //key_ratio1 = key_ratio2 = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        key_ratio1 = (ultraEdge_length - (radius2 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
        key_ratio2 = (ultraEdge_length - (radius1 + NODE_DRAW_RADIUS + 1))/ultraEdge_length
    
        square1_x = (1-key_ratio1)*ultraEdge.obj1.x + key_ratio1*ultraEdge.obj2.x
        square1_y = (1-key_ratio1)*ultraEdge.obj1.y + key_ratio1*ultraEdge.obj2.y
        square2_x = key_ratio2*ultraEdge.obj1.x + (1-key_ratio2)*ultraEdge.obj2.x
        square2_y = key_ratio2*ultraEdge.obj1.y + (1-key_ratio2)*ultraEdge.obj2.y
    }
    else {  
        //not yet implemented
    }
    undrawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    undrawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    //redraw the edge objects and their seleciton indicators
    if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
        draw_iconizedGroup(ultraEdge.obj1)
        if(selected_iconizedGroups.has(ultraEdge.obj1)) {
            select_iconizedGroup(ultraEdge.obj1)
        }
    }
    else {
        draw_node(ultraEdge.obj1)
        if(selected_nodes.has(ultraEdge.obj1)) {
            select_node(ultraEdge.obj1)
        }
    }
    if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
        draw_iconizedGroup(ultraEdge.obj2)
        if(selected_iconizedGroups.has(ultraEdge.obj2)) {
            select_iconizedGroup(ultraEdge.obj2)
        }
    }
    else {
        draw_node(ultraEdge.obj2)
        if(selected_nodes.has(ultraEdge.obj2)) {
            select_node(ultraEdge.obj2)
        }
    }

    draw_all_edges()
    draw_all_ultraEdges()
    //could be clobbering some selected edges and ultraEdges so redraw them (could be more careful about this)
    for(const e of selected_edges) {
        select_edge(e)
    }
    for(const u of selected_ultraEdges) {
        if(!equalUltraEdges(u, ultraEdge)) {
            select_ultraEdge(u)
        }
    }
    selected_ultraEdges.delete(ultraEdge)
}

function equalUltraEdges(uEdge1, uEdge2) { 
    if(edge_type == TYPE_UNDIRECTED) {
        return ((uEdge1.obj1 == uEdge2.obj1 && uEdge1.obj2 == uEdge2.obj2) ||
        (uEdge1.obj1 == uEdge2.obj2 && uEdge1.obj2 == uEdge2.obj1))
    }
    else {
        return uEdge1.obj1 == uEdge2.obj1 && uEdge1.obj2 == uEdge2.obj2
    }
}

function getPolygonVerticesForIconizedGroup(iconizedGroup) {
    let x = iconizedGroup.x
    let y = iconizedGroup.y
    let radius = iconizedGroup.radius
    let sides = iconizedGroup.num_sides
    let vertices = []
    let initial_angle = -Math.PI/2
    if(sides == 4) {
        initial_angle = -Math.PI/4
    }
    let pt = new Point(x + radius * Math.cos(initial_angle), y + radius * Math.sin(initial_angle))
    vertices .push(pt)
    let angle = (Math.PI * 2) / sides;
    for (let i = 1; i <= sides; i++) {
        pt = new Point(x + radius * Math.cos(initial_angle + angle * i), y + radius * Math.sin(initial_angle + angle * i))
        vertices .push(pt)
    }
    return vertices
}

function select_iconizedGroup(icoGroup) {
    //draw selection squares
    vertices = getPolygonVerticesForIconizedGroup(icoGroup)
    for(let vertex of vertices) {
        drawSelectionSquare(vertex.x, vertex.y, NODE_DRAW_RADIUS*2, ICONIZED_GROUP_SELECT_COLOR, 2)
    }

    //add to group
    selected_iconizedGroups.add(icoGroup)
}

function unselect_iconizedGroup(icoGroup) {
    vertices = getPolygonVerticesForIconizedGroup(icoGroup)
    for(let vertex of vertices) {
        drawSelectionSquare(vertex.x, vertex.y, NODE_DRAW_RADIUS*2, UNSELECT_COLOR)
    }
    //redraw any very close nodes
    for(let n of nodes) {
        dist = Math.sqrt(Math.pow((n.x-icoGroup.x),2) + Math.pow((n.y-icoGroup.y),2))
        if(dist < icoGroup.radius + 2*NODE_DRAW_RADIUS) {
            draw_node(n)
        }
    }
    //redraw any very close iconizedGroups
    for(let i of iconizedGroups) {
        dist = Math.sqrt(Math.pow((i.x-icoGroup.x),2) + Math.pow((i.y-icoGroup.y),2))
        if(dist < i.radius + icoGroup.radius + NODE_DRAW_RADIUS) {
            draw_iconizedGroup(i)
        }
    }
    //redraw edges (could be impairing not just edges from this node but other very close edges....)
    draw_all_edges()
    for(const e of selected_edges) {
        select_edge(e)
    }
    selected_iconizedGroups.delete(icoGroup)
}

function toggle_select_iconizedGroup(icoGroup) {
    if(selected_iconizedGroups.has(icoGroup)) {
        unselect_iconizedGroup(icoGroup)
    }
    else {
        select_iconizedGroup(icoGroup)
    }
}

function toggle_select_ultraEdge(ultraEdge) {
    if(selected_ultraEdges.has(ultraEdge)) {
        unselect_ultraEdge(ultraEdge)
    }
    else {
        select_ultraEdge(ultraEdge)
    }
}

 function draw_all_iconizedGroups() {
    for(let icoGroup of iconizedGroups) {
        draw_iconizedGroup(icoGroup)
    }
}

function draw_iconizedGroup(icoGroup) {
    drawPolygon("mainCanvas", icoGroup.x, icoGroup.y, icoGroup.radius,
        icoGroup.num_sides, icoGroup.fill_color, icoGroup.label)
}

function erase_iconizedGroup(icoGroup) {
    drawPolygon("mainCanvas", icoGroup.x, icoGroup.y, icoGroup.radius, icoGroup.num_sides, "White", "")
}


 function drawPolygon(canvasId, x, y, radius, sides, fill_color, label) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  if (sides < 3) return;
  ctx.beginPath();
  if(fill_color.toLowerCase() != "white") {
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
  }
  else {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
  }
  let initial_angle = -Math.PI/2
  if(sides == 4) {
    initial_angle = -Math.PI/4
  }
  const angle = (Math.PI * 2) / sides;
  ctx.moveTo(x + radius * Math.cos(initial_angle), y + radius * Math.sin(initial_angle));
  for (let i = 1; i <= sides; i++) {
    ctx.lineTo(
      x + radius * Math.cos(initial_angle + angle * i),
      y + radius * Math.sin(initial_angle + angle * i)
    );
  }
  ctx.closePath();
  ctx.fillStyle = fill_color
  ctx.fill()
  ctx.stroke();

  let font_size = radius*2/5
  ctx.font = '' + font_size + 'pt Arial';  //8-14 works
  if(fill_color == "cyan" || fill_color == "chartreuse" || fill_color == "orange") {
    ctx.fillStyle = 'black'; // Text color
  }
  else {
    ctx.fillStyle = 'white';
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x, y);
}

function draw_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = EDGE_COLOR
            ctx.lineWidth = EDGE_WIDTH*2
            ctx.setLineDash([10, 5]);
            ctx.moveTo(ultraEdge.obj1.x, ultraEdge.obj1.y);
            ctx.lineTo(ultraEdge.obj2.x, ultraEdge.obj2.y); 
            ctx.stroke();
            ctx.closePath()
            ctx.setLineDash([]);
        }
        else {
            draw_directed_ultraEdge(ultraEdge)
        }
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {  
            draw_iconizedGroup(ultraEdge.obj1)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj2)
        }
    }
    else {
        drawUltraSelfLoop(ultraEdge.obj1, ultraEdge.dir)
        draw_iconizedGroup(ultraEdge.obj1)
    }
}

function erase_ultraEdge(ultraEdge) {
    if(ultraEdge.obj1 != ultraEdge.obj2) {
        if(edge_type == TYPE_UNDIRECTED) {
            ctx.beginPath()
            ctx.strokeStyle = "white"
            ctx.lineWidth = EDGE_WIDTH*4
            ctx.moveTo(ultraEdge.obj1.x, ultraEdge.obj1.y);
            ctx.lineTo(ultraEdge.obj2.x, ultraEdge.obj2.y); 
            ctx.stroke();
            ctx.closePath()
        }
        else {
            erase_directed_ultraEdge(ultraEdge)
        }
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj1)
        }
        else {
            draw_node(ultraEdge.obj1)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            draw_iconizedGroup(ultraEdge.obj2)
        }
        else {
            draw_node(ultraEdge.obj2)
        }
    }
    else {
        eraseUltraSelfLoop(ultraEdge.obj1, ultraEdge.dir)
    }
}

function draw_directed_ultraEdge(ultraEdge) {
    fromX = ultraEdge.obj1.x
    toX = ultraEdge.obj2.x
    fromY = ultraEdge.obj1.y
    toY = ultraEdge.obj2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    let tempEdge = Edge()
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(ultraEdge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.strokeStyle = EDGE_COLOR
    ctx.lineWidth = EDGE_WIDTH*1.5
    ctx.setLineDash([10, 5]);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.setLineDash([]);
    ctx.fillStyle = EDGE_COLOR
    ctx.fill();
}

function erase_directed_ultraEdge(ultraEdge) {
     fromX = ultraEdge.obj1.x
    toX = ultraEdge.obj2.x
    fromY = ultraEdge.obj1.y
    toY = ultraEdge.obj2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(ultraEdge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    ctx.beginPath();
    ctx.strokeStyle = "white"
    ctx.lineWidth = EDGE_WIDTH*3
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = EDGE_WIDTH*3
    ctx.strokeStyle = "white"
    ctx.moveTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH*1.25 * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH*1.25 * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = "white"
    ctx.fill();
    ctx.stroke();
}

function drawSelectionSquare(x, y, side_length, color) { 
    const sideLength = side_length;
    const top_leftX = x - side_length/2; // x-coordinate of the top-left corner
    const top_leftY = y - side_length/2; // y-coordinate of the top-left corner
    ctx.beginPath()
    ctx.strokeStyle = color; // Set stroke color
    line_width = 1
    if(color == UNSELECT_COLOR) {
        line_width += 2
    }
    ctx.lineWidth = line_width; // Set line width 
    ctx.strokeRect(top_leftX, top_leftY, sideLength, sideLength); 
    ctx.stroke()
    ctx.closePath()
}

function drawSelectionCircle(x, y, radius) { //used for selecting edges
    ctx.beginPath()
    ctx.strokeStyle = "blue";
    //ctx.moveTo(x, y);
    ctx.arc(x, y, radius, 0, 2*Math.PI)
    ctx.fillStyle = EDGE_SELECT_COLOR;
    ctx.fill();
    ctx.lineWidth = 1
    ctx.stroke();
    ctx.closePath()
}

function undrawSelectionCircle(x, y, radius) {  //used for unselecting edges
    ctx.beginPath()
    ctx.strokeStyle = "white";
    //ctx.moveTo(x, y);
    ctx.arc(x, y, radius, 0, 2*Math.PI)
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.lineWidth = 3
    ctx.stroke();
    ctx.closePath()
}

function getSmartArrowOffsetPct(e) {  
    if(e.hasOwnProperty("node1")) {
        edge_length = Math.sqrt((e.node2.y - e.node1.y)*(e.node2.y - e.node1.y) + 
                        (e.node2.x - e.node1.x)*(e.node2.x - e.node1.x))
    }
    else { //e is an UltraEdge
        edge_length = Math.sqrt((e.obj2.y - e.obj1.y)*(e.obj2.y - e.obj1.y) + 
                        (e.obj2.x - e.obj1.x)*(e.obj2.x - e.obj1.x))
    }
    CRITICAL_LENGTH = 300
    if(edge_length > CRITICAL_LENGTH) {
        return ARROW_OFFSET_PCT
    }
    else {
        return (edge_length/CRITICAL_LENGTH)*ARROW_OFFSET_PCT + ((CRITICAL_LENGTH-edge_length)/CRITICAL_LENGTH)*(ARROW_OFFSET_PCT + (1-ARROW_OFFSET_PCT)*ARROW_OFFSET_PCT)
    }
}

function drawSelectionTriangle(edge) {
    fromX = edge.node1.x
    toX = edge.node2.x
    fromY = edge.node1.y
    toY = edge.node2.y
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(-dy, -dx);
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(edge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;
    ctx.strokeStyle = "blue";
    ctx.beginPath();
    ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(midX, midY);
    ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = EDGE_SELECT_COLOR
    ctx.fill();
    ctx.stroke()
}

function toggle_select_node(node) {
    if(selected_nodes.has(node)) {
        unselect_node(node)
    }
    else {
        select_node(node)
    }
}

function toggle_select_edge(edge) {
    if(selected_edges.has(edge)) {
        unselect_edge(edge)
    }
    else {
        select_edge(edge)
    }
}

function select_node(node) {
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, NODE_SELECT_COLOR)
    selected_nodes.add(node)
}

function unselect_node(node) {
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y - NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    drawSelectionSquare(node.x + NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    drawSelectionSquare(node.x - NODE_DRAW_RADIUS, node.y + NODE_DRAW_RADIUS, NODE_DRAW_RADIUS*3/2, UNSELECT_COLOR)
    draw_node(node)
    //redraw any very close nodes
    for(const n of nodes) {
        dist = Math.sqrt(Math.pow((n.x-node.x),2) + Math.pow((n.y-node.y),2))
        if(dist < 3*NODE_DRAW_RADIUS) {
            draw_node(n)
        }
    }
    //redraw edges (could be impairing not just edges from this node but other very close edges....)
    draw_all_edges()
    for(const e of selected_edges) {
        select_edge(e)
    }
    selected_nodes.delete(node)
}

function select_edge(edge) {
    alreadyInSelectedSet = false
    for(e of selected_edges) {
        if(equalEdges(e, edge)) {
            alreadyInSelectedSet = true
        }
    }
    if(!alreadyInSelectedSet) {
        selected_edges.add(edge)
    }
    else {
        //return  IMMEDIATELY RETURNING CAUSES MOVES OF SELECTED EDGES NOT TO DRAW!!
    }
    if(edge.node1 != edge.node2) {
        edge_length = Math.sqrt(Math.pow((edge.node1.x-edge.node2.x),2) + Math.pow((edge.node1.y-edge.node2.y),2))
        key_ratio = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        square1_x = (1-key_ratio)*edge.node1.x + key_ratio*edge.node2.x
        square1_y = (1-key_ratio)*edge.node1.y + key_ratio*edge.node2.y
        square2_x = key_ratio*edge.node1.x + (1-key_ratio)*edge.node2.x
        square2_y = key_ratio*edge.node1.y + (1-key_ratio)*edge.node2.y
    }
    else {
        square1_x = square2_x = edge.node1.x
        square1_y = square2_y = edge.node1.y
        let dt = 5
        if(edge.dir == DIR_UP) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y -= dt
            square2_y -= dt
        }
        else if(edge.dir == DIR_DOWN) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y += dt
            square2_y += dt
        }
        else if(edge.dir == DIR_RIGHT) {
            square1_x += dt
            square2_x += dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
        else {
            square1_x -= dt
            square2_x -= dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
    }
    drawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    drawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    if(edge_type == TYPE_DIRECTED) {
        drawSelectionTriangle(edge)
    }
}

function unselect_edge(edge) {
    if(edge.node1 != edge.node2) {
        edge_length = Math.sqrt(Math.pow((edge.node1.x-edge.node2.x),2) + Math.pow((edge.node1.y-edge.node2.y),2))
        key_ratio = (edge_length - 2*(NODE_DRAW_RADIUS+1))/edge_length
        square1_x = (1-key_ratio)*edge.node1.x + key_ratio*edge.node2.x
        square1_y = (1-key_ratio)*edge.node1.y + key_ratio*edge.node2.y
        square2_x = key_ratio*edge.node1.x + (1-key_ratio)*edge.node2.x
        square2_y = key_ratio*edge.node1.y + (1-key_ratio)*edge.node2.y
    }
    else {
        square1_x = square2_x = edge.node1.x
        square1_y = square2_y = edge.node1.y
        let dt = 5
        if(edge.dir == DIR_UP) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y -= dt
            square2_y -= dt
        }
        else if(edge.dir == DIR_DOWN) {
            square1_x -= 2*(NODE_DRAW_RADIUS+1)
            square2_x += 2*(NODE_DRAW_RADIUS+1)
            square1_y += dt
            square2_y += dt
        }
        else if(edge.dir == DIR_RIGHT) {
            square1_x += dt
            square2_x += dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
        else {
            square1_x -= dt
            square2_x -= dt
            square1_y -= 2*(NODE_DRAW_RADIUS+1)
            square2_y += 2*(NODE_DRAW_RADIUS+1)
        }
    }
    undrawSelectionCircle(square1_x, square1_y, NODE_DRAW_RADIUS+1)
    undrawSelectionCircle(square2_x, square2_y, NODE_DRAW_RADIUS+1)

    //redraw the edge nodes and their seleciton indicators
    draw_node(edge.node1)
    draw_node(edge.node2)
    if(selected_nodes.has(edge.node1)) {
        select_node(edge.node1)
    }
    if(selected_nodes.has(edge.node2)) {
        select_node(edge.node2)
    }
    draw_all_edges()
    draw_all_ultraEdges
    //could be clobbering some selected edges or ultraEdges so redraw them (could be more careful about this)
    for(const e of selected_edges) {
        if(!equalEdges(e, edge)) {
            select_edge(e)
        }
    }
    for(const u of selected_ultraEdges) {
        select_ultraEdge(u)
    }
    selected_edges.delete(edge)
}

function drawConstantBoxFlagPole(node) {
    ctx.beginPath()
    ctx.strokeStyle = "Blue"
    ctx.lineWidth = CONSTANT_BOX_OFFSET_X/3
    ctx.moveTo(node.x, node.y - NODE_DRAW_RADIUS);
    ctx.lineTo(node.x, node.y - CONSTANT_FLAGPOLL_TOP_OFFSET - CONSTANT_BOX_HEIGHT); 
    ctx.stroke();
    ctx.closePath()
}

function eraseConstantBoxFlagPole(node) {
    ctx.beginPath()
    ctx.strokeStyle = "White"
    ctx.lineWidth = CONSTANT_BOX_OFFSET_X/2
    ctx.moveTo(node.x, node.y - NODE_DRAW_RADIUS);
    ctx.lineTo(node.x, node.y - CONSTANT_FLAGPOLL_TOP_OFFSET - CONSTANT_BOX_HEIGHT); 
    ctx.stroke();
    ctx.closePath()
}

function isViableDrag(event) {
    if(event.button == 0) {
        if (Math.abs(event.clientX - canvas.offsetLeft - DIVIDING_LINE_LOC) <= DIVIDING_LINE_BUFFER)  {  
                //reject if too close to dividing line
            return false
        }
        else if(event.clientY - canvas.offsetTop < TOP_BUFFER) {  //reject if in top buffer
            //return false
            return true    //no longer rejecting these
        }
        else {
            return true
        }
    }
    else {
        return false
    }
}

function isClickInAnOrderInputBox(event) {
    //let CLICK_BUFF = 3
    const cursor = getComputedStyle(event.target).cursor;  //the text cursor gives screwy coordinates....
    return cursor == "text"
    /*console.log(cursor);
    if(orderings_are_being_displayed) {
        for(let node of nodes) {
            orderInputBox = node_id_to_inputBox_map.get(node.id)
            bdgRect = orderInputBox.getBoundingClientRect()
            if(x >= bdgRect.left - CLICK_BUFF && x <= bdgRect.left + bdgRect.width  + CLICK_BUFF &&
                y >= bdgRect.top - CLICK_BUFF && y <= bdgRect.top + bdgRect.height  + CLICK_BUFF) {
                beep()
                orderInputBox.focus()
                return true
            }
        }
        return false
    }
    else {
        return false
    }*/
}

function process_click(event) {
    x = event.clientX - canvas.offsetLeft
    y = event.clientY - canvas.offsetTop

    if(isClickInAnOrderInputBox(event)) {
        return false
    }

    if(wasDragging) {
        wasDragging = false
        return false
    }
    else if (Math.abs(x - DIVIDING_LINE_LOC) <= DIVIDING_LINE_BUFFER) {  //reject if too close to dividing line
        return false
    }
    else if(y < TOP_BUFFER) {  //reject if in top buffer
        return false
    }
    else {
        return true
    }
}

function clearSelectionFromAllButNode(node) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        if(selected_nodes_list[i] != node) {
            unselect_node(selected_nodes_list[i])
        }
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function clearSelectionFromAllButEdge(edge) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        if(selected_edge_list[i] != edge) {
            unselect_edge(selected_edge_list[i])
        }
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function clearSelectionFromAllButUltraEdge(ultraEdge) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }

    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        if(selected_ultraEdge_list[i] != ultraEdge) {
            unselect_ultraEdge(selected_ultraEdge_list[i])
        }
    }
}

function clearSelectionFromAllButIconizedGroup(icoGroup) {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        if(selected_iconizedGroup_list[i] != icoGroup) {
            unselect_iconizedGroup(selected_iconizedGroup_list[i])
        }
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}


function clearSelection() {
    let selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
    }
    let selected_iconizedGroup_list = Array.from(iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
    }
    let selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
    }
    let selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
    }
}

function getPointToDirectedEdgeDistance(point, edge) { //here the target is the direction triangle
    let fromX = edge.node1.x
    let toX = edge.node2.x
    let fromY = edge.node1.y
    let toY = edge.node2.y
    SMART_ARROW_OFFSET_PCT = getSmartArrowOffsetPct(edge)
    const midX = (1-SMART_ARROW_OFFSET_PCT)*fromX + SMART_ARROW_OFFSET_PCT*toX;
    const midY = (1-SMART_ARROW_OFFSET_PCT)*fromY + SMART_ARROW_OFFSET_PCT*toY;

    return Math.sqrt((point.x - midX)*(point.x - midX) + (point.y - midY)*(point.y - midY))
}

function getPointToUndirectedEdgeDistance(point, edge) { //here the target is the entire edge
    return getPointToUndirectedAbstractEdgeDistance(point, edge.node1.x, edge.node1.y, edge.node2.x, edge.node2.y)
}



function getPointToEdgeDistance(point, edge) { //used to determine if user has clicked on an edge
    if(edge_type == TYPE_UNDIRECTED) {
        return getPointToUndirectedEdgeDistance(point, edge)
    }
    else {
        return getPointToDirectedEdgeDistance(point, edge)
    }
}

function getPointToIconizedGroupIconDistance(point, icoGroup) {
    consecutiveVertices = getPolygonVerticesForIconizedGroup(icoGroup)
    seg1 = new Segment(point, new Point(icoGroup.x, icoGroup.y))
    for(let i = 0; i < consecutiveVertices.length -1; i++) {
        seg2 = new Segment(consecutiveVertices[i], consecutiveVertices[i+1])
        int_pt = getIntersectPoint(seg1, seg2)
        if(int_pt != undefined) {
            return Math.sqrt(Math.pow(point.x - int_pt.x, 2) + Math.pow(point.y - int_pt.y, 2))
        }
    }
}

//Gets the intersection point of two line segments, under the assumption that the two line segs
// are NOT collinear.
function getIntersectPoint(seg1, seg2) {
  const s1_x = seg1.pt2.x - seg1.pt1.x;
  const s1_y = seg1.pt2.y - seg1.pt1.y;
  const s2_x = seg2.pt2.x - seg2.pt1.x;
  const s2_y = seg2.pt2.y - seg2.pt1.y;

  const s = (-s1_y * (seg1.pt1.x - seg2.pt1.x) + s1_x * (seg1.pt1.y - seg2.pt1.y)) / (-s2_x * s1_y + s1_x * s2_y);
  const t = ( s2_x * (seg1.pt1.y - seg2.pt1.y) - s2_y * (seg1.pt1.x - seg2.pt1.x)) / (-s2_x * s1_y + s1_x * s2_y);

  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return new Point(seg1.pt1.x + (t * s1_x), seg1.pt1.y + (t * s1_y));
  }

  return undefined;
}

function getPointToUltraEdgeDistance(point, ultraEdge) { //used to determine if user has clicked on an edge
    if(edge_type == TYPE_UNDIRECTED) {
        return getPointToUndirectedAbstractEdgeDistance(point, ultraEdge.obj1.x, ultraEdge.obj1.y, ultraEdge.obj2.x, ultraEdge.obj2.y)
    }
    else {
        return getPointToDirectedUltraEdgeDistance(point, ultraEdge)
    }
}

function getPointToDirectedUltraEdgeDistance(point, ultraEdge) {
    return getPointToDirectedAbstractEdgeDistance(point, ultraEdge, ultraEdge.obj1.x, ultraEdge.obj1.y, 
        ultraEdge.obj2.x, ultraEdge.obj2.y) 
}

function getPointToUndirectedAbstractEdgeDistance(point, x1, y1, x2, y2) {
    if(x1 != x2 || y1 != y2) {
        let A = B = C = 0
        if(x1 == x2) {
            //B = 1
            //C = -1*edge.node1.x
            if(point.y >= Math.min(y1, y2) && point.y <= Math.max(y1, y2)) {
                return Math.abs(point.x - x1)
            }
            else {
                //let d1 = Math.sqrt((point.x - edge.node1.x)*(point.x - edge.node1.x) + (point.y - edge.node1.y)*(point.y - edge.node1.y))
                //let d2 = Math.sqrt((point.x - edge.node2.x)*(point.x - edge.node2.x) + (point.y - edge.node2.y)*(point.y - edge.node2.y))
                //return Math.min(d1, d2)
                return INFINITE  //want to reject these clicks!
            }
        }
        else {
            A = y2 - y1
            B = x2 - x1
            C = x2*y1 - y2*x1
        }

        pt_line_dist = Math.abs(A*point.x - B*point.y + C)/Math.sqrt(A*A + B*B)

        edge_length = Math.sqrt(Math.pow((x1-x2),2) + Math.pow((y1-y2),2))
        test_distance1 = Math.sqrt(Math.pow((x1-point.x),2) + Math.pow((y1-point.y),2))
        test_distance2 = Math.sqrt(Math.pow((x2-point.x),2) + Math.pow((y2-point.y),2))
        
        if(test_distance1 < edge_length && test_distance2 < edge_length) {
            return pt_line_dist
        }
        else {
            return edge_length  //we want to reject these clicks so we don't bother with the exact calculation here....
                                //Modify to do proper calculation here if needed
        }
    }
    else {  //in this case it is the point to circle distance
        //Not doing this in a very good way
        //let d = Math.abs(Math.sqrt(Math.pow(point.x - edge.node1.x, 2) + Math.pow(point.y - edge.node1.y, 2)) - SELF_LOOP_RADIUS)
        //return d
        let disk_center = undefined
        let x = x1
        let y = y1
        if(edge.dir==DIR_UP) {
            disk_center = new Point(x, y-SELF_LOOP_RADIUS)
        }
        else if(edge.dir==DIR_RIGHT) {
            disk_center = new Point(x+SELF_LOOP_RADIUS, y)
        }
        else if(edge.dir==DIR_DOWN) {
            disk_center = new Point(x, y+SELF_LOOP_RADIUS)
        }
        else {
            disk_center = new Point(x-SELF_LOOP_RADIUS, y)
        }
        let d = Math.sqrt(Math.pow(point.x - disk_center.x, 2) + Math.pow(point.y - disk_center.y, 2)) 
        return Math.abs(d - SELF_LOOP_RADIUS)
    }
}

  prior_width = 0; 
  prior_height = 0;
  wasDragging = false

function smartClearRect(event) {
    deltaX = 1
    deltaY = 1
    if(prior_width < 0) {
        deltaX = -1
    }
    if(prior_height < 0) {
        deltaY = -1
    }
    keepSelections = false
    if(event.shiftKey || event.metaKey) { 
        keepSelections = true
    }
    ctx.clearRect(startX-deltaX, startY-deltaY, prior_width+2*deltaX, prior_height+2*deltaY);
    const rect = new Rectangle(startX-deltaX, startY-deltaY, prior_width+2*deltaX, prior_height+2*deltaY)
    for(const node of nodes) {
        if(nodeInRect(node, rect)) {
            draw_node(node)
            if(keepSelections && selected_nodes.has(node)) {
                select_node(node)
            }
        }
    }
    draw_all_edges()
    draw_all_ultraEdges()
    draw_all_iconizedGroups()
    if(keepSelections) {
        for(const edge of selected_edges) {
            select_edge(edge)
        }
        for(const icoGroup of selected_iconizedGroups) {
            select_iconizedGroup(icoGroup)
        }
    }
    //drawDividingLine()
}

  function redrawRectangle(x, y, width, height) {
    ctx.clearRect(x, y, width, height)
    draw_all_edges()
    for(let edge of selected_edges) {
        select_edge(edge)
    }
    draw_all_ultraEdges()
    for(let ultraEdge of selected_ultraEdges) {
        select_ultraEdge(ultraEdge)
    }
    draw_all_nodes()
    for(let node of selected_nodes) {
        select_node(node)
    }
    draw_all_iconizedGroups()
    for(let icoGroup of selected_iconizedGroups) {
        select_iconizedGroup(icoGroup)
    }
    //drawDividingLine()
  }

  function createNodeOrderingBox(node) {
    const ORDERING_BOX_WIDTH = 20 //was `17
    const ORDERING_BOX_HEIGHT = 15

    if(node.order == NO_ORDER) {
        max_order_on_this_side = NO_ORDER
        some_nodes_have_orders = false
        for(let n of nodes) {
            if(n.order != NO_ORDER) {
                some_nodes_have_orders = true
                if((n.x < DIVIDING_LINE_LOC && node.x < DIVIDING_LINE_LOC) || (n.x > DIVIDING_LINE_LOC && node.x > DIVIDING_LINE_LOC)) {
                    if(n.order > max_order_on_this_side) {
                        max_order_on_this_side = n.order
                    }
                }
            }
        }

        if(some_nodes_have_orders || orderings_are_being_displayed) {
            if(max_order_on_this_side > NO_ORDER) {
                node.order = Math.floor(max_order_on_this_side + 1)
            }
            else {
                node.order = 1
            }
        }
    }

    orderInputBox = createTextBox(node.x + ORDERING_BOX_OFFSET_X, node.y + ORDERING_BOX_OFFSET_Y, node.order, 
                    ORDERING_BOX_WIDTH, ORDERING_BOX_HEIGHT)
    node_id_to_inputBox_map.set(node.id, orderInputBox)
    return orderInputBox
  }

  function orderNodesbyId() {
    left_hand_nodes = []
    right_hand_nodes = []
    for(let node of nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            left_hand_nodes.push(node)
        }
        else {
            right_hand_nodes.push(node)
        }
    }
    left_hand_nodes.sort((a,b) => {a.id - b.id});
    right_hand_nodes.sort((a,b) => {a.id - b.id});
    for(i=0; i<left_hand_nodes.length; i++) {
        left_hand_nodes[i].order = i+1
    }
    for(i=0; i<right_hand_nodes.length; i++) {
        right_hand_nodes[i].order = i+1
    }
  }

  function nodesAreAllUnordered() {
    for(let node of nodes) {
        if(node.order != NO_ORDER) {
            return false
        }
    }

    return true
  }

  function displayNodeOrderings() {
    const ORDERING_BOX_OFFSET_X = -15
    const ORDERING_BOX_OFFSET_Y = 15
    const ORDERING_BOX_WIDTH = 17
    const ORDERING_BOX_HEIGHT = 15
    if(nodesAreAllUnordered()) {
        orderNodesbyId()
    }
    for(let node of nodes) {
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.left = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
        orderInputBox.style.top = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        orderInputBox.style.display = "initial"
        if(node.order != NO_ORDER) {
            orderInputBox.value = node.order
        }
        else {
            orderInputBox.value = ''
        }
    }
  }

  function hideNodeOrderings() {
    for(let node of nodes) {
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.display = "none"
    }
  }

  function createTextBox(x, y, value, width, height) {
        const input = document.createElement('input');
        input.type = 'text';
        input.style.position = 'absolute';
        input.style.left = x + 'px';
        input.style.top = y + 'px';
        input.style.width = width + 'px';
        input.style.height = height + 'px';
        input.style.textAlign = 'center'
        input.style.fontSize = "8pt"
        input.disabled = true
        input.maxLength = 3
        input.pattern = "[0-9]{3}"
        input.style.backgroundColor = "white"
        if(value != NO_ORDER && !isNaN(value)) {
            input.value = value
        }
        
        
        document.body.appendChild(input);

        input.addEventListener('input', function(event) {
            const allowedChars = /^[0-9.-]*$/; // Allows only numbers
            if (!allowedChars.test(this.value)) {
                beep()
                this.value = this.value.replace(/[^0-9.-]/g, ''); //Removes invalid characters
            }
        });

        input.addEventListener('blur', function(event) {
            for(let node of nodes) {
                ibox = node_id_to_inputBox_map.get(node.id)
                if(ibox == this) {
                    node.order = Number(this.value)
                    if(isNaN(node.order) || node.order == 0) {
                        node.order = NO_ORDER
                        ibox.value = ''
                    }
                }
            }
        });
       
       
        input.addEventListener('keyup', function(event) {
            event.stopPropagation()   //Don't propagate deletes to selected nodes and other things like that
        });


        return input;
    }   

    function createConstantBox(x, y, value, width, height) {
        const input = document.createElement('input');
        input.type = 'text';
        input.style.position = 'absolute';
        input.style.left = x + 'px';
        input.style.top = y + 'px';
        input.style.width = width + 'px';
        input.style.height = height + 'px';
        input.style.textAlign = 'center'
        input.style.fontSize = "8pt"
        input.style.border = "2px solid"
        input.style.borderColor = "Blue"
        //input.disabled = true  //uncomment on game_play page!
        input.value = value
        input.maxLength = 3
        input.style.backgroundColor = "yellow"        
        
        document.body.appendChild(input);


        ignoreBlur = false  //a bit of a hack
        input.addEventListener('blur', function(event) {
            if(ignoreBlur) {
                ignoreBlur = false
                return
            }
            for(let node of nodes) {
                cbox = node_id_to_constantBox_map.get(node.id)
                if(cbox == this) {  
                    if(node.constant == this.value) { //they didn't change anything
                        if(this.value == '') {
                            removeConstantBox(node)
                        }
                        killClickEvent = true 
                        return 
                    }
                    //From here on down the user has changed the constant (possibly from '')
                    if(this.value != '') {
                        if(in_use_constants.has(this.value)) {
                            alert("Constant is already in use on this side!")
                            this.value = node.constant
                            ignoreBlur = true
                            this.focus()
                            return
                        }
                        if(node.constant != '') {
                            in_use_constants.delete(node.constant)
                        }
                        in_use_constants.add(this.value)
                        node.constant = this.value
                    }
                    else { //remove constant box and flag pole
                        if(node.constant != '') {
                            in_use_constants.delete(node.constant)
                        }
                        node.constant = ''
                        removeConstantBox(node)
                    }
                }
            }
            killClickEvent = true 
        });
       
        input.addEventListener('keyup', function(event) {
            event.stopPropagation()   //Don't propagate deletes to selected nodes and other things like that
        });


        return input;
    } 
  
  function redrawAll() {
    minX = canvas.width
    maxX = 0
    minY = canvas.height
    maxY = 0
    for(let node of nodes) {
        if(node.x < minX) {
            minX = node.x
        }
        if(node.x > maxX) {
            maxX = node.x
        }
        if(node.y < minY) {
            minY = node.y
        }
        if(node.y > maxY) {
            maxY = node.y
        }
    }
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.x < minX) {
            minX = icoGroup.x
        }
        if(icoGroup.x > maxX) {
            maxX = icoGroup.x
        }
        if(icoGroup.y < minY) {
            minY = icoGroup.y
        }
        if(icoGroup.y > maxY) {
            maxY = icoGroup.y
        }
    }
    REDRAW_BUFF = 100
    if(maxX >= minX && maxY >= minY) {    //there could just be a single node or a bunch of horizontal/vertical nodes
        redrawRectangle(minX-REDRAW_BUFF, minY-REDRAW_BUFF, maxX-minX+2*REDRAW_BUFF, maxY-minY+2*REDRAW_BUFF)
    }
  }

  function nodeInRect(node, rect) {
    tolerance = NODE_DRAW_RADIUS
    rect_left = Math.min(rect.x, rect.x + rect.width) - tolerance
    rect_right = Math.max(rect.x, rect.x + rect.width) + tolerance 
    rect_top = Math.min(rect.y, rect.y + rect.height) - tolerance
    rect_bottom = Math.max(rect.y, rect.y + rect.height) + tolerance
    return rect_left <= node.x && node.x <= rect_right && rect_top <= node.y && node.y <= rect_bottom
  }

  function iconizedGroupInRect(icoGroup, rect) {
    tolerance = icoGroup.radius
    rect_left = Math.min(rect.x, rect.x + rect.width) - tolerance
    rect_right = Math.max(rect.x, rect.x + rect.width) + tolerance 
    rect_top = Math.min(rect.y, rect.y + rect.height) - tolerance
    rect_bottom = Math.max(rect.y, rect.y + rect.height) + tolerance
    return rect_left <= icoGroup.x && icoGroup.x <= rect_right && rect_top <= icoGroup.y && icoGroup.y <= rect_bottom
  }

  function drawDragRectangle(event) {
      smartClearRect(event)
      const width = endX - startX;
      const height = endY - startY;
      ctx.beginPath()
      ctx.lineWidth = 1;
      //ctx.globalAlpha = 0.5; 
      ctx.strokeStyle = 'red';
      ctx.setLineDash([10, 5]);
      ctx.strokeRect(startX, startY, width, height);
      ctx.setLineDash([]);
      //ctx.globalAlpha = 1.0;
      prior_width = width
      prior_height = height
      ctx.closePath()
    }

    function selectAll() {
        for(const node of nodes) {
            select_node(node)
        }
        for(const edge of edges) {
            select_edge(edge)
        }
    }


  document.addEventListener('mousedown', function(event) {
    console.log('document got mousedown')
    killClickEvent = true
    if(isViableDrag(event)) {
        isDragging = true;
        startX = event.clientX - canvas.offsetLeft;
        startY = event.clientY - canvas.offsetTop;
        dragging_node = undefined
        dragging_iconizedGroup = undefined
        if(!group_processing_active) {
            if(active_grouping_rectangle == undefined || !isPointWithinToleranceOfDistanceToGroupingRectangle(startX, startY)) {
                dragging_node = get_clicked_on_node(event)  //undefined if not dragging a node
                dragging_iconizedGroup = get_clicked_on_iconizedGroup(event)
                if(active_grouping_rectangle != undefined) {
                    killGroupingRectangle()
                }
                else {
                    killClickEvent = false
                }
            }
        }
        else {
            group_processing_active = false
        }
    }
  });

  function drawSelfLoop(node, dir=DIR_UP) {  //will also eventuall add an arrow if edges are directed
        let x = node.x
        let y = node.y
        ctx.lineWidth = EDGE_WIDTH;  
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        if(dir==DIR_UP) {
            ctx.arc(x, y-SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_RIGHT) {
            ctx.arc(x+SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_DOWN) {
            ctx.arc(x, y+SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else {
            ctx.arc(x-SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        ctx.stroke(); 

        if(edge_type == TYPE_DIRECTED) {
            let dx = dy = 0;
            let midX = node.x
            let midY = node.y
            if(dir == DIR_UP) {
                dx = 10  //arrow should point right
                midX += ARROW_HEAD_LENGTH/2
                midY -= 2*(SELF_LOOP_RADIUS)
            }
            else if(dir == DIR_RIGHT) {
                dy = 10  //arrow should point down
                midX += 2*(SELF_LOOP_RADIUS)
                midY += ARROW_HEAD_LENGTH/2
            }
            else if(dir == DIR_DOWN) {
                dx = -10  //arrow should point to the left
                midX -= ARROW_HEAD_LENGTH/2
                midY += 2*(SELF_LOOP_RADIUS)
            }
            else {
                dy = -10  //arrow should pont left
                midX -= 2*(SELF_LOOP_RADIUS)
                midY -= ARROW_HEAD_LENGTH/2
            }
            let angle = Math.atan2(-dy, -dx);

            ctx.beginPath();
            ctx.moveTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX, midY);
            ctx.lineTo(midX + ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), midY + ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = EDGE_COLOR
            ctx.fill();
        }
    }

    function eraseSelfLoop(node, dir=DIR_UP) {  //will also eventuall add an arrow if edges are directed 
        let x = node.x
        let y = node.y
        ctx.lineWidth = EDGE_WIDTH*2;  
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        if(dir==DIR_UP) {
            ctx.arc(x, y-SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_RIGHT) {
            ctx.arc(x+SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else if(dir==DIR_DOWN) {
            ctx.arc(x, y+SELF_LOOP_RADIUS, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }
        else {
            ctx.arc(x-SELF_LOOP_RADIUS, y, SELF_LOOP_RADIUS, 0, 2 * Math.PI);
        }

        ctx.stroke(); 

        if(edge_type == TYPE_DIRECTED) {  //a lot of redundant code here!!
            let dx = dy = 0;
            let midX = node.x
            let midY = node.y
            ERASURE_BUFF = 2
            if(dir == DIR_UP) {
                dx = 10  //arrow should point right
                midX += (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
                midY -= 2*(SELF_LOOP_RADIUS)
            }
            else if(dir == DIR_RIGHT) {
                dy = 10  //arrow should point down
                midX += 2*(SELF_LOOP_RADIUS)
                midY += (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
            }
            else if(dir == DIR_DOWN) {
                dx = -10  //arrow should point to the left
                midX -= (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
                midY += 2*(SELF_LOOP_RADIUS)
            }
            else {
                dy = -10  //arrow should pont left
                midX -= 2*(SELF_LOOP_RADIUS)
                midY -= (ARROW_HEAD_LENGTH+ERASURE_BUFF)/2
            }
            let angle = Math.atan2(-dy, -dx);

            ctx.beginPath();
            ctx.lineWidth = 2*EDGE_WIDTH
            ctx.strokeStyle = "white"
            ctx.moveTo(midX + (ARROW_HEAD_LENGTH+ERASURE_BUFF) * Math.cos(angle - Math.PI / 6), midY + (ARROW_HEAD_LENGTH+ERASURE_BUFF) * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX, midY);
            ctx.lineTo(midX + (ARROW_HEAD_LENGTH+ERASURE_BUFF)  * Math.cos(angle + Math.PI / 6), midY + (ARROW_HEAD_LENGTH+ERASURE_BUFF) * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = "white"
            ctx.fill();
        }
        draw_node(node)
    }

  function areThereNodesOnBothSides() {
    let nodesOnLeft = nodesOnRight = false
    for(let node of nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            nodesOnLeft = true
            if(nodesOnLeft && nodesOnRight) {
                return true
            }
        }
        else {
            nodesOnRight = true
            if(nodesOnLeft && nodesOnRight) {
                return true
            }
        }
    }
    return false
  }

  function isPointWithinToleranceOfDistanceToGroupingRectangle(x, y) {  //this is a tiny bit crude 
    tolerance = 10
    if((x >= active_grouping_rectangle.x && x <= active_grouping_rectangle.x + active_grouping_rectangle.width) && 
            ((y >= active_grouping_rectangle.y - tolerance && y <= active_grouping_rectangle.y + tolerance) ||
            (y >= active_grouping_rectangle.y + active_grouping_rectangle.height - tolerance && y <= active_grouping_rectangle.y + active_grouping_rectangle.height + tolerance))) {
                return true
    }
    if((y >= active_grouping_rectangle.y && y <= active_grouping_rectangle.y + active_grouping_rectangle.height) &&
            ((x >= active_grouping_rectangle.x - tolerance && x <= active_grouping_rectangle.x + tolerance) ||
            (x >= active_grouping_rectangle.x + active_grouping_rectangle.width - tolerance && x <= active_grouping_rectangle.x + active_grouping_rectangle.width + tolerance))) {
                return true
    }
    
    return false
     
  }

  function testSafeGroupingRectangleDragPoint(dx, dy) {
    //If too high or too low, return false regardless of the case
    if((active_grouping_rectangle.y + dy + GROUPING_BOX_BUFFER <= TOP_BUFFER) || 
            (active_grouping_rectangle.y + active_grouping_rectangle.height + dy - GROUPING_BOX_BUFFER >= canvas.height - NODE_DRAW_RADIUS)) {
        return false
    }
    
    //case grouping box just on the left
    if(active_grouping_rectangle.x + active_grouping_rectangle.width - GROUPING_BOX_BUFFER < DIVIDING_LINE_LOC) {
        return active_grouping_rectangle.x + dx + GROUPING_BOX_BUFFER > DIVIDING_LINE_BUFFER && 
                    active_grouping_rectangle.x + active_grouping_rectangle.width + dx - GROUPING_BOX_BUFFER < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER
    }
    //case grouping box just on the right
    if(active_grouping_rectangle.x + GROUPING_BOX_BUFFER > DIVIDING_LINE_LOC) {
        return active_grouping_rectangle.x + dx + GROUPING_BOX_BUFFER > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
                    active_grouping_rectangle.x + active_grouping_rectangle.width + dx - GROUPING_BOX_BUFFER < canvas.width - NODE_DRAW_RADIUS
    }
    //case grouping box spans both sides
    return active_grouping_rectangle.x + dx + GROUPING_BOX_BUFFER > DIVIDING_LINE_BUFFER && 
        exists_side_grouping_control_point + dx < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER &&
        forall_side_grouping_control_point + dx > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
        active_grouping_rectangle.x + active_grouping_rectangle.width + dx - GROUPING_BOX_BUFFER < canvas.width - NODE_DRAW_RADIUS      
  }

  function handleGroupingRectangleDrag() {
    let dx = endX - startX
    let dy = endY - startY
    if(!testSafeGroupingRectangleDragPoint(dx, dy)) {
        return
    }
    startX = endX
    startY = endY
    for(let node of selected_nodes) {
        node.x += dx
        node.y += dy
        orderInputBox = node_id_to_inputBox_map.get(node.id)
        orderInputBox.style.left = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
        orderInputBox.style.top = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        constantBox = node_id_to_constantBox_map.get(node.id)
        if(constantBox != undefined) {
            constantBox.style.left = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
            constantBox.style.top = "" + (node.y + CONSTANT_BOX_OFFSET_Y) + "px"
        }
    }
    for(let icoGroup of selected_iconizedGroups) {
        icoGroup.x += dx
        icoGroup.y += dy
    }
    redrawAll()
    drawGroupingRectangle(UNSELECT_COLOR)
    active_grouping_rectangle.x += dx
    active_grouping_rectangle.y += dy
    exists_side_grouping_control_point += dx
    forall_side_grouping_control_point += dx
    drawGroupingRectangle("grey")
  }

 document.addEventListener('mousemove', function(event) {
    BUFF = 100 //Buffer for redrawing around node mins and maxes
    endX = event.clientX - canvas.offsetLeft;
    endY = event.clientY - canvas.offsetTop;
    if(active_grouping_rectangle != undefined) {
        if(isPointWithinToleranceOfDistanceToGroupingRectangle(endX, endY)) {
            document.body.style.cursor = "move"
        }
        else {
            document.body.style.cursor = "default"
        }
    }
    else {
        document.body.style.cursor = "default"
    }
    if (!isDragging) return;
    if(active_grouping_rectangle != undefined) {
        handleGroupingRectangleDrag(event)
    }
    else if(Math.abs(endX-startX) > 5 || Math.abs(endY-startY) > 5 ) {
        wasDragging = true
        if(dragging_node == undefined && dragging_iconizedGroup == undefined) {
            drawDragRectangle(event);
        }
        else {
            if(dragging_node != undefined) {
                if(  //don't allow dragging of a node too close to dividing line, too close to left edge,  or above top buffer
                    endY > TOP_BUFFER && endX > DIVIDING_LINE_BUFFER && endX < canvas.width - NODE_DRAW_RADIUS && endY < canvas.height - NODE_DRAW_RADIUS &&
                    ((startX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER && 
                            endX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) ||
                    (startX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
                            endX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER))) {
                    if(!selected_nodes.has(dragging_node)) {
                        select_node(dragging_node)
                    }
                    if(selected_nodes.size + selected_iconizedGroups.size + selected_edges.size 
                        + selected_ultraEdges.size > 1) {
                        clearSelectionFromAllButNode(dragging_node)
                    }
                    dragging_node.x = endX
                    dragging_node.y = endY
                    orderInputBox = node_id_to_inputBox_map.get(dragging_node.id)
                    orderInputBox.style.left = "" + (endX + ORDERING_BOX_OFFSET_X) + "px"
                    orderInputBox.style.top = "" + (endY + ORDERING_BOX_OFFSET_Y) + "px"
                    constantBox = node_id_to_constantBox_map.get(dragging_node.id)
                    if(constantBox != undefined) {
                        constantBox.style.left = "" + (endX + CONSTANT_BOX_OFFSET_X) + "px"
                        constantBox.style.top = "" + (endY + CONSTANT_BOX_OFFSET_Y) + "px"
                    }
                    minX = minY = INFINITE
                    maxX = maxY = INFINITE
                    for(let node of nodes) {
                        if(node.x - BUFF < minX) {
                            minX = node.x - BUFF
                        }
                        if(node.x + BUFF > maxX) {
                            maxX = node.x + BUFF
                        }
                        if(node.y - BUFF < minY) {
                            minY = node.y - BUFF
                        }
                        if(node.y + BUFF > maxY) {
                            maxY = node.x + BUFF
                        }
                    }
                    for(let icoGroup of iconizedGroups) {
                        if(icoGroup.x - BUFF < minX) {
                            minX = icoGroup.x - BUFF
                        }
                        if(icoGroup.x + BUFF > maxX) {
                            maxX = icoGroup.x + BUFF
                        }
                        if(icoGroup.y - BUFF < minY) {
                            minY = icoGroup.y - BUFF
                        }
                        if(icoGroup.y + BUFF > maxY) {
                            maxY = icoGroup.x + BUFF
                        }
                    }
                    redrawRectangle(minX, minY, maxX-minX, maxY-minY)
                }
            }
            else { //case we are dragging an IconizedGroup
                if(  //don't allow dragging of a node too close to dividing line, too close to left edge,  or above top buffer
                    endY > TOP_BUFFER && endX > DIVIDING_LINE_BUFFER && endX < canvas.width - dragging_iconizedGroup.radius && endY < canvas.height - dragging_iconizedGroup.radius &&
                    ((startX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER && 
                            endX < DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) ||
                    (startX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER && 
                            endX > DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER))) {
                    if(!selected_iconizedGroups.has(dragging_iconizedGroup)) {
                        select_iconizedGroup(dragging_iconizedGroup)
                    }
                    if(selected_nodes.size + selected_iconizedGroups.size + selected_edges.size 
                        + selected_ultraEdges.size > 1) {
                        clearSelectionFromAllButIconizedGroup(dragging_iconizedGroup)
                    }
                    dragging_iconizedGroup.x = endX
                    dragging_iconizedGroup.y = endY
                    minX = minY = INFINITE
                    maxX = maxY = INFINITE
                    for(let node of nodes) {
                        if(node.x - BUFF < minX) {
                            minX = node.x - BUFF
                        }
                        if(node.x + BUFF > maxX) {
                            maxX = node.x + BUFF
                        }
                        if(node.y - BUFF < minY) {
                            minY = node.y - BUFF
                        }
                        if(node.y + BUFF > maxY) {
                            maxY = node.x + BUFF
                        }
                    }
                    for(let icoGroup of iconizedGroups) {
                        if(icoGroup.x - BUFF < minX) {
                            minX = icoGroup.x - BUFF
                        }
                        if(icoGroup.x + BUFF > maxX) {
                            maxX = icoGroup.x + BUFF
                        }
                        if(icoGroup.y - BUFF < minY) {
                            minY = icoGroup.y - BUFF
                        }
                        if(icoGroup.y + BUFF > maxY) {
                            maxY = icoGroup.x + BUFF
                        }
                    }
                    redrawRectangle(minX, minY, maxX-minX, maxY-minY)
                }
            }
        }
    }
      
  }, true);

  document.addEventListener('mouseup', function(event) {
    let grid_dialog = document.getElementById("grid_dialog")
    let iconization_dialog = document.getElementById("iconization_dialog")
    if(grid_dialog.open || iconization_dialog.open) { 
        isDragging = false 
        return
    }
    isDragging = false;
    if(wasDragging) {
        if(active_grouping_rectangle == undefined) {
            smartClearRect(event)
            if(dragging_node == undefined && dragging_iconizedGroup == undefined) {
                selectionRect = new Rectangle(startX, startY, endX - startX, endY - startY)
                if(!event.shiftKey && !event.metaKey) { 
                    clearSelection()
                }
                for(const node of nodes) {
                    if(nodeInRect(node, selectionRect)) {
                        select_node(node)
                    }
                }
                for(const icoGroup of iconizedGroups) {
                    if(iconizedGroupInRect(icoGroup, selectionRect)) {
                        select_iconizedGroup(icoGroup)
                    }
                }
                for(const edge of edges) {
                    if(nodeInRect(edge.node1, selectionRect) && nodeInRect(edge.node2, selectionRect)) {
                        select_edge(edge)
                    }
                }
                for(const ultraEdge of ultraEdges) {
                    let obj1_in = obj2_in = false
                    if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                        obj1_in = iconizedGroupInRect(ultraEdge.obj1 , selectionRect)
                    }
                    else {
                        obj1_in = nodeInRect(ultraEdge.obj1 , selectionRect)
                    }
                    if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                        obj2_in = iconizedGroupInRect(ultraEdge.obj2 , selectionRect)
                    }
                    else {
                        obj2_in = nodeInRect(ultraEdge.obj2 , selectionRect)
                    }
                    if(obj1_in && obj2_in) {
                        select_ultraEdge(ultraEdge)
                    }
                }
            }
            else {
                draw_all_nodes()
                for(let node of selected_nodes) {
                    select_node(node)
                }
                for(let icoGroup of selected_iconizedGroups) {
                    select_iconizedGroup(icoGroup)
                }
                for(let edge of selected_edges) {
                    select_edge(edge)
                }
                for(let ultraEdge of selected_ultraEdges) {
                    select_ultraEdge(ultraEdge)
                }
            }
        }
    }

  }, true);

  async function rejectDuplicatorMove() {
    //beep()
    const context = new AudioContext();  //use this code in the beep() function!!
    const oscillator = context.createOscillator();
    const gainNode = context.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(context.destination);

    oscillator.type = 'sine'; // You can change the type: sine, square, triangle, sawtooth
    oscillator.frequency.value = 600; // Frequency in Hz
    gainNode.gain.setValueAtTime(0.1, context.currentTime); // Adjust volume (0 to 1)

    oscillator.start();
    oscillator.stop(context.currentTime + 0.2); // Duration of the beep (in seconds)
    alert("Duplicator must play on the opposite side from Spoiler!")  //change to using a custom alert box so beep() is heard first
  }

  function freezePage() {
    //does not disable click events and keyboard events except on buttons
    const overlay = document.createElement('div');
    overlay.id = 'page-overlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.25)'; // Semi-transparent black
    overlay.style.zIndex = '9999'; // Ensure it's on top
    page_is_frozen = true
    
    document.body.appendChild(overlay);
  }

  function unfreezePage() {
    const overlay = document.getElementById('page-overlay');
    if (overlay) {
        overlay.remove();
    }
    page_is_frozen = false
  }

  async function launchIconizedGroupPopup(icoGroup) {  //should popup a smaller window with just 
                            //the one side (top bar with just the exists/forall button and shading)
    //wh_string = "width=" + window.innerWidth/2 + ",height=" + window.innerHeight   
    wh_string = "width=" + canvas.width/2 + ",height=" + canvas.height      
    if(which_side == FORALL_SIDE) {
        wh_string += (",left=" + canvas.width/2)
    }
    //document.body.style.backgroundColor = "lightgrey" // could do this and deactivate....
    contextMenu.style.display = ''  //unpop the context menu
    icoGroup_being_edited = icoGroup
    freezePage()
    child_window = window.open("ico_group_editor.html", "_blank", wh_string)
    await delay(250); 
    child_window.postMessage(getIcoGroupJSON(icoGroup), '*'); 
  }

  window.addEventListener('beforeunload', (e) => {
    //kill children and send parent a cancel message
    if(!dont_send_cancel_on_close) {
        sendDieMessageDown()
        sendCancelMessageUp()
    }
  });

  async function sendCancelMessageUp() {
    msg = "{\"cancel\": true}"
    window.opener.postMessage(msg, '*');   
    await delay(1000); 
    //window.close();  //caller should close
    dont_send_cancel_on_close = true
  }

  async function sendDieMessageDown() {
    if(child_window == undefined) {
        return
    }
    msg = "{\"die\": true}"
    child_window.postMessage(msg, '*');   
    await delay(1000); 
    //window.close();  //caller should close
  }

  async function sendBoardContentsUp() {
    window.opener.postMessage(getBoardJSON(), '*'); 
    await delay(1000); 
    //window.close();  //caller should close
  }

  document.addEventListener('click', function(event) {  
    if(page_is_frozen) {
        return
    }
    dialog = document.getElementById("grid_dialog")
    let grid_dialog = document.getElementById("grid_dialog")
    let iconization_dialog = document.getElementById("iconization_dialog")
    if(grid_dialog.open || cycle_dialog.open || iconization_dialog.open) {  //don't process clicks when a modal dialog is being displayed!
        return
    }
    if (contextMenu.style.display != '') { // && !contextMenuDiv.contains(event.target)) {
      contextMenu.style.display = '';
      return
    }
    if(killClickEvent || !process_click(event)) {
        return
    }
    click_point = new Point(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop)
    icoGroup = get_clicked_on_iconizedGroup(event)    
    if(icoGroup != undefined) {
        if(event.shiftKey || event.metaKey) {
            toggle_select_iconizedGroup(icoGroup)  
        }
        else {
            clearSelectionFromAllButIconizedGroup(icoGroup)  //check that this works properply with icoGroups!
            toggle_select_iconizedGroup(icoGroup)   
        }
    }
    else {
        node = click_to_node(event)
        if(!nodes.has(node)) {
            //did user click near an existing edge? If so, select it 
            let distance_to_closest_edge = INFINITE
            let closest_edge = undefined
            for(let edge of edges) {
                let d = getPointToEdgeDistance(click_point, edge)
                if(d < distance_to_closest_edge) {
                    closest_edge = edge
                    distance_to_closest_edge = d
                }
            }
            if(distance_to_closest_edge <= EDGE_CLICK_TOLERANCE) {
                if(event.shiftKey || event.metaKey) {
                    toggle_select_edge(closest_edge)
                }
                else {
                    clearSelectionFromAllButEdge(closest_edge)
                    toggle_select_edge(closest_edge)
                }
                return
            }
            //did user click near an existing UltraEdge? If so, select it 
            let distance_to_closest_ultraEdge = INFINITE
            let closest_ultraEdge = undefined
            for(let ultraEdge of ultraEdges) {
                let d = getPointToUltraEdgeDistance(click_point, ultraEdge)
                if(d < distance_to_closest_ultraEdge) {
                    closest_ultraEdge = ultraEdge
                    distance_to_closest_ultraEdge = d
                }
            }
            if(distance_to_closest_ultraEdge <= EDGE_CLICK_TOLERANCE) {
                if(event.shiftKey || event.metaKey) {
                    toggle_select_ultraEdge(closest_ultraEdge)
                }
                else {
                    clearSelectionFromAllButUltraEdge(closest_ultraEdge)
                    toggle_select_ultraEdge(closest_ultraEdge)
                }
            }
            else if(selected_nodes.size > 0 || selected_edges.size > 0 || 
                selected_iconizedGroups.size > 0 || selected_ultraEdges.size > 0) {
                clearSelection()
            }
            else {
                create_node(node)
            }
        }
        else {
            if(event.shiftKey || event.metaKey) {
                toggle_select_node(node)
            }
            else {
                clearSelectionFromAllButNode(node)
                toggle_select_node(node)
            }
            
        }
    }
  });

  contextMenuItems = ['Order Nodes', 'Display Node Ordering', 'Order Selected Nodes Left to Right', 
                                'Shrink Selection', 'Expand Selection', 'Insert Grid of Nodes...', 'Insert a Cycle of Nodes...']
  contextMenuPrefix = ['', '', '', '', '', '' , '']
  ORDER_NODES_INDEX = 0
  DISPLAY_ORDERINGS_INDEX = 1
  ORDER_LEFT_TO_RIGHT_INDEX = 2
  SHRINK_SELECTED_INDEX = 3
  EXPAND_SELECTED_INDEX = 4
  INSERT_GRID_INDEX = 5
  INSERT_CYCLE_INDEX = 6
  nodeContextMenuItems = ['Assign a Constant', 'Create a Self-Loop    \u25BE']
  ASSIGN_CONSTANT_INDEX = 0
  SELF_LOOP_INDEX = 1
  selfLoopMenuItems = ['Above', 'To the Right', 'Below', 'To the Left']
  LOOP_ABOVE_INDEX = 0
  LOOP_RIGHT_INDEX = 1
  LOOP_BELOW_INDEX = 2
  LOOP_LEFT_INDEX = 3
  groupMenuItems = ['Iconize Group', 'Ungroup']
  ICONIZE_INDEX = 0
  UNGROUP_INDEX = 1
  iconizedGroupContextMenuItems = ['Change Icon/Label','Edit Group Contents', 'Explode Iconized Group']
  ICO_GROUP_CHANGE_ICON_INDEX = 0
  ICO_GROUP_EDIT_INDEX = 1
  ICO_GROUP_EXPAND_INDEX = 2

  function getNodeSelfLoopDir(node) {
    for(let edge of node.edges) {
        if(edge.dir != DIR_NONE) {
            return edge.dir
        }
    }
    return DIR_NONE
  }

  document.addEventListener('contextmenu', function(event) { //clean up this code at some point!!
        if(page_is_frozen) {
            return
        }
        event.preventDefault();
        let grid_dialog = document.getElementById("grid_dialog")
        let iconization_dialog = document.getElementById("iconization_dialog")
        if(grid_dialog.open || iconization_dialog.open) {  //don't display context menu when a modal dialog is being displayed!
            return
        }
        contextMenuClickPoint = new Point(event.clientX, event.clientY)
        subMenuItems = []
        clicked_on_node = get_clicked_on_node(event)
        clicked_on_iconizedGroup = get_clicked_on_iconizedGroup(event)
        if(clicked_on_node != undefined) {   //context menu when someone clicks on a node
            clearSelectionFromAllButNode(clicked_on_node)
            select_node(clicked_on_node)
            contextMenuApproximateSize = 140 //in pixels
            constantBox = node_id_to_constantBox_map.get(clicked_on_node.id)
            if(constantBox == undefined) {
                nodeContextMenuItems[ASSIGN_CONSTANT_INDEX] = 'Assign a Constant'
            }
            else {
                nodeContextMenuItems[ASSIGN_CONSTANT_INDEX] = 'Remove Constant'
            }
            let self_loop_dir = getNodeSelfLoopDir(clicked_on_node)
            if(self_loop_dir != DIR_NONE) {
                nodeContextMenuItems[SELF_LOOP_INDEX] = 'Move Self-Loop    \u25BE'
            }
            else {
                nodeContextMenuItems[SELF_LOOP_INDEX] = 'Create a Self-Loop    \u25BE'
            }
            
            for(let i=0; i < nodeContextMenuItems.length; i++) {
                subMenuItems.push({ text: nodeContextMenuItems[i], action: () => nodeContextMenuHandler(clicked_on_node, i)})
            }

            contextMenuList.innerHTML = '';
            selfLoopMenuItemElement = undefined
            selfLoopMenuList.replaceChildren();
            subSubMenuItemsCreated = false

            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                subMenuItemElement.style.color = "black"
                subMenuItemElement.addEventListener('click', item.action);    
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == SELF_LOOP_INDEX) {
                    selfLoopMenuItemElement = subMenuItemElement
                    subMenuItemElement.addEventListener('mouseover', function(event) {
                        //new stuff for subSubMenuItems
                        if(!subSubMenuItemsCreated) {
                            subSubMenuItems = []
                            subSubMenuItemsCreated = true
                            selfLoopMenuList.replaceChildren();
                            selfLoopMenuItemElement.appendChild(selfLoopMenuList)
                            for(let i=0; i < selfLoopMenuItems.length; i++) {
                                subSubMenuItems.push({ text: selfLoopMenuItems[i], action: () => selfLoopContextMenuHandler(clicked_on_node, i)})
                            }
                            for(let i=0; i<subSubMenuItems.length; i++) {
                                item = subSubMenuItems[i]
                                let subSubMenuItemElement = document.createElement('li');
                                subSubMenuItemElement.textContent = item.text;
                                if(self_loop_dir != i) {
                                    subSubMenuItemElement.style.color = "black"
                                }
                                else {
                                    subSubMenuItemElement.style.color = "grey"
                                }
                                subSubMenuItemElement.addEventListener('click', item.action); 
                                selfLoopMenuList.appendChild(subSubMenuItemElement);
                            }
                        }
                    });
                }
                else {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                    subMenuItemElement.addEventListener('mouseover', function(event) { 
                        subSubMenuItems = [] 
                        selfLoopMenuList.replaceChildren();
                        subSubMenuItemsCreated = false
                    })
                }
                ctr++
            });

            

        }
        //Check if context click is on a grouping rectangle
        else if(active_grouping_rectangle != undefined && 
            isPointWithinToleranceOfDistanceToGroupingRectangle(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop)) {
            contextMenuApproximateSize = 50 //needs to be more carefully specified
            for(let i=0; i < groupMenuItems.length; i++) {
                if(i == ICONIZE_INDEX) {
                    subMenuItems.push({ text: groupMenuItems[i], action: () => iconizeGroup()})
                }
                else {
                    subMenuItems.push({ text: groupMenuItems[i], action: () => killGroupingRectangle()})
                }
            }
            contextMenuList.innerHTML = '';
            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                subMenuItemElement.style.color = "black"
                subMenuItemElement.addEventListener('click', item.action);
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == ICONIZE_INDEX) {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                }
                ctr++
            });
            group_processing_active = true
        }
        else if(clicked_on_iconizedGroup != undefined) { //submenu when someone clicks on an icoGroup
            clearSelectionFromAllButIconizedGroup(clicked_on_iconizedGroup)
            select_iconizedGroup(clicked_on_iconizedGroup)
            contextMenuApproximateSize = 200 //in pixels
            for(let i=0; i < iconizedGroupContextMenuItems.length; i++) {
                subMenuItems.push({ text: iconizedGroupContextMenuItems[i], action: () => iconizedGroupContextMenuHandler(clicked_on_iconizedGroup, i)})
            }
            contextMenuList.innerHTML = '';
            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                subMenuItemElement.style.color = "black"
                subMenuItemElement.addEventListener('click', item.action);
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == ICO_GROUP_EDIT_INDEX) {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                }
                ctr++
            });
        }
        else {  //context menu when someone clicks on anything other than a node, iconizedGroup, 
                // or a grouping rectangle (perhaps we need one for clicking on an edge too....)
            contextMenuApproximateSize = 270 //in pixels
            for(let i=0; i < contextMenuItems.length; i++) {
                subMenuItems.push({ text: contextMenuPrefix[i] + contextMenuItems[i], action: () => contextMenuHandler(i)})
            }

            contextMenuList.innerHTML = '';

            ctr = 0
            subMenuItems.forEach(item => {
                let subMenuItemElement = document.createElement('li');
                subMenuItemElement.textContent = item.text;
                if( (ctr == DISPLAY_ORDERINGS_INDEX && !nodes_are_ordered) ||
                    ctr == ORDER_LEFT_TO_RIGHT_INDEX && (!nodes_are_ordered || selected_nodes.size == 0) ||
                    (ctr == SHRINK_SELECTED_INDEX || ctr == EXPAND_SELECTED_INDEX) && selected_nodes.size + selected_iconizedGroups.size < 2) {
                    subMenuItemElement.style.color = "grey"
                    subMenuItemElement.style.pointerEvents = "none"
                }
                else {
                    subMenuItemElement.style.color = "black"
                    subMenuItemElement.addEventListener('click', item.action);
                }
                contextMenuList.appendChild(subMenuItemElement);
                if(ctr == ORDER_LEFT_TO_RIGHT_INDEX || ctr == EXPAND_SELECTED_INDEX) {
                    subMenuItemElement = document.createElement('hr');
                    contextMenuList.appendChild(subMenuItemElement);
                }
                ctr++
            });
        }

       
        let CONTEXT_MENU_PUSHUP_BUFF = 0
        if(event.clientY + contextMenuApproximateSize > window.innerHeight) {
            CONTEXT_MENU_PUSHUP_BUFF = event.clientY + contextMenuApproximateSize - window.innerHeight
        }
        contextMenuDiv.style.left = `${event.clientX}px`;
        contextMenuDiv.style.top = `${event.clientY - CONTEXT_MENU_PUSHUP_BUFF}px`;
        contextMenuDiv.style.display = 'block';
        contextMenuDiv.style.fontFamily = "Arial, Helvetica, sans-serif";
        contextMenuDiv.style.fontWeight = "Bold";
        contextMenuDiv.style.fontSize = "10pt";
  }, false);

  function deleteSelectedNodes() {
    selected_nodes_list = Array.from(selected_nodes)
    for(let i=0; i<selected_nodes_list.length; i++) {
        unselect_node(selected_nodes_list[i])
        delete_node(selected_nodes_list[i])
    }
  }

  function deleteSelectedEdges() {
    selected_edge_list = Array.from(selected_edges)
    for(let i=0; i<selected_edge_list.length; i++) {
        unselect_edge(selected_edge_list[i])
        delete_edge(selected_edge_list[i])
    }
  }

  function deleteSelectedUltraEdges() {
    selected_ultraEdge_list = Array.from(selected_ultraEdges)
    for(let i=0; i<selected_ultraEdge_list.length; i++) {
        unselect_ultraEdge(selected_ultraEdge_list[i])
        delete_ultraEdge(selected_ultraEdge_list[i])
    }
  }

  function deleteSelectedIconizedGroups() {
    selected_iconizedGroup_list = Array.from(selected_iconizedGroups)
    for(let i=0; i<selected_iconizedGroup_list.length; i++) {
        unselect_iconizedGroup(selected_iconizedGroup_list[i])
        for(let uEdge of selected_iconizedGroup_list[i].ultraEdges) {
            delete_ultraEdge(uEdge)
        }
        delete_iconizedGroup(selected_iconizedGroup_list[i])
    }
  }

  function getAllPairsOfSelectedElements() {  //only return pairs on the same side
    pairs = []
    selected_nodes_list = Array.from(selected_nodes)
    for (let i = 0; i < selected_nodes_list.length - 1; i++) {
        for (let j = i + 1; j < selected_nodes_list.length; j++) {
            if((selected_nodes_list[i].x - DIVIDING_LINE_LOC)*(selected_nodes_list[j].x - DIVIDING_LINE_LOC) > 0) {
                pairs.push([selected_nodes_list[i], selected_nodes_list[j]]);
            }
        }
    }
    selected_icoGroup_list = Array.from(selected_iconizedGroups)
    for (let i = 0; i < selected_icoGroup_list.length - 1; i++) {
        for (let j = i + 1; j < selected_icoGroup_list.length; j++) {
            if((selected_icoGroup_list[i].x - DIVIDING_LINE_LOC)*(selected_icoGroup_list[j].x - DIVIDING_LINE_LOC) > 0) {
                pairs.push([selected_icoGroup_list[i], selected_icoGroup_list[j]]);
            }
        }
    }
    for (let i = 0; i < selected_nodes_list.length; i++) {
        for (let j = 0; j < selected_icoGroup_list.length; j++) {
            if((selected_nodes_list[i].x - DIVIDING_LINE_LOC)*(selected_icoGroup_list[j].x - DIVIDING_LINE_LOC) > 0) {
                pairs.push([selected_nodes_list[i], selected_icoGroup_list[j]]);
            }
        }
    }

    return pairs
  }

  function equalEdges(edge1, edge2) { 
    if(edge_type == TYPE_UNDIRECTED) {
        return ((edge1.node1 == edge2.node1 && edge1.node2 == edge2.node2) ||
        (edge1.node1 == edge2.node2 && edge1.node2 == edge2.node1))
    }
    else {
        return edge1.node1 == edge2.node1 && edge1.node2 == edge2.node2
    }
  }

  function edgeInEdges(edge) {
    for(const e of edges) {
        if(equalEdges(e, edge)) {
            return true
        }
    }
    return false
  }

  function ultraEdgeInUltraEdges(ultraEdge) {
    for(const u of ultraEdges) {
        if(equalUltraEdges(u, ultraEdge)) {
            return true
        }
    }
    return false
  }

  function getYCoordOfLowestNode(whichSide) {
    lowestY = 0
    for(let node of nodes) {
        if(whichSide == BOTH_SIDES || (whichSide == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) || 
            (whichSide == FORALL_SIDE && node.x > DIVIDING_LINE_LOC)) {
            if(node.y > lowestY) {
                lowestY = node.y
            }
        }
    }

    return lowestY
  }

  function getYCoordOfHighestNode(whichSide) {
    highestY = 0
    for(let node of nodes) {
        if(whichSide == BOTH_SIDES || (whichSide == EXISTS_SIDE && node.x < DIVIDING_LINE_LOC) || 
            (whichSide == FORALL_SIDE && node.x > DIVIDING_LINE_LOC)) {
            if(node.y < highestY) {
                highestY = node.y
            }
        }
    }

    return highestY
  }

  document.addEventListener('keyup', function(event) {
    if(page_is_frozen) {
        return
    }
    if(event.key == "Delete" || event.key == "Backspace") {
        console.log("Delete selected requested.")
        deleteSelectedEdges() 
        deleteSelectedUltraEdges()
        deleteSelectedNodes()
        deleteSelectedIconizedGroups()
    }
    else if(event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27) {
        contextMenu.style.display = "none"
    }
    else if(event.key == "e" || event.key == "E") {
        if(edge_type == TYPE_DIRECTED) {
            //if(edges.size > 0 || ultraEdges.size > 0) {
            if(areThereNestedEdgesOrUltraEdges(undefined)) {
                beep()
                return
            }
            else {
                edge_type = TYPE_UNDIRECTED
            }
        }
        if(selected_nodes.size + selected_iconizedGroups.size >= 2) {
            pairs = getAllPairsOfSelectedElements()  //will only return pairs on the same side of the dividing line
            clearSelection()
            for(let i=0; i< pairs.length; i++) {
                if(!pairs[i][0].hasOwnProperty("num_sides") &&  !pairs[i][1].hasOwnProperty("num_sides")) {
                    edge = new Edge(pairs[i][0], pairs[i][1])
                    if(!edgeInEdges(edge)) {
                        create_edge(edge)
                    }
                }
                else {
                    ultraEdge = new UltraEdge(pairs[i][0], pairs[i][1])
                    if(!ultraEdgeInUltraEdges(ultraEdge)) {
                        create_ultraEdge(ultraEdge)
                    }
                }
            }
        }
    }
    else if(event.key == "d") {
        if(edge_type == TYPE_UNDIRECTED) {
            if(areThereNestedEdgesOrUltraEdges(undefined)) {
                beep()
                return
            }
            else {
                edge_type = TYPE_DIRECTED
            }
        }
        if(selected_nodes.size + selected_iconizedGroups.size >= 2) {
            pairs = getAllPairsOfSelectedElements()  //will only return pairs on the same side of the dividing line
            clearSelection()
            for(let i=0; i< pairs.length; i++) {
                if(!pairs[i][0].hasOwnProperty("num_sides") &&  !pairs[i][1].hasOwnProperty("num_sides")) {
                    edge = new Edge(pairs[i][0], pairs[i][1])
                    if(!edgeInEdges(edge)) {
                        create_edge(edge)
                    }
                }
                else {
                    ultraEdge = new UltraEdge(pairs[i][0], pairs[i][1])
                    if(!ultraEdgeInUltraEdges(ultraEdge)) {
                        create_ultraEdge(ultraEdge)
                    }
                }
            }
        }
    }
    else if(event.key == "r") {  //reverse the direction of any selected directed edges
        if(edge_type == TYPE_UNDIRECTED || (selected_edges.size == 0 && selected_ultraEdges == 0)) {
            //beep()
            return
        }
        for(let edge of selected_edges) {
            erase_edge(edge)
            temp_node = edge.node1
            edge.node1 = edge.node2
            edge.node2 = temp_node
            draw_edge(edge) 
            select_edge(edge)   
        }
        for(let ultraEdge of selected_ultraEdges) {
            erase_ultraEdge(ultraEdge)
            temp_obj = ultraEdge.obj1
            ultraEdge.obj1 = ultraEdge.obj2
            ultraEdge.obj2 = temp_obj
            draw_ultraEdge(ultraEdge) 
            select_ultraEdge(ultraEdge)   
        }
    }
    else if(event.key == "R") {  //add an additional edge in the reverse direction (needs to be completely implemented)
                                //also need to be able to directly add a second directed edge by clicking on respective 
                                // ordered vertices
        if(edge_type == TYPE_UNDIRECTED || (selected_edges.size == 0 && selected_ultraEdges == 0)) {
            //beep()
            return
        }
        for(let edge of selected_edges) {
            reverse_edge = new Edge(edge.node2, edge.node1)
            edge.node1.edges.add(reverse_edge)
            edge.node2.edges.add(reverse_edge)
            edges.add(reverse_edge)
            draw_edge(reverse_edge)    
        }
        for(let ultraEdge of selected_ultraEdges) {
            reverse_ultraEdge = new UltraEdge(ultraEdge.obj2, ultraEdge.obj1)
            ultraEdge.obj1.edges.add(reverse_ultraEdge)
            ultraEdge.obj2.edges.add(reverse_ultraEdge)
            ultraEdges.add(reverse_ultraEdge)
            draw_ultraEdge(reverse_ultraEdge)    
        }
        clearSelection()
    }
    else if(event.key == 'g') {
        if(!event.metaKey) {
            handleGrouping()
        }
        else {
            event.preventDefault()
            if(areThereNodesOnBothSides()) {
                startGame()
            }
            else {
                beep()
            }
        }
    }
    else if(event.key == 'u') {  //for undirected ultraEdge
        if(selected_nodes.size + selected_iconizedGroups.size >= 2) {
            pairs = getAllPairsOfSelectedElements()  //will only return pairs on the same side of the dividing line
            let someViableUltraPairs = false
            for(let i=0; i< pairs.length; i++) {
                if(!pairs[i][0].hasOwnProperty("num_sides") && !pairs[i][1].hasOwnProperty("num_sides")) {
                    //ignore
                }
                else {
                    if(!someViableUltraPairs) {
                        clearSelection()
                        someViableUltraPairs = true
                    }
                    ultraEdge = new UltraEdge(pairs[i][0], pairs[i][1])
                    if(!ultraEdgeInUltraEdges(ultraEdge)) {
                        create_ultraEdge(ultraEdge)
                    }
                }
            }
            if(!someViableUltraPairs) {
                beep()
            }
        }
    }

  });

  function handleGrouping() {
    //handle grouping/ungrouping
    if(selected_nodes.size + selected_iconizedGroups.size == 0) {
        beep()
        return
    }
    else if(selected_nodes.size + selected_iconizedGroups.size == 1) {
        alert("Cannot group a single node or iconized group!")
        return
    }
    else if(active_grouping_rectangle != undefined) {
        killGroupingRectangle()
    }
    else {
        let minX = canvas.width
        let maxX = 0
        let minY = canvas.height
        let maxY = 0
        let right_mostX_on_left_side = 0
        let left_mostX_on_right_side = canvas.width
        for(let node of selected_nodes) {
            if(node.x - NODE_DRAW_RADIUS < minX) {
                minX = node.x - NODE_DRAW_RADIUS
            }
            if(node.x + NODE_DRAW_RADIUS > maxX) {
                maxX = node.x + NODE_DRAW_RADIUS
            }
            if(node.y - NODE_DRAW_RADIUS < minY) {
                minY = node.y - NODE_DRAW_RADIUS
            }
            if(node.y + NODE_DRAW_RADIUS > maxY) {
                maxY = node.y + NODE_DRAW_RADIUS
            }
            if(node.x < DIVIDING_LINE_LOC && node.x + NODE_DRAW_RADIUS > right_mostX_on_left_side) {
                right_mostX_on_left_side = node.x + NODE_DRAW_RADIUS
            }
            else if(node.x > DIVIDING_LINE_LOC && node.x - NODE_DRAW_RADIUS < left_mostX_on_right_side) {
                left_mostX_on_right_side = node.x - NODE_DRAW_RADIUS
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            if(icoGroup.x - icoGroup.radius < minX) {
                minX = icoGroup.x - icoGroup.radius
            }
            if(icoGroup.x + icoGroup.radius > maxX) {
                maxX = icoGroup.x + icoGroup.radius
            }
            if(icoGroup.y - icoGroup.radius < minY) {
                minY = icoGroup.y - icoGroup.radius
            }
            if(icoGroup.y + icoGroup.radius > maxY) {
                maxY = icoGroup.y + icoGroup.radius
            }
            if(icoGroup.x < DIVIDING_LINE_LOC && icoGroup.x + icoGroup.radius > right_mostX_on_left_side) {
                right_mostX_on_left_side = icoGroup.x + icoGroup.radius
            }
            else if(icoGroup.x > DIVIDING_LINE_LOC && icoGroup.x - icoGroup.radius < left_mostX_on_right_side) {
                left_mostX_on_right_side = icoGroup.x - icoGroup.radius
            }
        }
        active_grouping_rectangle = new Rectangle(minX - GROUPING_BOX_BUFFER, minY - GROUPING_BOX_BUFFER, 
                maxX - minX + 2*GROUPING_BOX_BUFFER, maxY - minY + 2*GROUPING_BOX_BUFFER)
        if(maxX > DIVIDING_LINE_LOC && minX < DIVIDING_LINE_LOC) {
            exists_side_grouping_control_point = right_mostX_on_left_side
            forall_side_grouping_control_point = left_mostX_on_right_side
        }
        else {
            exists_side_grouping_control_point = undefined
            forall_side_grouping_control_point = undefined
        }
        console.log("exists_side_grouping_control_point = " + exists_side_grouping_control_point)
        console.log("forall_side_grouping_control_point = " + forall_side_grouping_control_point)
        drawGroupingRectangle("grey")
    }
  }

  function killGroupingRectangle() {
    drawGroupingRectangle(UNSELECT_COLOR)
    active_grouping_rectangle = undefined
    redrawAll()
  }

  function drawGroupingRectangleHandle(x, y, color) {
    ctx.beginPath()
    ctx.strokeStyle = color; // Set stroke color
    line_width = 1
    if(color == UNSELECT_COLOR) {
        line_width += 2
    }
    ctx.lineWidth = line_width; // Set line width 
    ctx.fillStyle = "white"; 
    ctx.fillRect(x-5, y-5, 10, 10); 
    ctx.strokeRect(x-5, y-5, 10, 10); 
    ctx.stroke()
    ctx.closePath()
  }

  function drawGroupingRectangle(color) {
    ctx.beginPath()
    ctx.strokeStyle = color; // Set stroke color
    line_width = 1
    if(color == UNSELECT_COLOR) {
        line_width += 2
    }
    ctx.lineWidth = line_width; // Set line width 
    ctx.setLineDash([10, 5]); // 5px line, 10px gap
    ctx.strokeRect(active_grouping_rectangle.x, active_grouping_rectangle.y, active_grouping_rectangle.width, active_grouping_rectangle.height); 
    ctx.stroke()
    ctx.closePath()
    ctx.setLineDash([])

    drawGroupingRectangleHandle(active_grouping_rectangle.x, active_grouping_rectangle.y, color)
    drawGroupingRectangleHandle(active_grouping_rectangle.x + active_grouping_rectangle.width, active_grouping_rectangle.y, color)
    drawGroupingRectangleHandle(active_grouping_rectangle.x, active_grouping_rectangle.y + active_grouping_rectangle.height, color)
    drawGroupingRectangleHandle(active_grouping_rectangle.x + active_grouping_rectangle.width, active_grouping_rectangle.y + active_grouping_rectangle.height, color)
  }



  function createButton(text, x, y) {
    const button = document.createElement('button');
    button.textContent = text;
    button.style.fontSize = "16px"
    button.style.position = 'absolute';
    button.style.left = `${x}px`;
    button.style.top = `${y}px`;
    document.body.appendChild(button);
    return button;
  }

  
  //who won area
  /*resultLabel = document.createTextNode('Game Result: ')
  const span0 = document.createElement('span');  
  span0.style.fontSize = "12pt"  
  span0.style.fontFamily = 'Arial, sans-serif';
  span0.style.position = 'absolute';
  span0.style.left = '10px'; 
  span0.style.top = '14px';
  document.body.appendChild(span0)
  span0.appendChild(resultLabel)
  inputWhoWon = document.createElement('input');
  inputWhoWon.type = 'text';
  inputWhoWon.style.position = 'absolute';
  inputWhoWon.style.left = '115px';
  inputWhoWon.style.top = '12px';
  inputWhoWon.style.width = '150px';
  inputWhoWon.style.height = '18px';
  inputWhoWon.style.textAlign = 'left'
  inputWhoWon.style.fontSize = "14pt"
  inputWhoWon.style.color = "red"
  inputWhoWon.value = ''
  inputWhoWon.disabled = true
  document.body.appendChild(inputWhoWon)*/

  //exists button stuff
  existsButtonPressed = false
  const existsButton = document.createElement('img');
  existsButton.src = 'exists_button.png';
  existsButton.draggable = false
  existsButton.width = 100
  existsButton.height = 25
  const span1 = document.createElement('span');
  document.body.appendChild(span1)
  span1.appendChild(existsButton)
  span1.style.fontSize = "20px"
  span1.style.position = 'absolute';
  loc_exists = DIVIDING_LINE_LOC/2 - 50
  span1.style.left = loc_exists.toString()+'px'; 
  span1.style.top = '10px';

  const confirmButton = document.createElement('button');
  confirmButton.textContent = 'Confirm';
  confirmButton.style.position = 'absolute';
  confirmButton.style.left = '70px'; // X-coordinate relative to container
  confirmButton.style.top = '12px'; // Y-coordinate relative to container
  confirmButton.style.zIndex = '10'; // Ensure button is above canvas if overlapping
  confirmButton.disabled = false;  
  confirmButton.addEventListener('click', () => {
        sendBoardContentsUp() 
        dont_send_cancel_on_close = true
        window.close();
    });
  document.body.appendChild(confirmButton)
  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancel';
  cancelButton.style.position = 'absolute';
  cancelButton.style.left = '150px'; // X-coordinate relative to container
  cancelButton.style.top = '12px'; // Y-coordinate relative to container
  cancelButton.style.zIndex = '10'; // Ensure button is above canvas if overlapping
  cancelButton.addEventListener('click', () => {
       //sendCancelMessageUp()
        window.close()  //cancel message gets sent on close
  });
  document.body.appendChild(cancelButton)
  /*existsButton.addEventListener('click', function() {
        if(!existsButtonPressed) {
            existsButton.src = 'exists_button_pressed_red2.png';
            forallButtonPressed = false;
            forallButton.src = 'forall_button.png';
        }
        else {
            existsButton.src = 'exists_button.png';
        }
        existsButtonPressed = !existsButtonPressed;
  });
  existsButton.addEventListener('mousedown', function() {
        existsButton.src = 'exists_button_pressed.png';
  });
  existsButton.addEventListener('mouseleave', function() {
    if(existsButtonPressed) {
        existsButton.src = 'exists_button_pressed_red2.png';
    }
    else {
        existsButton.src = 'exists_button.png';
    }
  });*/
  /*const span1a = document.createElement('span');  //this sits underneath the button and is just 
                                                  //so we can catch select all
  span1a.style.fontSize = "0px"  //effectively hidden
  span1a.style.position = 'absolute';
  span1a.style.left = loc_exists.toString()+'px'; 
  span1a.style.top = '10px';
  document.body.appendChild(span1a)
  textNode1 = document.createTextNode('\u2203 Side');
  span1a.appendChild(textNode1)*/

  /*span1.addEventListener("mouseover", function() {
    span1.style.cursor = "pointer";
  });
  span1.addEventListener("mouseleave", function() {
    span1.style.cursor = "default";
  });*/

  /*//forall button stuff
  forallButtonPressed = false
  const forallButton = document.createElement('img');
  forallButton.src = 'forall_button.png';
  forallButton.draggable = false
  forallButton.width = 100
  forallButton.height = 25
  const span2 = document.createElement('span');
  document.body.appendChild(span2)
  span2.appendChild(forallButton)
  span2.style.fontSize = "20px"
  span2.style.position = 'absolute';
  loc_forall = 3*DIVIDING_LINE_LOC/2 - 50
  span2.style.left = loc_forall.toString()+'px'; 
  span2.style.top = '10px';
  /*forallButton.addEventListener('click', function() {
        if(!forallButtonPressed) {
            forallButton.src = 'forall_button_pressed_red2.png';
            existsButtonPressed = false;
            existsButton.src = 'exists_button.png';
        }
        else {
            forallButton.src = 'forall_button.png';
        }
        forallButtonPressed = !forallButtonPressed;
  });
  forallButton.addEventListener('mousedown', function() {
    forallButton.src = 'forall_button_pressed.png';
  });
  forallButton.addEventListener('mouseleave', function() {
    if(forallButtonPressed) {
        forallButton.src = 'forall_button_pressed_red2.png';
    }
    else {
        forallButton.src = 'forall_button.png';
    }
  });*/
  /*const span2a = document.createElement('span');  //this sits underneath the button and is just 
                                                  //so we can catch select all
  span2a.style.fontSize = "0px"  //effectively hidden
  span2a.style.position = 'absolute';
  span2a.style.left = loc_forall.toString()+'px'; 
  span2a.style.top = '10px';
  document.body.appendChild(span2a)
  textNode2 = document.createTextNode('\u2200 Side');
  span2a.appendChild(textNode2)*/

  /*span2.addEventListener("mouseover", function() {
    span2.style.cursor = "pointer";
  });
  span2.addEventListener("mouseleave", function() {
    span2.style.cursor = "default";
  });*/

  /*numRdsLabel = document.createTextNode('Num Rounds: ')
  const span3 = document.createElement('span');  
  span3.style.fontSize = "12pt"  
  span3.style.fontFamily = 'Arial, sans-serif';
  span3.style.position = 'absolute';
  span_loc = 3*DIVIDING_LINE_LOC/4 - 105
  span3.style.left = span_loc.toString()+'px'; 
  span3.style.top = '14px';
  document.body.appendChild(span3)
  span3.appendChild(numRdsLabel)

  inputNumRds = document.createElement('input');
  inputNumRds.type = 'text';
  inputNumRds.style.position = 'absolute';
  inputNumRds.style.left = (3*DIVIDING_LINE_LOC/4) + 'px';
  inputNumRds.style.top = '12px';
  inputNumRds.style.width = '30px';
  inputNumRds.style.height = '18px';
  inputNumRds.style.textAlign = 'center'
  inputNumRds.style.fontSize = "12pt"
  inputNumRds.maxLength = 3
  inputNumRds.pattern = "[0-9]{3}"
  inputNumRds.value = ''
  inputNumRds.addEventListener('blur', function(event) {
    if(!isNaN(inputNumRds.value)) {
        num_rounds = Number(inputNumRds.value)
        if(num_rounds >= round_counter) {
            inputWhoWon.value = ''
        }
        else {
            if(num_rounds+1 == round_counter && whose_move == SPOILER_MOVE) {
                reportGameEnd()
            }
            else {
                let played_rounds = round_counter
                if(whose_move == SPOILER_MOVE) {
                    played_rounds--
                }
                if(played_rounds < round_counter) {
                    alert(played_rounds + " rounds have already been played. You must set the number of rounds to at least this number.")
                    inputNumRds.value = '' + played_rounds
                    this.focus()
                }
            }
        }
    }
    else {
        beep()
        inputNumRds.focus()
    }
  });
  document.body.appendChild(inputNumRds)*/

  /*rdsThusFarLabel = document.createTextNode('Rounds Thus Far: ')
  const span4 = document.createElement('span');  
  span4.style.fontSize = "12pt"  
  span4.style.fontFamily = 'Arial, sans-serif';
  span4.style.position = 'absolute';
  span_loc = DIVIDING_LINE_LOC - 60
  span4.style.left = span_loc.toString()+'px'; 
  span4.style.top = '14px';
  document.body.appendChild(span4)
  span4.appendChild(rdsThusFarLabel)

  inputGameSig = document.createElement('input');
  inputGameSig.type = 'text';
  inputGameSig.style.position = 'absolute';
  inputGameSig.style.left = DIVIDING_LINE_LOC + 75 + 'px';
  inputGameSig.style.top = '12px';
  inputGameSig.style.width = '120px';
  inputGameSig.style.height = '18px';
  inputGameSig.style.textAlign = 'left'
  inputGameSig.style.fontSize = "14pt"
  inputGameSig.value = ''
  inputGameSig.disabled = true
  document.body.appendChild(inputGameSig)

  const undo_button = document.createElement('button');
  document.body.appendChild(undo_button)
  undo_button.style.width = "26px" 
  undo_button.style.height = "26px"
  undo_button.style.position = 'absolute';
  undo_button.style.left = (DIVIDING_LINE_LOC + 210) + 'px'; 
  undo_button.style.top = '11px';
  undo_button.disabled = true
  const undo_img = document.createElement('img');
  undo_img.src = 'undo_inactive.png';
  undo_img.width = "15"
  undo_img.height = "15"
  undo_button.appendChild(undo_img)
  undo_button.addEventListener('click', undo_move)

  const redo_button = document.createElement('button');
  document.body.appendChild(redo_button)
  redo_button.style.width = "26px"
  redo_button.style.height = "26px"
  redo_button.style.position = 'absolute';
  redo_button.style.left = (DIVIDING_LINE_LOC + 242) + 'px'; 
  redo_button.style.top = '11px';
  redo_button.disabled = true
  const redo_img = document.createElement('img');
  redo_img.src = 'redo_inactive.png';
  redo_img.width = "15"
  redo_img.height = "15"
  redo_button.appendChild(redo_img)
  redo_button.addEventListener('click', redo_move)*/

  function undo_move() {
    move = move_queue.pop()
    move.move_box.style.display = 'none'
    /*if(whose_move == DUPLICATOR_MOVE) {  //was to be Duplicator's move so we are undoing Spoiler's move
        inputGameSig.value  = inputGameSig.value.substring(0, inputGameSig.value.length-1)
    }
    else {
        round_counter--
    }*/
    whose_move = (whose_move + 1) % 2
    last_side_played = move.last_side_played
    redrawAll()  //very wasteful
    /*if(move_queue.length == 0) {
        disableUndo()
    }
    redo_queue.push(move)
    enableRedo()
    inputWhoWon.value = ''  
    reportIfGameDecided()*/
  }

  function redo_move() {
    move = redo_queue.pop()
    move.move_box.style.display = 'initial'
    if(whose_move == SPOILER_MOVE) {
        if(move.node.x < DIVIDING_LINE_LOC) {
            inputGameSig.value  += '\u2203'
            last_side_played = EXISTS_SIDE
        }
        else {
            inputGameSig.value  += '\u2200'
            last_side_played = FORALL_SIDE
        }
    }
    else{
        round_counter++
    }
    whose_move = (whose_move + 1) % 2
    if(redo_queue.length == 0) {
        disableRedo()
    }
    move_queue.push(move)
    enableUndo()
    //reportIfGameDecided()
  }

  function enableUndo() {
    undo_img.src = 'undo.png';
    undo_button.disabled = false
  }

  function disableUndo() {
    undo_img.src = 'undo_inactive.png';
    undo_button.disabled = true
  }

  function enableRedo() {
    redo_img.src = 'redo.png';
    redo_button.disabled = false
  }

  function disableRedo() {
    redo_img.src = 'redo_inactive.png';
    redo_button.disabled = true
  }

  function coerceToNode(n) {
    if(n instanceof Node) {
        return n
    }
    else {
        let node = new Node(n.x, n.y, n.id, n.constant)
        if(n.edges != undefined && n.edges instanceof Set) {
            node.edges = n.edges
        }
        else {
            node.edges = new Set()
        }
        if(n.ultraEdges != undefined && n.ultraEdges instanceof Set) {
            node.ultraEdges = n.ultraEdges
        }
        else {
            node.ultraEdges = new Set()
        }
        node.order = n.order
        node.parent = n.parent
        return node
    }

  }


  function coerceToIconizedGroup(o) {
    if(o instanceof IconizedGroup) {
        return o
    }
    else {
        if(o.inner_nodes instanceof Array) {
            o.inner_nodes = new Set(o.inner_nodes)
        }
        else if(!(o.inner_nodes instanceof Set)) {
            o.inner_node = new Set()
        }
        if(o.inner_edges instanceof Array) {
            o.inner_edges = new Set(o.inner_edges)
        }
        else if(!(o.inner_edges instanceof Set)) {
            o.inner_edges = new Set()
        }
        if(o.inner_iconizedGroups instanceof Array) {
            o.inner_iconizedGroups = new Set(o.inner_iconizedGroups)
        }
        else if(!(o.inner_iconizedGroups instanceof Set)) {
            o.inner_iconizedGroups = new Set()
        }
        if(o.inner_ultraEdges instanceof Array) {
            o.inner_ultraEdges = new Set(o.inner_ultraEdges)
        }
        else if(!(o.inner_ultraEdgs instanceof Set)) {
            o.inner_ultraEdges = new Set()
        }
        if(o.ultraEdges instanceof Array) {
            o.ultraEdges = new Set(o.ultraEdges)
        }
        else if(!(o.ultraEdges instanceof Set)) {
            o.ultraEdges = new Set()
        }

        let icoGroup = new IconizedGroup(o.inner_nodes, o.inner_edges, o.inner_iconizedGroups, 
                o.inner_ultraEdges, o.ultraEdges, o.x, o.y, o.num_sides, o.radius, 
                o.fill_color, o.label)
        icoGroup.id = o.id
        iconizedGroup_id_counter--
        icoGroup.parent = o.parent
        return icoGroup
    }

  }

  function coerceToEdge(e) {
    if(e instanceof Edge) {
        return e
    }
    else {
        let edge = new Edge(e.node1, e.node2, e.dir)
        return edge
    }
  }

  function coerceToUltraEdge(u) {
    if(u instanceof UltraEdge) {
        return u
    }
    else {
        let ultraEdge = new UltraEdge(u.obj1, u.obj2, u.dir)
        return ultraEdge
    }
  }

  function getAllNestedIconizedGroups(icoGroup) {   
    let allNestedIcos = []

    if(icoGroup == undefined) {
        for(let i of iconizedGroups) {
            allNestedIcos.push(coerceToIconizedGroup(i))
            allNestedIcos = allNestedIcos.concat(getAllNestedIconizedGroups(i))
        }
    }
    else {
        for(let i of icoGroup.inner_iconizedGroups) {
            let trueInnerIcoGroup = fetchById(i.id, innerIconizedGroups)
            allNestedIcos.push(trueInnerIcoGroup)
            allNestedIcos = allNestedIcos.concat(getAllNestedIconizedGroups(trueInnerIcoGroup))
        }
    }

    return allNestedIcos
  }

  function iconizeGroup() {
    if(active_grouping_rectangle.x < DIVIDING_LINE_LOC &&
        active_grouping_rectangle.x + active_grouping_rectangle.width > DIVIDING_LINE_LOC) {
            alert("You can only iconize a group that is completely on the \u2203 side or completely on the \u2200 side.")
            group_processing_active = false
            return
    }
    else {
        //make sure: (i) all edges associated with all nodes are selected 
        for(let node of selected_nodes) {
            for(let edge of node.edges) {
                if(selected_nodes.has(edge.node1) && selected_nodes.has(edge.node2) && !selected_edges.has(edge)) {
                    alert("You must be sure to select all edges associated with the nodes in a group you wish to iconize.")
                    group_processing_active = false
                    return
                }
            }
        }
        //make sure (ii) no edges associated with nodes not in the group are selected
        for(let edge of selected_edges) {
            if(!selected_nodes.has(edge.node1) || !selected_nodes.has(edge.node2)) {
                alert("You cannot iconize a group that has an edge to a node not in the selected group.")
                group_processing_active = false
                return
            }
        }
        //make sure (iii) there are no edges between nodes in the group and nodes not in the group
        for(let node of selected_nodes) {
            for(let edge of node.edges) {
                if(!selected_nodes.has(edge.node1) || !selected_nodes.has(edge.node2)) {
                    alert("You can only iconize a group that is disconnected from all other nodes.")
                    group_processing_active = false
                    return
                }
            }
        }
        //make sure (iv) there are no ultraEdges assocaited with all sected nodes or iconizedGroups are also selected
        let msg = "You can only iconize a group that that is disconnected from all other objects."
        for(let node of selected_nodes) {
            for(let ultraEdge of node.ultraEdges) {
                if(!selected_ultraEdges.has(ultraEdge)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            for(let ultraEdge of icoGroup.ultraEdges) {
                if(!selected_ultraEdges.has(ultraEdge)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
        }


        //make sure (v) if an ultraEdge is selected the objects on both sides are in the group
        msg = "You cannot iconize a group that has an ultraEdge to an objectgg not in the selected group."
        for(let ultraEdge of selected_ultraEdges) {
            if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
                if(!selected_iconizedGroups.has(ultraEdge.obj1)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
            else if(!selected_nodes.has(ultraEdge.obj1)) {
                alert(msg)
                group_processing_active = false
                return
            }
            if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
                if(!selected_iconizedGroups.has(ultraEdge.obj2)) {
                    alert(msg)
                    group_processing_active = false
                    return
                }
            }
            else if(!selected_nodes.has(ultraEdge.obj2)) {
                alert(msg)
                group_processing_active = false
                return
            }
        }

        requestGroupIconization(undefined)  //not starting with an existing IconizedGoup
    }

  }

  iconizationDialogHasEventListeners = false  
  activeIcoGroup = undefined //a bit clugey, but....
  function requestGroupIconization(icoGroup) {
    const dialog = document.getElementById("iconization_dialog") 
    
    let submitButton = document.getElementById("ico_submit_button")
    activeIcoGroup = icoGroup
    if(!iconizationDialogHasEventListeners) {
        submitButton.addEventListener('click', (event) => {
            captureIconizationDialogDetails()
        });  
        dialog.addEventListener('keydown', iconizationDialogKeyHandler(event))
        iconizationDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
    if(icoGroup != undefined) {
        document.getElementById("n_gon").value = icoGroup.num_sides
        document.getElementById("radius").value = icoGroup.radius
        const radios = document.getElementsByName("color");
        for (let i = 0; i < radios.length; i++) {
            if (radios[i].value == icoGroup.fill_color) {
                radios[i].checked = true
                break;
            }
        }
        document.getElementById("label").value = icoGroup.label
    }
    else {
        document.getElementById("label").value = ""
    }
    redrawSamplePolygon()
  }

  function iconizationDialogKeyHandler(event) {
    if (event.key === 'Escape' || event.keyCode === 27) {
        iconizationDailogCancelHandler()
    }
    else if(event.key === 'Enter' || event.keyCode === 13) {
        captureIconizationDialogDetails()
    }
  }

  function redrawSamplePolygon() {   
    eraseCanvas("iconization-canvas", 135 - 50, 50 - 50, 100, 100)
    let sides = document.getElementById("n_gon").value
    let circumradius = Number(document.getElementById("radius").value)
    let fill_color = "cyan"  //the default
    const radios = document.getElementsByName("color");
    for (let i = 0; i < radios.length; i++) {
        if (radios[i].checked) {
            fill_color = radios[i].value;
            break;
        }
    }
    let label = document.getElementById("label").value
    drawPolygon("iconization-canvas", 135, 50, circumradius, sides, fill_color, label)
  }

  document.addEventListener('selectionchange', function(event) {
    selectedText = document.getSelection().toString()
    if(selectedText.includes('\u2200') && selectedText.includes('\u2203')) {
        selectAll()
        window.getSelection().removeAllRanges()
    }
  }, true);

  document.addEventListener('copy', function(event) {
    cutPending = false
    handleCopy()
  }, true);

  document.addEventListener('cut', function(event) {  //nodes and edges should be deleted immediately in this case
    cutPending = true
    let all_associated_edges = new Set()  //make sure that all_associated_edges is local
    for(node of selected_nodes) {
        all_associated_edges = all_associated_edges.union(node.edges)
    }
    all_cut_edges = structuredClone(all_associated_edges)
    handleCopy()
    deleteSelectedNodes()
    deleteSelectedEdges() 
  }, true);

  function getNodeById(id) {
    for(node of nodes) {
        if(node.id == id) {
            return node
        }
    }
    return undefined
  }

  function getIconoizedGroupById(id) {
    for(let icoGroup of iconizedGroups) {
        if(icoGroup.id == id) {
            return icoGroup
        }
    }

    return undefined
  }

  function getEdgeByNodeIdPair(id1, id2) {
    for(edge of edges) {
        if(edge.node1.id == id1 && edge.node2.id == id2) {
            return edge
        }
    }
    return undefined
  }

  function getBoardJSON() {
    return clipifyBoardState(nodes, edges, iconizedGroups, ultraEdges)
  }

  function clipifyBoardState(nodes, edges, iconizedGroups, ultraEdges) {
    
    zoomLevel = getZoomLevel()  
    zoomPortion = "\"zoom_level\": " + zoomLevel
    edgeTypePortion = "\"edge_type\": " + (edge_type == TYPE_DIRECTED ? "\"directed\"" : "\"undirected\"")
    orderPortion = "\"node_ordering\": " + nodes_are_ordered
    nodesPortion = "\"nodes\": " + arrayToJson(Array.from(nodes))
    edgesPortion = "\"edges\": " + arrayToJson(Array.from(edges))
    icoGrouPortion =  "\"iconizedGroups\": " + arrayToJson(Array.from(iconizedGroups))
    ultraEdgePortion =  "\"ultraEdges\": " + arrayToJson(Array.from(ultraEdges))
    let innerIconizedGroups = []
    for(let icoGroup of iconizedGroups) {
        innerIconizedGroups = innerIconizedGroups.concat(getAllNestedIconizedGroups(icoGroup))
    }
    innerIcoGroupPortion =  "\"innerIconizedGroups\": " + arrayToJson(innerIconizedGroups)
    moveQueuePortion = "\"move_queue\": []"
    
    return "{" + zoomPortion + ",\n" + edgeTypePortion + ",\n" + orderPortion + ",\n" 
        + nodesPortion + ",\n" + edgesPortion + ",\n" 
        + icoGrouPortion + ",\n" + ultraEdgePortion + ",\n" + innerIcoGroupPortion + ",\n"
        + moveQueuePortion + "}"
  }


  function getIcoGroupJSON(icoGroup) {  
    removeAllParents() //to take care of circularity problem
    let inner_nodes = new Set()
    for(let n of icoGroup.inner_nodes) {
        inner_nodes.add(coerceToNode(n))
    }
    let inner_edges = new Set()
    for(let e of icoGroup.inner_edges) {
        inner_edges.add(coerceToEdge(e))
    }
    let inner_icoGroups = new Set()
    for(let i of icoGroup.inner_iconizedGroups) {
        //inner_icoGroups.add(coerceToIconizedGroup(i))
        inner_icoGroups.add(fetchById(i.id, innerIconizedGroups))
    }
    let inner_ultraEdges = new Set()
    for(let u of icoGroup.inner_ultraEdges) {
        inner_ultraEdges.add(coerceToUltraEdge(u))
    }
   
    //let which_side = (icoGroup.x < DIVIDING_LINE_LOC ? EXISTS_SIDE : FORALL_SIDE)  //Must use same which_side as we were called with!!
    return clipifyIcoGroup(which_side, icoGroup.x, icoGroup.y, inner_nodes, inner_edges, inner_icoGroups, inner_ultraEdges)
  }

  function clipifyIcoGroup(which_side, center_x, center_y, inner_nodes, inner_edges, inner_iconizedGroups, inner_ultraEdges) {
    
    zoomLevel = getZoomLevel()
    zoomPortion = "\"zoom_level\": " + zoomLevel
    roundCounterPortion = "\"round_counter\":" + round_counter
    nodeIdCounterPortion = "\"node_id_counter\": " + node_id_counter
    icoGroupIdCounterPortion = "\"iconizedGroup_id_counter\": " + iconizedGroup_id_counter
    whichSidePortion = "\"which_side\": " + which_side
    constantsPortion = "\"in_use_constants\": " + JSON.stringify(Array.from(in_use_constants))
    locationPortion = "\"center_x\": " + center_x + ",\"center_y\": " + center_y
    edgeTypePortion = "\"edge_type\": " + (edge_type == TYPE_DIRECTED ? "\"directed\"" : "\"undirected\"")
    orderPortion = "\"node_ordering\": " + nodes_are_ordered
    nodesPortion = "\"nodes\": " + arrayToJson(Array.from(inner_nodes))
    edgesPortion = "\"edges\": " + arrayToJson(Array.from(inner_edges))
    icoGrouPortion =  "\"iconizedGroups\": " + arrayToJson(Array.from(inner_iconizedGroups))
    ultraEdgePortion =  "\"ultraEdges\": " + arrayToJson(Array.from(inner_ultraEdges))
    let relative_innerIconizedGroups = []
    for(let i of inner_iconizedGroups) {
        relative_innerIconizedGroups = relative_innerIconizedGroups.concat(getAllNestedIconizedGroups(i))
    }
    innerIcoGroupPortion =  "\"innerIconizedGroups\": " + arrayToJson(relative_innerIconizedGroups)
    moveQueuePortion = "\"move_queue\": " + arrayToJson(move_queue)
    
    return "{" + zoomPortion + ",\n" + roundCounterPortion + ",\n" + nodeIdCounterPortion + ",\n"
        + icoGroupIdCounterPortion + ",\n" + whichSidePortion + ",\n"  
        + constantsPortion + ",\n" + locationPortion + ",\n" + edgeTypePortion + ",\n" 
        + orderPortion + ",\n" + nodesPortion + ",\n" + edgesPortion + ",\n" 
        + icoGrouPortion + ",\n" + ultraEdgePortion + ",\n" + innerIcoGroupPortion + ",\n" 
        + moveQueuePortion + "}"
  }

  function clipifyNodesAndEdges(_nodes, _edges) {
    //this does not properly stringify the edge lists since sets are not properly stringified by JSON.stringify()
    edgeTypePortion = "\"edge_type\": " + (edge_type == TYPE_DIRECTED ? "\"directed\"" : "\"undirected\"")
    orderPortion = "\"node_ordering\": " + nodes_are_ordered
    nodesPortion = "\"nodes\": " + JSON.stringify(Array.from(_nodes))
    edgesPortion = "\"edges\": " + JSON.stringify(Array.from(_edges))
    return "{" + edgeTypePortion + ",\n" + orderPortion + ",\n" +nodesPortion + ",\n" + edgesPortion + "}"
  }

  function handleCopy() {
    if(selected_nodes.size > 0) {
        copied_nodes = structuredClone(selected_nodes)
        copied_edges = structuredClone(selected_edges)

        //somehow the below does not always work!!
        copyToClipboard(clipifyNodesAndEdges(copied_nodes, copied_edges))
    }
    else {
        beep()
    }
  }

  function isPasteToRepairAMistakenCut() {
    nodes_on_left = false
    nodes_on_right = false
    for(let node of copied_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            nodes_on_left = true
        }
        else if (node.x > DIVIDING_LINE_LOC) {
            nodes_on_right = true
        }
    }
    if(nodes_on_left && nodes_on_right) {
        return true
    }
    else if(nodes_on_left && (existsButtonPressed || (!forallButtonPressed && endX < DIVIDING_LINE_LOC))) {
        return true
    }
    else if(nodes_on_right && (forallButtonPressed || (!existsButtonPressed && endX > DIVIDING_LINE_LOC))) {
        return true
    }
    else {
        return false
    }
  }

  function pasteToRepairMistakenCut() {  //this is a tricky case - may not be worth it....
                                         //don't handle if graph on the given side has been changed
    
    //make sure that any nodes that copied edges were attached to, 
    // that were not part of the coped set, still exist!
    for(let node of copied_nodes) {
        node.edges = new Set()
        orderInputBox = createNodeOrderingBox(node)
        node_id_to_inputBox_map[node.id] = orderInputBox
        if(orderings_are_being_displayed) {
            orderInputBox.style.display = "initial"
        }
        else {
            orderInputBox.style.display = "none"
        }
    }
    nodes = nodes.union(copied_nodes)
    for(let edge of all_cut_edges) {
        node1 = getNodeById(edge.node1.id)
        node2 = getNodeById(edge.node2.id)
        if(node1 != undefined && node2 != undefined) {
            edge.node1 = node1
            edge.node2 = node2
            node1.edges.add(edge)
            node2.edges.add(edge)
            edges.add(edge)
        }
    }   
    selected_nodes = copied_nodes  
    selected_edges = new Set()
    for(let edge of copied_edges) {
        sel_edge = getEdgeByNodeIdPair(edge.node1.id, edge.node2.id) 
        if(sel_edge != undefined) {
            selected_edges.add(sel_edge)
        }
    }
    redrawAll()
    copied_nodes = new Set()
    copied_edges = new Set()
    cutPending = false
  }

  document.addEventListener('paste', function(event) {
    VERTICAL_PASTE_BUFFER = 20
    //json = readFromClipboard()
    //clipObject = JSON.parse(json)
    if(copied_nodes.size == 0) {  //can only copy edges that are between copied nodes!!
        beep
        return
    }
    else {
        if(cutPending && isPasteToRepairAMistakenCut()) {
            pasteToRepairMistakenCut()
            return
        }
        //First remove any edges from the selection for which both nodes are not selected
        edges_to_remove = new Set()
        for(let edge of copied_edges) {
            has_node1 = false
            has_node2 = false
            for(node of copied_nodes) {
                if(edge.node1.id == node.id) {
                    has_node1 = true
                    edge.node1 = node
                }
                else if(edge.node2.id == node.id) {
                    has_node2 = true
                    edge.node2 = node
                }
            }
            if(!has_node1 || !has_node2) {
                edges_to_remove.add(edge)
            }
        }
        for(let edge of edges_to_remove) {
            copied_edges.delete(edge)
        }
        //Alter node ids so they are distinct from existing node ids; 
        //Make sure the edge set for the nodes correspond to the edges to be added
        //Also add the selected_nodes and selected_edges to nodes and edges
        for(let node of copied_nodes) {
            node.id = node_id_counter++
            node.edges = new Set()
        }
        for(let edge of copied_edges) {
            edge.node1.edges.add(edge)
            edge.node2.edges.add(edge)
        }

        //decide which side to copy to and reference point of where to copy to
        which_side_to_copy_to = FORALL_SIDE  //the default
        //if there are selected nodes on both sides paste must be to both sides
        //after pasting, pasted nodes should be selected
        nodes_on_left = false
        nodes_on_right = false
        for(let node of copied_nodes) {
            if(node.x < DIVIDING_LINE_LOC) {
                nodes_on_left = true
            }
            else if (node.x > DIVIDING_LINE_LOC) {
                nodes_on_right = true
            }
        }
        highesttSelectedY = canvas.height
        for(let node of copied_nodes) {
            if(node.y < highesttSelectedY) {
                highesttSelectedY = node.y
            }
        }

        if(nodes_on_left && nodes_on_right) {
            which_side_to_copy_to = BOTH_SIDES
            lowestY = Math.max(getYCoordOfLowestNode(BOTH_SIDES), TOP_BUFFER)
            for(let node of copied_nodes) {
                node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
            }
        }
        else if(nodes_on_left) {
            if(existsButtonPressed || (!forallButtonPressed && endX < DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = EXISTS_SIDE
                lowestY = Math.max(getYCoordOfLowestNode(EXISTS_SIDE), TOP_BUFFER)
                for(let node of copied_nodes) {
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
            else if(forallButtonPressed|| (!existsButtonPressed && endX > DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = FORALL_SIDE
                lowestY = Math.max(getYCoordOfLowestNode(FORALL_SIDE), TOP_BUFFER)
                for(let node of copied_nodes) {
                    node.x += DIVIDING_LINE_LOC
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
        }
        else if(nodes_on_right) {
            if(existsButtonPressed || (!forallButtonPressed && endX < DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = EXISTS_SIDE
                lowestY = Math.max(getYCoordOfLowestNode(EXISTS_SIDE), TOP_BUFFER)
                for(let node of copied_nodes) {
                    node.x -= DIVIDING_LINE_LOC
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
            else if(forallButtonPressed|| (!existsButtonPressed && endX > DIVIDING_LINE_LOC)) {
                which_side_to_copy_to = FORALL_SIDE
                lowestY = Math.max(getYCoordOfLowestNode(FORALL_SIDE), TOP_BUFFER)
                for(let node of copied_nodes) {
                    node.y += (lowestY - highesttSelectedY) + VERTICAL_PASTE_BUFFER
                }
            }
        }
        //now create the ordering boxes NOTE: nodes should be ordered in the same order as they were copied in 
        // (keep in left hand and right hand side groups when doing this....)
        sortedCopiedNodes = Array.from(copied_nodes)
        sortedCopiedNodes.sort((a,b) => a.order - b.order)
        for(let node of sortedCopiedNodes) {
            orderInputBox = undefined
            if(node.order == NO_ORDER) {
                orderInputBox = createNodeOrderingBox(node)
                orderInputBox.value = ''
                node.order = NO_ORDER
            }
            else if(nodes_on_left && which_side_to_copy_to == FORALL_SIDE) {
                //see if or the order is available - if so, snag it
                order_available = true
                for(n of nodes) {
                    if(n.x > DIVIDING_LINE_LOC && n.order == node.order) {
                        order_available = false
                        break
                    }
                }
                if(!order_available) {
                    node.order = NO_ORDER
                    orderInputBox = createNodeOrderingBox(node)
                }
                else {
                    orderInputBox = createNodeOrderingBox(node)
                }
            }
            else if(nodes_on_right && which_side_to_copy_to == EXISTS_SIDE) {
                //see if or the order is available - if so, snag it
                order_available = true
                for(n of nodes) {
                    if(n.x < DIVIDING_LINE_LOC && n.order == node.order) {
                        order_available = false
                        break
                    }
                }
                if(!order_available) {
                    node.order = NO_ORDER
                    orderInputBox = createNodeOrderingBox(node)
                }
                else {
                    orderInputBox = createNodeOrderingBox(node)
                }
            }
            else {
                node.order = NO_ORDER  //will force a new ordering
                orderInputBox = createNodeOrderingBox(node)
            }
            node_id_to_inputBox_map[node.id] = orderInputBox
            if(orderings_are_being_displayed) {
                orderInputBox.style.display = "initial"
            }
            else {
                orderInputBox.style.display = "none"
            }
            nodes.add(node)
        }
        edges = edges.union(copied_edges)
        selected_nodes = copied_nodes  
        selected_edges = copied_edges  
        copied_nodes = structuredClone(selected_nodes)
        copied_edges = structuredClone(selected_edges)
        //now redraw everything ()
        redrawAll()
        cutPending = false
    }
  }, true);

  function delay(ms) {   //must be called by functions that are declared async
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function copyToClipboard(text) {
    try {
        await navigator.clipboard.writeText(text);
        console.log('JSON copied to clipboard');
    } 
    catch (err) {
        console.error('Failed to copy to clipboard: ', err);
    }
  }

  async function readFromClipboard() {
    try {
        
        const text = await navigator.clipboard.readText();
        console.log('Text read from clipboard');
        return text
    } 
    catch (err) {
        console.error('Failed to read from clipboard: ', err);
        return ""
    }
  }

  function contextMenuHandler(which) { 
    if(which == ORDER_NODES_INDEX) {
        hideNodeOrderings()
        nodes_are_ordered = !nodes_are_ordered
        if(nodes_are_ordered) {
            orderUnorderedNodesById()
        }
    }
    else if(which == DISPLAY_ORDERINGS_INDEX) {  
        orderings_are_being_displayed = !orderings_are_being_displayed
        if(orderings_are_being_displayed) {
            displayNodeOrderings()
        }
        else {
            hideNodeOrderings()
        }
    }
    else if(which == ORDER_LEFT_TO_RIGHT_INDEX) {
        orderSelectedNodesLeftToRight()
        displayNodeOrderings()
    }
    else if(which == SHRINK_SELECTED_INDEX) {
        shrinkSelection(0.67)   //inverse of the expand amount
    }
    else if(which == EXPAND_SELECTED_INDEX) {   
        shrinkSelection(1.5)    //inverse of the shrink amount
    }
    else if(which == INSERT_GRID_INDEX) {
        requestInsertGrid()  
        return
    }
    else if(which == INSERT_CYCLE_INDEX) {
        requestInsertCycle()  //ideally get location of where they right clicked and pass that on!
        return
    }
    if(nodes_are_ordered) {
        contextMenuPrefix[ORDER_NODES_INDEX] = '\u2713 '
        if(orderings_are_being_displayed) {
            contextMenuPrefix[DISPLAY_ORDERINGS_INDEX] = '\u2713 '
        }
        else {
            contextMenuPrefix[DISPLAY_ORDERINGS_INDEX] = '\xa0\xa0\xa0'
        }
        contextMenuPrefix[ORDER_LEFT_TO_RIGHT_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[SHRINK_SELECTED_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[EXPAND_SELECTED_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[INSERT_GRID_INDEX] = '\xa0\xa0\xa0'
        contextMenuPrefix[INSERT_CYCLE_INDEX] = '\xa0\xa0\xa0'
    }
    else {
        orderings_are_being_displayed = false 
        for(i=0; i<contextMenuPrefix.length; i++) {
            contextMenuPrefix[i] = ''
        }
    }
    console.log('Option ' + which + ' clicked.');
    contextMenu.style.display = 'none';
  }

  function captureGridDialogDetails(event) {
    num_rows = document.getElementById("num_rows").value
    num_cols = document.getElementById("num_cols").value
    pixel_separation = document.getElementById("separation").value
    l1_connect = document.getElementById("l1_connect").checked
    order_tb_lr = document.getElementById("order_tb_lr").checked
    if(document.getElementById("via_undirected_edges").checked) {
        edge_type = TYPE_UNDIRECTED
    }
    else {
        edge_type = TYPE_DIRECTED
    }
    res = sanityCheckGridDialogEntries(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr)
    if(res) {
        renderGridOfNodes(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr)
        clearSelection()
    } 
    else {
        event.preventDefault()
    }
  }

  function captureIconizationDialogDetails() {
    let num_sides = document.getElementById("n_gon").value
    let circumradius = Number(document.getElementById("radius").value)
    let fill_color = "cyan"  //the default
    const radios = document.getElementsByName("color");
    for (let i = 0; i < radios.length; i++) {
        if (radios[i].checked) {
            fill_color = radios[i].value;
            break;
        }
    }
    let label = document.getElementById("label").value
    
    let alsoSwapOthers = false
    if(activeIcoGroup == undefined) {
        //active_grouping_rectangle has already been disabled, so we have to make do without it
        let minX = canvas.width
        let minY = canvas.height
        let maxX = maxY = 0
        for(let node of selected_nodes) {
            if(node.x < minX) {
                minX = node.x
            }
            if(node.x > maxX) {
                maxX = node.x
            }
            if(node.y < minY) {
                minY = node.y
            }
            if(node.y > maxY) {
                maxY = node.y
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            if(icoGroup.x < minX) {
                minX = icoGroup.x
            }
            if(icoGroup.x > maxX) {
                maxX = icoGroup.x
            }
            if(icoGroup.y < minY) {
                minY = icoGroup.y
            }
            if(icoGroup.y > maxY) {
                maxY = icoGroup.y
            }
        }
        minX -= GROUPING_BOX_BUFFER
        minY -= GROUPING_BOX_BUFFER
        maxX += GROUPING_BOX_BUFFER
        maxY += GROUPING_BOX_BUFFER
        let x = (minX + maxX)/2
        let y = (minY + maxY)/2

        activeIcoGroup = new IconizedGroup(structuredNodesClone(selected_nodes), structuredEdgesClone(selected_edges), 
            structuredIconizedGroupsClone(selected_iconizedGroups),
            structuredUltraEdgesClone(selected_ultraEdges), 
            new Set(), x, y, num_sides, circumradius, fill_color, label)  //initially created with no ultraEdges
        iconizedGroups.add(activeIcoGroup)
        //nodes and edges must be deteled from the main set or they will always be drawn
        deleteSelectedEdges()
        deleteSelectedUltraEdges()
        deleteSelectedNodes()
        deleteSelectedIconizedGroups()
        let EXTRA_BUFF = 5  //to try to take care of phantom grouping box that sometimes seems to appear
        redrawRectangle(minX - EXTRA_BUFF, minY - EXTRA_BUFF, maxX - minX + 2*EXTRA_BUFF, maxY - minY + 2*EXTRA_BUFF)
    }
    else {
        if(num_sides != activeIcoGroup.num_sides || circumradius != activeIcoGroup.radius || 
            fill_color != activeIcoGroup.fill_color) {
            otherIcosWithSameIcon = new Set()
            for(let i of iconizedGroups) {
                if(i != activeIcoGroup && i.num_sides == activeIcoGroup.num_sides && 
                    i.radius == activeIcoGroup.radius && i.fill_color == activeIcoGroup.fill_color) {
                    otherIcosWithSameIcon.add(i)
                }
            }
            if(otherIcosWithSameIcon.size > 0) {  //only ask this question if the icon or fill color was changed!!
                alsoSwapOthers = confirm("Also swap the icons of other groups with this same icon (does not affect labels)?")
            }
        }
        erase_iconizedGroup(activeIcoGroup)
        activeIcoGroup.num_sides = num_sides
        activeIcoGroup.radius = circumradius
        activeIcoGroup.fill_color = fill_color
        activeIcoGroup.label = label
        if(alsoSwapOthers) {
            for(let i of otherIcosWithSameIcon) {
                erase_iconizedGroup(i)
                i.num_sides = num_sides
                i.radius = circumradius
                i.fill_color = fill_color
            }
        }
    }
    //perform iconization
    MAX_ICON_RADIUS = 40
    draw_iconizedGroup(activeIcoGroup)
    redrawRectangle(activeIcoGroup.x - MAX_ICON_RADIUS, activeIcoGroup.y - MAX_ICON_RADIUS,
        2*MAX_ICON_RADIUS, 2*MAX_ICON_RADIUS)
    if(alsoSwapOthers) {
        for(let i of otherIcosWithSameIcon) {
            draw_iconizedGroup(i)
            redrawRectangle(i.x - MAX_ICON_RADIUS, i.y - MAX_ICON_RADIUS, 2*MAX_ICON_RADIUS, 2*MAX_ICON_RADIUS)
        }
    }
  }

  gridDialogHasEventListeners = false  //a bit clugey, but....
  function requestInsertGrid() {
    //const dialog = document.querySelector("dialog");
    const dialog = document.getElementById("grid_dialog")
    document.getElementById("order_tb_lr").disabled = !nodes_are_ordered
    document.getElementById("order_lr_tb").disabled = !nodes_are_ordered

    document.getElementById("via_undirected_edges").disabled = (edges.size + ultraEdges.size > 0 || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_directed_edges").disabled = (edges.size + ultraEdges.size > 0 || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_undirected_edges").checked = (edge_type == TYPE_UNDIRECTED)
    document.getElementById("via_directed_edges").checked = (edge_type == TYPE_DIRECTED)
    
    submitButton = document.getElementById("grid_submit_button")
    if(!gridDialogHasEventListeners) {
        submitButton.addEventListener('click',(event) => {
            captureGridDialogDetails(event)
        });
        dialog.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                gridDailogCancelHandler()
            }
            else if(event.key === 'Enter' || event.keyCode === 13) {
                captureGridDialogDetails(event)
            }
        });
        gridDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
  }

   function requestExplodeIconizedGroup(icoGroup) {
    let topMost = canvas.height
    let leftMost = canvas.width
    let bottomMost = rightMost = 0
    let idToNodeMap = new Map()
    for(let node of icoGroup.inner_nodes) {
        idToNodeMap.set(node.id, node)
        if(node.y < topMost) {
            topMost = node.y
        }
        if(node.x < leftMost) {
            leftMost = node.x
        }
        if(node.y > bottomMost) {
            bottomMost = node.y
        }
        if(node.x > rightMost) {
            rightMost = node.x
        }
        node.edges = new Set()  //will rebuild these
        node.ultraEdges = new Set() //will reubuild these too!
    }
    let idToIconizedGroupMap = new Map()
    for(let i of icoGroup.inner_iconizedGroups) {
        idToIconizedGroupMap.set(i.id, i)
        if(i.y < topMost) {
            topMost = i.y
        }
        if(i.x < leftMost) {
            leftMost = i.x
        }
        if(i.y > bottomMost) {
            bottomMost = i.y
        }
        if(i.x > rightMost) {
            rightMost = i.x
        }
        i.ultraEdges = new Set() //will reubuild these!
    }
    //Now confirm there is enough space to do explosion
    formerCenterX = (leftMost + rightMost)/2
    formerCenterY = (topMost + bottomMost)/2
    newLeftMost = leftMost + (icoGroup.x - formerCenterX)
    newRightMost = rightMost + (icoGroup.x - formerCenterX)
    newTopMost = topMost + (icoGroup.y - formerCenterY)
    newBottomMost = bottomMost + (icoGroup.y - formerCenterY)

    let whichSide = EXISTS_SIDE
    if(icoGroup.x > DIVIDING_LINE_LOC) {
        whichSide = FORALL_SIDE
    }
    let errMsg = "Explosion would push some objects off the canvas. Please move icon to a more centralized portion of the canvas and try again."
    if(newTopMost < TOP_BUFFER || newBottomMost > canvas.height - BOTTOM_BUFFER) {
        alert(errMsg)
        return
    }
    if(whichSide == EXISTS_SIDE && (newLeftMost < DIVIDING_LINE_BUFFER || newRightMost > DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER)) {
        alert(errMsg)
        return
    }
    if(whichSide == FORALL_SIDE && (newLeftMost < DIVIDING_LINE_LOC + DIVIDING_LINE_BUFFER || newRightMost > canvas.width - DIVIDING_LINE_BUFFER)) {
        alert(errMsg)
        return
    }
     
    errMsg = "Not enough room to perform explositon. Please move icon to a portion of the canvas with more space and try again."
    for(let node of nodes) {
        if(node.x + NODE_DRAW_RADIUS > newLeftMost && node.x - NODE_DRAW_RADIUS < newRightMost
            && node.y + NODE_DRAW_RADIUS > newTopMost && node.y - NODE_DRAW_RADIUS < newBottomMost) {
                alert(errMsg)
                return
        }
    }
    for(let ig of iconizedGroups) {
        if(ig != icoGroup) {
            if(ig.x + ig.radius > newLeftMost && ig.x - icoGroup.radius < newRightMost
                && ig.y + icoGroup.radius > newTopMost && ig.y - ig.radius < newBottomMost) {
                    alert(errMsg)
                    return
            }
        }
    }

    for(let node of icoGroup.inner_nodes) {
        orderInputBox = createNodeOrderingBox(node)  //this has been lost in the shuffle
        if(orderings_are_being_displayed) {
            orderInputBox.style.display = "default"
        }
        else {
            orderInputBox.style.display = "none"
        }
        if(node.constant != '') {  //and this too...
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
    }

    clearSelection()
    //if(selected_iconizedGroups.has(icoGroup)) {
    //    unselect_iconizedGroup(icoGroup)
    //}
    oldCenter = new Point((rightMost + leftMost)/2, (topMost + bottomMost)/2)
    if(oldCenter.x != icoGroup.x || oldCenter.y != icoGroup.y) {
        for(let node of icoGroup.inner_nodes) {
            node.x += (icoGroup.x - oldCenter.x)
            node.y += (icoGroup.y - oldCenter.y)
            let constantBox = node_id_to_constantBox_map.get(node.id)
            if(constantBox != undefined) {
                constantBox.style.left = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
                constantBox.style.top = "" + (node.y + CONSTANT_BOX_OFFSET_Y) + "px"
            }
            let orderInputBox = node_id_to_inputBox_map.get(node.id)
            orderInputBox.style.left = "" + (node.x + ORDERING_BOX_OFFSET_X) + "px"
            orderInputBox.style.top = "" + (node.y + ORDERING_BOX_OFFSET_Y) + "px"
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            i.x += (icoGroup.x - oldCenter.x)
            i.y += (icoGroup.y - oldCenter.y)
        }
    } 
    //Repair the edges and the edges in node.edges using the idToNodeMap!
    for(let edge of icoGroup.inner_edges) {
        id1 = edge.node1.id
        id2 = edge.node2.id
        edge.node1 = idToNodeMap.get(id1)
        edge.node2 = idToNodeMap.get(id2)
        edge.node1.edges.add(edge)
        edge.node2.edges.add(edge)
    }
    //Repair ultraedges
    for(let ultraEdge of icoGroup.inner_ultraEdges) {
        if(ultraEdge.obj1.hasOwnProperty("num_sides")) {
            ultraEdge.obj1 = idToIconizedGroupMap.get(ultraEdge.obj1.id)
        }
        else {
            ultraEdge.obj1 = idToNodeMap.get(ultraEdge.obj1.id)
        }
        if(ultraEdge.obj2.hasOwnProperty("num_sides")) {
            ultraEdge.obj2 = idToIconizedGroupMap.get(ultraEdge.obj2.id)
        }
        else {
            ultraEdge.obj2 = idToNodeMap.get(ultraEdge.obj2.id)
        }
        //also have to modify the ultraEdges of the objects on each side!!
        ultraEdge.obj1.ultraEdges.add(ultraEdge)
        ultraEdge.obj2.ultraEdges.add(ultraEdge)
    }
    //Now replace any ultraEdges going from this icoGroup outward with edges and ultraEdges
    for(let ultraEdge of icoGroup.ultraEdges) {
        otherObj = ultraEdge.obj1
        if(ultraEdge.obj1 == icoGroup) {
            otherObj = ultraEdge.obj2
        }
        otherObjIsNode = !otherObj.hasOwnProperty("num_sides")
        //now deal with replacements....
        for(let node of icoGroup.inner_nodes) {
            if(otherObjIsNode) {
                edge = new Edge(otherObj, node)
                otherObj.edges.add(edge)
                node.edges.add(edge)
                edges.add(edge)
            }
            else {
                ultraEdge = new UltraEdge(otherObj, node)
                otherObj.ultraEdges.add(ultraEdge)
                node.ultraEdges.add(ultraEdge)
                ultraEdges.add(ultraEdge)
            }
        }
        for(let i of icoGroup.inner_iconizedGroups) {
            ultraEdge = new UltraEdge(otherObj, i)
            otherObj.ultraEdges.add(ultraEdge)
            i.ultraEdges.add(ultraEdge)
            ultraEdges.add(ultraEdge)
        }
    }
    nodes = nodes.union(icoGroup.inner_nodes)
    edges = edges.union(icoGroup.inner_edges)
    ultraEdges = ultraEdges.union(icoGroup.inner_ultraEdges)
    iconizedGroups = iconizedGroups.union(icoGroup.inner_iconizedGroups)

    selected_nodes = new Set()
    selected_nodes = selected_nodes.union(icoGroup.inner_nodes)
    selected_edges = new Set()
    selected_edges = selected_edges.union(icoGroup.inner_edges)
    selected_iconizedGroups = new Set()
    selected_iconizedGroups = selected_iconizedGroups.union(icoGroup.inner_iconizedGroups)
    selected_ultraEdges = new Set()
    selected_ultraEdges = selected_ultraEdges.union(icoGroup.inner_ultraEdges)
    
    //unselect_iconizedGroup(icoGroup)
    for(let uEdge of icoGroup.ultraEdges) {
        delete_ultraEdge(uEdge)
    }
    delete_iconizedGroup(icoGroup)
    
    redrawAll()
  }

  function iconizedGroupContextMenuHandler(icoGroup, which) {
    if(which == ICO_GROUP_CHANGE_ICON_INDEX) {
        requestGroupIconization(icoGroup)
    }
    else if(which == ICO_GROUP_EDIT_INDEX) {
        launchIconizedGroupPopup(icoGroup)
    }
    else if(which == ICO_GROUP_EXPAND_INDEX) {
        requestExplodeIconizedGroup(icoGroup)
    }
  }

  function selfLoopContextMenuHandler(clicked_on_node, whichSide) {
    edge = new Edge(clicked_on_node, clicked_on_node, whichSide)
    self_loop_already_exists = false
    for(e of edges) {   //determine if self-loop already exists, and if so, which side it was drawn on
        if(e.node1 == clicked_on_node && e.node2 == clicked_on_node) {
            self_loop_already_exists = true
            e.dir = whichSide
            eraseSelfLoop(clicked_on_node, e.dir)
            redrawRectangle(clicked_on_node.x - 50, clicked_on_node.y - 50, 100, 100)
            return
        }
    }
    create_edge(edge) 
  }

  function shrinkSelection(amount) {    
    let left_hand_nodes = new Set()
    let right_hand_nodes = new Set()
    let left_hand_iconizedGroups = new Set()
    let right_hand_iconizedGroups = new Set()
    topMostLeft = canvas.height
    leftMostLeft = canvas.width
    topMostRight = canvas.height
    leftMostRight = canvas.width
    for(let node of selected_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            left_hand_nodes.add(node)
            if(node.x < leftMostLeft) {
                leftMostLeft = node.x
            }
            if(node.y < topMostLeft) {
                topMostLeft = node.y
            }
        }
        else {
            right_hand_nodes.add(node)
            if(node.x < leftMostRight) {
                leftMostRight = node.x
            }
            if(node.y < topMostRight) {
                topMostRight = node.y
            }
        }
    }
    for(let icoGroup of selected_iconizedGroups) {
        if(icoGroup.x < DIVIDING_LINE_LOC) {
            left_hand_iconizedGroups.add(icoGroup)
            if(icoGroup.x < leftMostLeft) {
                leftMostLeft = icoGroup.x
            }
            if(icoGroup.y < topMostLeft) {
                topMostLeft = icoGroup.y
            }
        }
        else {
            right_hand_iconizedGroups.add(icoGroup)
            if(icoGroup.x < leftMostRight) {
                leftMostRight = icoGroup.x
            }
            if(icoGroup.y < topMostRight) {
                topMostRight = icoGroup.y
            }
        }
    }
    //Make sure it is safe to do the expansion
    if(amount > 1) {
        rightMostLeft = rightMostRight = 0
        bottomMostLeft = bottomMostRight = 0
        for(let node of selected_nodes) {
            if(node.x < DIVIDING_LINE_LOC) {
                if(node.x > rightMostLeft) {
                    rightMostLeft = node.x
                }
                if(node.y > bottomMostLeft) {
                    bottomMostLeft = node.y
                }
            }
            else {
                if(node.x > rightMostRight) {
                    rightMostRight = node.x
                }
                if(node.y > bottomMostRight) {
                    bottomMostRight = node.y
                }
            }
        }
        for(let icoGroup of selected_iconizedGroups) {
            if(icoGroup.x < DIVIDING_LINE_LOC) {
                if(icoGroup.x > rightMostLeft) {
                    rightMostLeft = icoGroup.x
                }
                if(icoGroup.y > bottomMostLeft) {
                    bottomMostLeft = icoGroup.y
                }
            }
            else {
                if(icoGroup.x > rightMostRight) {
                    rightMostRight = icoGroup.x
                }
                if(icoGroup.y > bottomMostRight) {
                    bottomMostRight = icoGroup.y
                }
            }
        }
        //test that these are safe
        testLeftX = (1-amount)*leftMostLeft + amount*rightMostLeft
        testRightX = (1-amount)*leftMostRight + amount*rightMostRight
        testLeftY = (1-amount)*topMostLeft + amount*bottomMostLeft
        testRightY = (1-amount)*topMostRight + amount*bottomMostRight
        if(testLeftX > DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) {
            alert("Expansion would take objects on the \u2203 side to far right! Bailing out.")
            return
        }
        else if(testRightX > canvas.width - DIVIDING_LINE_BUFFER) {
            alert("Expansion would take objects on the \u2200 side to far right! Bailing out.")
            return
        }
        else if(testLeftY > canvas.height - DIVIDING_LINE_BUFFER) {
            alert("Expansion would take objects on the \u2203 side to far down! Bailing out.")
            return
        }
        else if(testRightY > canvas.height - DIVIDING_LINE_BUFFER) {
            alert("Expansion gwould take objects on the \u2200 side to far down! Bailing out.")
            return
        }
    }
    if(topMostLeft < canvas.height && leftMostLeft < canvas.width) {
        //shrink nodes on left
        for(let node of left_hand_nodes) {
            node.x = (1-amount)*leftMostLeft + amount*node.x
            node.y = (1-amount)*topMostLeft + amount*node.y
        }
        //shrink iconizedGroups on left
        for(let icoGroup of left_hand_iconizedGroups) {
            icoGroup.x = (1-amount)*leftMostLeft + amount*icoGroup.x
            icoGroup.y = (1-amount)*topMostLeft + amount*icoGroup.y
        }
    }
    if(topMostRight < canvas.height && leftMostRight < canvas.width) {
        //shrink nodes on right
        for(let node of right_hand_nodes) {
            node.x = (1-amount)*leftMostRight + amount*node.x
            node.y = (1-amount)*topMostRight + amount*node.y
        }
        //shrink iconizedGroups on right
        for(let icoGroup of right_hand_iconizedGroups) {
            icoGroup.x = (1-amount)*leftMostRight + amount*icoGroup.x
            icoGroup.y = (1-amount)*topMostRight + amount*icoGroup.y
        }
    }

    //now move constant boxes
    let all_nodes = left_hand_nodes.union(right_hand_nodes)
    for(let node of all_nodes) {
        constantBox = node_id_to_constantBox_map.get(node.id)
        if(constantBox != undefined) {
            constantBox.style.left = "" + (node.x + CONSTANT_BOX_OFFSET_X) + "px"
            constantBox.style.top = "" + (node.y  + CONSTANT_BOX_OFFSET_Y) + "px"
        }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height)  //since the redrawAll will just know about new node positions
    redrawAll()
    if(orderings_are_being_displayed) {
        displayNodeOrderings()   //redisplays at new locations
    }
  }

  function removeConstantBox(node) {
    constantBox = node_id_to_constantBox_map.get(node.id)
    if(constantBox != undefined) {
        constantBox.remove()
        eraseConstantBoxFlagPole(node)
        node_id_to_constantBox_map.delete(node.id)
        redrawRectangle(node.x - 50, node.y - 50, 100, 100) 
    }
  }

  function nodeContextMenuHandler(node, which) {
    if(which == ASSIGN_CONSTANT_INDEX) {
        constantBox = node_id_to_constantBox_map.get(node.id)
        if(constantBox == undefined) {
            constantBox = createConstantBox(node.x + CONSTANT_BOX_OFFSET_X, node.y + CONSTANT_BOX_OFFSET_Y, node.constant, 
                                    CONSTANT_BOX_WIDTH, CONSTANT_BOX_HEIGHT)
            drawConstantBoxFlagPole(node) 
            constantBox.focus()
            node_id_to_constantBox_map.set(node.id, constantBox)
        }
        else { 
            node.constant = ''
            removeConstantBox(node)
        }
    }
  }

  function orderSelectedNodesLeftToRight() {
    left_hand_node_orders = []
    left_hand_nodes = []
    right_hand_node_orders = []
    right_hand_nodes = []
    for(let node of selected_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            if(node.order != NO_ORDER) {
                left_hand_node_orders.push(node.order)
                left_hand_nodes.push(node)
            }
        }
        else {
            if(node.order != NO_ORDER) {
                right_hand_node_orders.push(node.order)
                right_hand_nodes.push(node)
            }
        }
    }
    left_hand_nodes.sort((a,b)=> {
        if(a.x < b.x || (a.x == b.x && a.y < b.y)) {
            return -1
        }
        else if(a.x > b.x || (a.x == b.x && a.y > b.y)) {
            return 1
        } 
        else { //should never happen -- means nodes are on top of each other
            return 0
        }
    });
    left_hand_node_orders.sort((a,b)=>a-b)
    right_hand_nodes.sort((a,b)=> {
        if(a.x < b.x || (a.x == b.x && a.y < b.y)) {
            return -1
        }
        else if(a.x > b.x || (a.x == b.x && a.y > b.y)) {
            return 1
        } 
        else { //should never happen -- means nodes are on top of each other
            return 0
        }
    });
    right_hand_node_orders.sort((a,b)=>a-b)
    for(i = 0; i<left_hand_node_orders.length; i++) {
        left_hand_nodes[i].order = left_hand_node_orders[i]
    }
    for(i = 0; i<right_hand_node_orders.length; i++) {
        right_hand_nodes[i].order = right_hand_node_orders[i]
    }
  }

  function contractSelectedNodes() {  
    CONTRACTION_AMOUNT = 0.5
    let left_hand_nodes = new Set()
    let right_hand_nodes = new Set()
    topMostLeft = canvas.height
    leftMostLeft = canvas.width
    topMostRight = canvas.height
    leftMostRight = canvas.width
    for(let node of selected_nodes) {
        if(node.x < DIVIDING_LINE_LOC) {
            left_hand_nodes.add(node)
            if(node.x < leftMostLeft) {
                leftMostLeft = node.x
            }
            if(node.y < topMostLeft) {
                topMostLeft = node.y
            }
        }
        else {
            right_hand_nodes.add(node)
            if(node.x < leftMostRight) {
                leftMostRight = node.x
            }
            if(node.y < topMostRight) {
                topMostRight = node.y
            }
        }
    }
    if(topMostLeft < canvas.height && leftMostLeft < canvas.width) {
        //contract nodes on left
        for(let node of left_hand_nodes) {
            node.x = CONTRACTION_AMOUNT*leftMostLeft + (1-CONTRACTION_AMOUNT)*node.x
            node.y = CONTRACTION_AMOUNT*topMostLeft + (1-CONTRACTION_AMOUNT)*node.y
        }
    }
    if(topMostRight < canvas.height && leftMostRight < canvas.width) {
        //contract nodes on right
        for(let node of right_hand_nodes) {
            node.x = CONTRACTION_AMOUNT*leftMostRight + (1-CONTRACTION_AMOUNT)*node.x
            node.y = CONTRACTION_AMOUNT*topMostRight + (1-CONTRACTION_AMOUNT)*node.y
        }
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height)  //since the redrawAll will just know about new node positions
    redrawAll()
    if(orderings_are_being_displayed) {
        displayNodeOrderings()   //redisplays at new locations
    }
  }

  function validateSpaceForNodes(left_edge, right_edge, top_edge, bottom_edge) {
    if(left_edge < DIVIDING_LINE_BUFFER) {
        alert("Not enough space to the left to fit all of your nodes. Please try again.")
        return false
    }
    else if(left_edge < DIVIDING_LINE_LOC && right_edge > DIVIDING_LINE_LOC - DIVIDING_LINE_BUFFER) {
        alert("Nodes will not all fit on the left-hand side. Please try again.")
        return false
    } 
    else if(right_edge > CANVAS_WIDTH - NODE_DRAW_RADIUS) {
        alert("Nodes will not all fit on the right-hand side. Please try again.")
        return false
    }
    else if(top_edge < TOP_BUFFER) {
        alert("Not enough space above to fit all of your nodes. Please try again.")
        return false
    }
    else if(bottom_edge > CANVAS_HEIGHT - NODE_DRAW_RADIUS) {
        alert("Not enough space below to fit all of your nodes. Please try again.")
        return false
    }
    //Now verify that there are not nodes in the rectangle
    for(let node of nodes) {
        if(left_edge <= node.x && node.x <= right_edge && top_edge <= node.y && node.y <= bottom_edge) {
            alert("Requested nodes will overlap with some of your existing nodes. Please try again.")
            return false
        }
    }
    //Finally verify that there are not iconizedGroups in the rectangle
    for(let icoGroup of iconizedGroups) {
        if(left_edge <= icoGroup.x + icoGroup.radius && icoGroup.x - icoGroup.radius <= right_edge 
            && top_edge <= icoGroup.y + icoGroup.radius && icoGroup.y - icoGroup.radius <= bottom_edge) {
            alert("Requested nodes will overlap with some of your existing iconized groups. Please try again.")
            return false
        }
    }

    return true
}

function sanityCheckGridDialogEntries(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr) {
    MINIMUM_PIXEL_SEPARATION = 20
    if(num_rows < 1) {
        alert("# Rows must be > 0!")
        document.getElementById("num_rows").focus()
        return false
    }
    else if(num_cols < 1) {
        alert("# Cols must be > 0!")
        document.getElementById("num_cols").focus()
        return false
    }
    else if(pixel_separation < MINIMUM_PIXEL_SEPARATION) {
        alert("Pixel separation must he at least " + MINIMUM_PIXEL_SEPARATION + "!")
        document.getElementById("separation").focus()
        return false
    }
    //now verify that we have room for the new nodes!
    width_needed =  num_cols*pixel_separation + 2*NODE_DRAW_RADIUS 
    height_needed = num_rows*pixel_separation + 2*NODE_DRAW_RADIUS

    left_edge = contextMenuClickPoint.x - NODE_DRAW_RADIUS
    right_edge = left_edge + width_needed
    top_edge = contextMenuClickPoint.y - NODE_DRAW_RADIUS
    bottom_edge = top_edge + height_needed

    return validateSpaceForNodes(left_edge, right_edge, top_edge, bottom_edge)
}

function renderGridOfNodes(num_rows, num_cols, pixel_separation, l1_connect, order_tb_lr) {
    //first create nodes
    let node_grid = []
    for(let i=0; i<num_rows; i++) {
        node_grid.push(new Array(num_cols))
    }
    if(order_tb_lr) {
        for(let i=0; i<num_rows; i++) {
            for(let j=0; j<num_cols; j++) {
                let x = contextMenuClickPoint.x + j*pixel_separation
                let y = contextMenuClickPoint.y + i*pixel_separation
                let node = new Node(x, y)
                node_grid[i][j] = node
                create_node(node)
            }
        }
    }
    else {
        for(let j=0; j<num_cols; j++) {
            for(let i=0; i<num_rows; i++) {
                let x = contextMenuClickPoint.x + j*pixel_separation
                let y = contextMenuClickPoint.y + i*pixel_separation
                let node = new Node(x, y)
                node_grid[i][j] = node
                create_node(node)
            }
        }
    }
    //next create edges, if requested
    if(l1_connect) {
        for(let i=0; i<num_rows; i++) {
            for(let j=0; j<num_cols; j++) {
                if(i < num_rows - 1) {
                    let edge = new Edge(node_grid[i][j], node_grid[i+1][j])
                    create_edge(edge)
                }
                if(j < num_cols - 1) {
                    let edge = new Edge(node_grid[i][j], node_grid[i][j+1])
                    create_edge(edge)
                }
            }
        }

    }
    redrawAll()
}

  cycleDialogHasEventListeners = false  //again a bit clugey, but....
  function requestInsertCycle() {
    console.log("Requested Insert Cycle....")
    const dialog = document.getElementById("cycle_dialog")
    document.getElementById("via_undir_edges").disabled = (edges.size + ultraEdges.size > 0  || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_dir_edges").disabled = (edges.size + ultraEdges.size > 0  || areThereEmbddedEdgesOrUltraEdges())
    document.getElementById("via_undir_edges").checked = (edge_type == TYPE_UNDIRECTED)
    document.getElementById("via_dir_edges").checked = (edge_type == TYPE_DIRECTED)
    
    submitButton = document.getElementById("cycle_submit_button")
    if(!cycleDialogHasEventListeners) {
        submitButton.addEventListener('click',(event) => {
            captureCycleDialogDetails(event)
        });
        dialog.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                cycleDailogCancelHandler()
            }
            else if(event.key === 'Enter' || event.keyCode === 13) {
                captureCycleDialogDetails(event)
            }
        });
        cycleDialogHasEventListeners = true
    }
    contextMenu.style.display = '';  //make sure contextMenu is no longer being shown
    dialog.showModal()  //returns immediately!
  }

  function cycleDailogCancelHandler() {
    console.log("cancel requested")
  }

  function captureCycleDialogDetails(event) {
    console.log("submit requested")
    let height = Number(document.getElementById("height").value)
    let width = Number(document.getElementById("width").value)
    let num_nodes = Number(document.getElementById("num_nodes").value)
    if(document.getElementById("via_undir_edges").checked) {
        edge_type = TYPE_UNDIRECTED
    }
    else {
        edge_type = TYPE_DIRECTED
    }
    res = sanityCheckCycleDialogEntries(height, width, num_nodes, event)
    if(res) {
        renderCycleOfNodes(height, width, num_nodes)
        clearSelection()
    } 
    else {
        event.preventDefault()
    }
  } 

  function sanityCheckCycleDialogEntries(height, width, num_nodes, event) {
    if(num_nodes < 3) {
        alert("# nodes must be at least 3!")
        document.getElementById("num_nodes").focus()
        return false
    }
    if(Math.ceil(num_nodes/2)*NODE_DRAW_RADIUS > Math.max(height,width)) {
        alert("Not enough pixels to accomodate requested number of nodes!")
        document.getElementById("height").focus()
        return false
    }

    //now verify that we have room for the new nodes!
    left_edge = contextMenuClickPoint.x - width/2 - NODE_DRAW_RADIUS
    right_edge = left_edge + width + 2*NODE_DRAW_RADIUS
    top_edge = contextMenuClickPoint.y - height/2 - NODE_DRAW_RADIUS
    bottom_edge = top_edge + height + 2*NODE_DRAW_RADIUS

    return validateSpaceForNodes(left_edge, right_edge, top_edge, bottom_edge)
}

function renderCycleOfNodes(height, width, num_nodes) {
    console.log("Would be rendering a cycle of " + num_nodes + " nodes.")
    //first create nodes
    let new_nodes = []
    let new_edges = []
    let x = contextMenuClickPoint.x
    let y = contextMenuClickPoint.y
    let p_x = p_y = 0
    if(num_nodes % 2 == 1) {
        if(width >= height) {
            p_x = x - width/2
            p_y = y
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=0; i<(num_nodes-1)/2; i++) {
                p_x = x - width/2 + (i+1)*width/((num_nodes-1)/2)
                p_y = y - height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            for(i = (num_nodes-3)/2; i>=0; i--) {
                p_x = x - width/2 + (i+1)*width/((num_nodes-1)/2)
                p_y = y + height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
        else {
            p_x = x
            p_y = y - height/2
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=0; i<(num_nodes-1)/2; i++) {
                p_x = x - width/2
                p_y = y - height/2 + (i+1)*height/((num_nodes-1)/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            for(i = (num_nodes-3)/2; i>=0; i--) {
                p_x = x + width/2
                p_y = y - height/2 + (i+1)*height/((num_nodes-1)/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
    }
    else {
        if(width >= height) {
            p_x = x - width/2
            p_y = y
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=1; i<num_nodes/2; i++) {
                p_x = x - width/2 +i*width/(num_nodes/2)
                p_y = y - height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            p_x = x + width/2
            p_y = y
            node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(i = (num_nodes/2) - 1; i>=1; i--) {
                p_x = x - width/2 + i*width/(num_nodes/2)
                p_y = y + height/2
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
        else {
            p_x = x
            p_y = y - height/2
            let node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(let i=1; i<num_nodes/2; i++) {
                p_x = x - width/2
                p_y = y - height/2 + i*height/(num_nodes/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
            p_x = x
            p_y = y + height/2
            node = new Node(p_x, p_y)
            new_nodes.push(node)
            create_node(node)
            for(i = (num_nodes/2) - 1; i>=1; i--) {
                p_x = x + width/2
                p_y = y - height/2 + i*height/(num_nodes/2)
                node = new Node(p_x, p_y)
                new_nodes.push(node)
                create_node(node)
            }
        }
    }
    for(i = 0; i<new_nodes.length - 1; i++) {
        let edge = new Edge(new_nodes[i], new_nodes[i+1])
        create_edge(edge)
    }
    edge = new Edge(new_nodes[new_nodes.length - 1], new_nodes[0])
    create_edge(edge)
    redrawAll()
}

  

</script>

<style>
  .mainMenu {
    display: grid;
    grid-template-columns: auto auto;
    grid-gap: 10px;
  }

  .shortcut {
    text-align: right;
    min-width: 80px; /* Adjust as needed */
  }

    #contextMenu {
        display: none;
        position: fixed;
        background-color: #f9f9f9;
        border: 1px solid #ccc;
        padding: 5px 0;
        min-width: 100px;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 1000;
    }

    #contextMenu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #contextMenu li {
        padding: 8px 15px;
        cursor: pointer;
    }

    #contextMenu li:hover {
        background-color: #e1e1e1;
    }

    #selfLoopMenu {
        display: none;
        position: fixed;
        background-color: #f9f9f9;
        border: 1px solid #ccc;
        padding: 5px 0;
        min-width: 100px;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 1000;
    }

    #selfLoopMenu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #selfLoopMenu li {
        padding: 8px 15px;
        cursor: pointer;
    }

    #selfLoopMenu li:hover {
        background-color: #e1e1e1;
    }

    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      background-color: #f0f0f0;  /**Gives the top menu its background color **/
      display: flex;
    }

    nav li {
      margin-right: 10px;  /** Controls the padding between top menu items **/
      font-family: Arial, Helvetica, sans-serif;
      font-weight: Bold;
      font-size: 12pt;
    }

    nav a {
      display: block;
      padding: 6px;  /** Controls the padding all around top menu items (top, bottom, left, right) **/
      text-decoration: none;
      color: #f0f0f0 /** #333;  **/
    }
</style>

<!--<input type="text" id="fname" name="fname">-->

</body>
</html>